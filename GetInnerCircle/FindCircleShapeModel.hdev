<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="17.12">
<procedure name="main">
<interface/>
<body>
<l>sopke_Paras:=[30,90,15]</l>
<l>read_image (Image1, 'C:/Users/sunru/Documents/WeChat Files/sunrh109989/FileStorage/File/2019-08/4/4/1.bmp')</l>
<l>get_image_size(Image1, Width, Height)</l>
<l>dev_close_window()</l>
<l>dev_open_window_fit_image(Image1, 0, 0, -1, -1, WindowHandle)</l>
<c></c>
<l>dev_display(Image1)</l>
<l>draw_spoke(Image1, Regions, WindowHandle, sopke_Paras[0], sopke_Paras[1], sopke_Paras[2], ROIRows, ROICols, Direct)</l>
<c></c>
<l>read_shape_model('CircleModel', ModelID1)</l>
<l>find_shape_model(Image1, ModelID1, -0.39, 0.79, 0.5, 1, 0.1, 'least_squares', 0, 0.9, RowOrigin, ColumnOrigin, AngleOrigin, Score1)</l>
<c></c>
<l>for Index := 1 to 10 by 1</l>
<l>read_image (Image1, 'C:/Users/sunru/Documents/WeChat Files/sunrh109989/FileStorage/File/2019-08/4/4/'+Index+'.bmp')</l>
<l>dev_close_window()</l>
<l>dev_open_window_fit_image(Image1, 0, 0, -1, -1, WindowHandle)</l>
<l>dev_display(Image1)</l>
<l>find_scaled_shape_model(Image1, ModelID1, -0.39, 0.78, 0.9, 1.1, 0.3, 1, 0.1, 'least_squares', 0, 0.9, Row1, Column1, Angle, Scale, Score)</l>
<l>*disp_cross(WindowHandle, Row1, Column1, 86, Angle)</l>
<l>*disp_message(WindowHandle, Score, 'image', Row1, Column1, 'black', 'true')</l>
<c></c>
<c></c>
<l>vector_angle_to_rigid( Row1, Column1, Angle,RowOrigin, ColumnOrigin, AngleOrigin, HomMat2D)</l>
<l>vector_angle_to_rigid(RowOrigin, ColumnOrigin, AngleOrigin, Row1, Column1, Angle, HomMat2D1)</l>
<l>affine_trans_image(Image1, ImageAffineTrans, HomMat2D, 'constant', 'false')</l>
<c></c>
<l>spoke(ImageAffineTrans, RegionAffineTrans, sopke_Paras[0], sopke_Paras[1], sopke_Paras[2], 1, 10, 'negative', 'first', ROIRows, ROICols, Direct, ResultRow, ResultColumn, ArcType)</l>
<c></c>
<l>gen_contour_polygon_xld(Contour,ResultRow, ResultColumn)</l>
<l>fit_circle_contour_xld(Contour, 'algebraic', -1, 0, 0, 3, 2, Row, Column, Radius, StartPhi, EndPhi, PointOrder)</l>
<c></c>
<l>gen_circle(Circle, Row, Column, Radius)</l>
<l>affine_trans_region(Circle, RegionAffineTrans1, HomMat2D1, 'nearest_neighbor')</l>
<c></c>
<c></c>
<l>dev_clear_window()</l>
<l>dev_set_line_width(1)</l>
<l>dev_set_draw('margin')</l>
<l>dev_display(Image1)</l>
<l>disp_cross(WindowHandle, Row1, Column1, 86, 0)</l>
<l>disp_message(WindowHandle, '图片'+Index, 'image', Row1+5, Column1+5, 'black', 'true')</l>
<l>disp_message(WindowHandle, '圆心：('+Row1+','+Column1+'）  半径：'+ Radius, 'image', Row1+105, Column1+5, 'black', 'true')</l>
<l>dev_display(RegionAffineTrans1)</l>
<c></c>
<l>stop()</l>
<l>endfor</l>
<l>clear_shape_model(ModelID1)</l>
<c></c>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="analyze_graph_event" access="local">
<interface>
<io>
<par name="BackgroundImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="MouseMapping" base_type="ctrl" dimension="0"/>
<par name="Button" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="VirtualTrackball" base_type="ctrl" dimension="0"/>
<par name="TrackballSize" base_type="ctrl" dimension="0"/>
<par name="SelectedObjectIn" base_type="ctrl" dimension="0"/>
<par name="Scene3D" base_type="ctrl" dimension="0"/>
<par name="AlphaOrig" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Labels" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="PosesIn" base_type="ctrl" dimension="0"/>
<par name="ButtonHoldIn" base_type="ctrl" dimension="0"/>
<par name="TBCenter" base_type="ctrl" dimension="0"/>
<par name="TBSize" base_type="ctrl" dimension="0"/>
<par name="WindowCenteredRotationlIn" base_type="ctrl" dimension="0"/>
<par name="MaxNumModels" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PosesOut" base_type="ctrl" dimension="0"/>
<par name="SelectedObjectOut" base_type="ctrl" dimension="0"/>
<par name="ButtonHoldOut" base_type="ctrl" dimension="0"/>
<par name="WindowCenteredRotationOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure reflects</c>
<c>* - the pose change that was introduced by the user by</c>
<c>*   moving the mouse</c>
<c>* - the selection of a single object</c>
<c>* </c>
<l>global tuple gIsSinglePose</l>
<c>* </c>
<l>ButtonHoldOut := ButtonHoldIn</l>
<l>PosesOut := PosesIn</l>
<l>SelectedObjectOut := SelectedObjectIn</l>
<l>WindowCenteredRotationOut := WindowCenteredRotationlIn</l>
<l>VisualizeTB := max(SelectedObjectOut) != 0</l>
<l>InvLog2 := 1.0 / log(2)</l>
<c>* </c>
<l>if (Button == MouseMapping[6])</l>
<l>    if (ButtonHoldOut)</l>
<l>        return ()</l>
<l>    endif</l>
<c>    * Ctrl (16) + Alt (32) + left mouse button (1) =&gt; Toggle rotation center position</c>
<c>    * If WindowCenteredRotation is not 1, set it to 1, otherwise, set it to 2</c>
<l>    count_seconds (Seconds)</l>
<l>    if (WindowCenteredRotationOut == 1)</l>
<l>        WindowCenteredRotationOut := 2</l>
<l>    else</l>
<l>        WindowCenteredRotationOut := 1</l>
<l>    endif</l>
<l>    ButtonHoldOut := true</l>
<l>    return ()</l>
<l>endif</l>
<l>if (Button == MouseMapping[5] and |ObjectModel3DID| &lt;= MaxNumModels)</l>
<l>    if (ButtonHoldOut)</l>
<l>        return ()</l>
<l>    endif</l>
<c>    * Ctrl (16) + left mouse button (1) =&gt; Select an object</c>
<l>    try</l>
<l>        set_scene_3d_param (Scene3D, 'object_index_persistence', 'true')</l>
<l>        display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>        get_display_scene_3d_info (WindowHandleBuffer, Scene3D, Row, Column, 'object_index', ModelIndex)</l>
<l>        set_scene_3d_param (Scene3D, 'object_index_persistence', 'false')</l>
<l>    catch (Exception1)</l>
<c>        * * NO OpenGL, no selection possible</c>
<l>        return ()</l>
<l>    endtry</l>
<l>    if (ModelIndex == -1)</l>
<c>        * Background click:</c>
<l>        if (sum(SelectedObjectOut) == |SelectedObjectOut|)</l>
<c>            * If all objects are already selected, deselect all</c>
<l>            SelectedObjectOut := gen_tuple_const(|ObjectModel3DID|,0)</l>
<l>        else</l>
<c>            * Otherwise select all</c>
<l>            SelectedObjectOut := gen_tuple_const(|ObjectModel3DID|,1)</l>
<l>        endif</l>
<l>    else</l>
<c>        * Object click:</c>
<l>        SelectedObjectOut[ModelIndex] := not SelectedObjectOut[ModelIndex]</l>
<l>    endif</l>
<l>    ButtonHoldOut := true</l>
<l>else</l>
<c>    * Change the pose</c>
<l>    hom_mat3d_identity (HomMat3DIdentity)</l>
<l>    NumModels := |ObjectModel3DID|</l>
<l>    get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>    get_cam_par_data (CamParam, 'image_height', Height)</l>
<l>    MinImageSize := min([Width,Height])</l>
<l>    TrackballRadiusPixel := TrackballSize * MinImageSize / 2.0</l>
<c>    * Set trackball fixed in the center of the window</c>
<l>    TrackballCenterRow := Height / 2</l>
<l>    TrackballCenterCol := Width / 2</l>
<l>    if (|ObjectModel3DID| &lt; MaxNumModels)</l>
<l>        if (WindowCenteredRotationOut == 1)</l>
<l>            get_trackball_center_fixed (SelectedObjectIn, TrackballCenterRow, TrackballCenterCol, TrackballRadiusPixel, Scene3D, ObjectModel3DID, PosesIn, WindowHandleBuffer, CamParam, GenParamName, GenParamValue, TBCenter, TBSize)</l>
<l>        else</l>
<l>            get_trackball_center (SelectedObjectIn, TrackballRadiusPixel, ObjectModel3DID, PosesIn, TBCenter, TBSize)</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (min(SelectedObjectOut) == 0 and max(SelectedObjectOut) == 1)</l>
<c>        * At this point, multiple objects do not necessary have the same</c>
<c>        * pose any more. Consequently, we have to return a tuple of poses</c>
<c>        * as output of visualize_object_model_3d</c>
<l>        gIsSinglePose := false</l>
<l>    endif</l>
<l>    count_channels (BackgroundImage, NumChannels)</l>
<l>    ColorImage := NumChannels == 3</l>
<c>    * Alt (32) =&gt; lower sensitivity</c>
<l>    tuple_rsh (Button, 5, BAnd)</l>
<l>    if (BAnd % 2)</l>
<l>        SensFactor := 0.1</l>
<l>    else</l>
<l>        SensFactor := 1.0</l>
<l>    endif</l>
<l>    IsButtonTrans := MouseMapping[0] == Button or (32 + MouseMapping[0]) == Button</l>
<l>    IsButtonRot := MouseMapping[1] == Button or (32 + MouseMapping[1]) == Button</l>
<l>    IsButtonDist := MouseMapping[2] == Button or (32 + MouseMapping[2]) == Button or MouseMapping[3] == Button or (32 + MouseMapping[3]) == Button or MouseMapping[4] == Button or (32 + MouseMapping[4]) == Button</l>
<l>    if (IsButtonTrans)</l>
<c>        * Translate in XY-direction</c>
<l>        MRow1 := Row</l>
<l>        MCol1 := Column</l>
<l>        while (IsButtonTrans)</l>
<l>            try</l>
<l>                get_mposition_sub_pix (WindowHandle, Row, Column, ButtonLoop)</l>
<l>                IsButtonTrans := ButtonLoop == Button</l>
<l>                MRow2 := MRow1 + (Row - MRow1) * SensFactor</l>
<l>                MCol2 := MCol1 + (Column - MCol1) * SensFactor</l>
<l>                get_line_of_sight (MRow1, MCol1, CamParam, PX, PY, PZ, QX1, QY1, QZ1)</l>
<l>                get_line_of_sight (MRow2, MCol2, CamParam, PX, PY, PZ, QX2, QY2, QZ2)</l>
<l>                Len := sqrt(QX1 * QX1 + QY1 * QY1 + QZ1 * QZ1)</l>
<l>                Dist := sqrt(TBCenter[0] * TBCenter[0] + TBCenter[1] * TBCenter[1] + TBCenter[2] * TBCenter[2])</l>
<l>                Translate := [QX2 - QX1,QY2 - QY1,QZ2 - QZ1] * Dist / Len</l>
<l>                PosesOut := []</l>
<l>                if (NumModels &lt;= MaxNumModels)</l>
<l>                    for Index := 0 to NumModels - 1 by 1</l>
<l>                        PoseIn := PosesIn[Index * 7:Index * 7 + 6]</l>
<l>                        if (SelectedObjectOut[Index])</l>
<l>                            pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, Translate[0], Translate[1], Translate[2], HomMat3DOut)</l>
<l>                            hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                            set_scene_3d_instance_pose (Scene3D, Index, PoseOut)</l>
<l>                        else</l>
<l>                            PoseOut := PoseIn</l>
<l>                        endif</l>
<l>                        PosesOut := [PosesOut,PoseOut]</l>
<l>                    endfor</l>
<l>                else</l>
<l>                    tuple_find (SelectedObjectOut, 1, Indices)</l>
<l>                    PoseIn := PosesIn[Indices[0] * 7:Indices[0] * 7 + 6]</l>
<l>                    pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                    hom_mat3d_translate (HomMat3DIn, Translate[0], Translate[1], Translate[2], HomMat3DOut)</l>
<l>                    hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                    Sequence := [0:NumModels * 7 - 1]</l>
<l>                    tuple_mod (Sequence, 7, Mod)</l>
<l>                    SequenceReal := [0:1.0 / 7.0:NumModels - (1.0 / 7.0)]</l>
<l>                    Sequence2Int := int(SequenceReal)</l>
<l>                    tuple_select (SelectedObjectOut, Sequence2Int, Selected)</l>
<l>                    InvSelected := 1 - Selected</l>
<l>                    tuple_select (PoseOut, Mod, PosesOut)</l>
<l>                    PosesOut := PosesOut * Selected + PosesIn * InvSelected</l>
<l>                    set_scene_3d_instance_pose (Scene3D, [0:NumModels - 1], PosesOut)</l>
<l>                endif</l>
<l>                dump_image_output (BackgroundImage, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3DID, GenParamName, GenParamValue, CamParam, PosesOut, ColorImage, Title, Information, Labels, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObjectOut, WindowCenteredRotationOut == 1, TBCenter)</l>
<l>                dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>                dev_set_window (WindowHandle)</l>
<l>                dev_display (ImageDump)</l>
<c>                * </c>
<l>                MRow1 := Row</l>
<l>                MCol1 := Column</l>
<l>                PosesIn := PosesOut</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>    elseif (IsButtonDist)</l>
<c>        * Change the Z distance</c>
<l>        MRow1 := Row</l>
<l>        while (IsButtonDist)</l>
<l>            try</l>
<l>                get_mposition_sub_pix (WindowHandle, Row, Column, ButtonLoop)</l>
<l>                IsButtonDist := ButtonLoop == Button</l>
<l>                MRow2 := Row</l>
<l>                DRow := MRow2 - MRow1</l>
<l>                Dist := sqrt(TBCenter[0] * TBCenter[0] + TBCenter[1] * TBCenter[1] + TBCenter[2] * TBCenter[2])</l>
<l>                TranslateZ := -Dist * DRow * 0.003 * SensFactor</l>
<l>                TBCenter[2] := TBCenter[2] + TranslateZ</l>
<l>                PosesOut := []</l>
<l>                if (NumModels &lt;= MaxNumModels)</l>
<l>                    for Index := 0 to NumModels - 1 by 1</l>
<l>                        PoseIn := PosesIn[Index * 7:Index * 7 + 6]</l>
<l>                        if (SelectedObjectOut[Index])</l>
<c>                            * Transform the whole scene or selected object only</c>
<l>                            pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, 0, 0, TranslateZ, HomMat3DOut)</l>
<l>                            hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                            set_scene_3d_instance_pose (Scene3D, Index, PoseOut)</l>
<l>                        else</l>
<l>                            PoseOut := PoseIn</l>
<l>                        endif</l>
<l>                        PosesOut := [PosesOut,PoseOut]</l>
<l>                    endfor</l>
<l>                else</l>
<l>                    tuple_find (SelectedObjectOut, 1, Indices)</l>
<l>                    PoseIn := PosesIn[Indices[0] * 7:Indices[0] * 7 + 6]</l>
<l>                    pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                    hom_mat3d_translate (HomMat3DIn, 0, 0, TranslateZ, HomMat3DOut)</l>
<l>                    hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                    Sequence := [0:NumModels * 7 - 1]</l>
<l>                    tuple_mod (Sequence, 7, Mod)</l>
<l>                    SequenceReal := [0:1.0 / 7.0:NumModels - (1.0 / 7.0)]</l>
<l>                    Sequence2Int := int(SequenceReal)</l>
<l>                    tuple_select (SelectedObjectOut, Sequence2Int, Selected)</l>
<l>                    InvSelected := 1 - Selected</l>
<l>                    tuple_select (PoseOut, Mod, PosesOut)</l>
<l>                    PosesOut := PosesOut * Selected + PosesIn * InvSelected</l>
<l>                    set_scene_3d_instance_pose (Scene3D, [0:NumModels - 1], PosesOut)</l>
<l>                endif</l>
<l>                dump_image_output (BackgroundImage, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3DID, GenParamName, GenParamValue, CamParam, PosesOut, ColorImage, Title, Information, Labels, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObjectOut, WindowCenteredRotationOut, TBCenter)</l>
<l>                dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>                dev_set_window (WindowHandle)</l>
<l>                dev_display (ImageDump)</l>
<c>                * </c>
<l>                MRow1 := Row</l>
<l>                PosesIn := PosesOut</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>    elseif (IsButtonRot)</l>
<c>        * Rotate the object</c>
<l>        MRow1 := Row</l>
<l>        MCol1 := Column</l>
<l>        while (IsButtonRot)</l>
<l>            try</l>
<l>                get_mposition_sub_pix (WindowHandle, Row, Column, ButtonLoop)</l>
<l>                IsButtonRot := ButtonLoop == Button</l>
<l>                MRow2 := Row</l>
<l>                MCol2 := Column</l>
<c>                * Transform the pixel coordinates to relative image coordinates</c>
<l>                MX1 := (TrackballCenterCol - MCol1) / (0.5 * MinImageSize)</l>
<l>                MY1 := (TrackballCenterRow - MRow1) / (0.5 * MinImageSize)</l>
<l>                MX2 := (TrackballCenterCol - MCol2) / (0.5 * MinImageSize)</l>
<l>                MY2 := (TrackballCenterRow - MRow2) / (0.5 * MinImageSize)</l>
<c>                * Compute the quaternion rotation that corresponds to the mouse</c>
<c>                * movement</c>
<l>                trackball (MX1, MY1, MX2, MY2, VirtualTrackball, TrackballSize, SensFactor, RelQuaternion)</l>
<c>                * Transform the quaternion to a rotation matrix</c>
<l>                quat_to_hom_mat3d (RelQuaternion, HomMat3DRotRel)</l>
<l>                PosesOut := []</l>
<l>                if (NumModels &lt;= MaxNumModels)</l>
<l>                    for Index := 0 to NumModels - 1 by 1</l>
<l>                        PoseIn := PosesIn[Index * 7:Index * 7 + 6]</l>
<l>                        if (SelectedObjectOut[Index])</l>
<c>                            * Transform the whole scene or selected object only</c>
<l>                            pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, -TBCenter[0], -TBCenter[1], -TBCenter[2], HomMat3DIn)</l>
<l>                            hom_mat3d_compose (HomMat3DRotRel, HomMat3DIn, HomMat3DIn)</l>
<l>                            hom_mat3d_translate (HomMat3DIn, TBCenter[0], TBCenter[1], TBCenter[2], HomMat3DOut)</l>
<l>                            hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                            set_scene_3d_instance_pose (Scene3D, Index, PoseOut)</l>
<l>                        else</l>
<l>                            PoseOut := PoseIn</l>
<l>                        endif</l>
<l>                        PosesOut := [PosesOut,PoseOut]</l>
<l>                    endfor</l>
<l>                else</l>
<l>                    tuple_find (SelectedObjectOut, 1, Indices)</l>
<l>                    PoseIn := PosesIn[Indices[0] * 7:Indices[0] * 7 + 6]</l>
<l>                    pose_to_hom_mat3d (PoseIn, HomMat3DIn)</l>
<l>                    hom_mat3d_translate (HomMat3DIn, -TBCenter[0], -TBCenter[1], -TBCenter[2], HomMat3DInTmp1)</l>
<l>                    hom_mat3d_compose (HomMat3DRotRel, HomMat3DInTmp1, HomMat3DInTmp)</l>
<l>                    hom_mat3d_translate (HomMat3DInTmp, TBCenter[0], TBCenter[1], TBCenter[2], HomMat3DOut)</l>
<l>                    hom_mat3d_to_pose (HomMat3DOut, PoseOut)</l>
<l>                    Sequence := [0:NumModels * 7 - 1]</l>
<l>                    tuple_mod (Sequence, 7, Mod)</l>
<l>                    SequenceReal := [0:1.0 / 7.0:NumModels - (1.0 / 7.0)]</l>
<l>                    Sequence2Int := int(SequenceReal)</l>
<l>                    tuple_select (SelectedObjectOut, Sequence2Int, Selected)</l>
<l>                    InvSelected := 1 - Selected</l>
<l>                    tuple_select (PoseOut, Mod, PosesOut)</l>
<l>                    PosesOut2 := PosesOut * Selected + PosesIn * InvSelected</l>
<l>                    PosesOut := PosesOut2</l>
<l>                    set_scene_3d_instance_pose (Scene3D, [0:NumModels - 1], PosesOut)</l>
<l>                endif</l>
<l>                dump_image_output (BackgroundImage, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3DID, GenParamName, GenParamValue, CamParam, PosesOut, ColorImage, Title, Information, Labels, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObjectOut, WindowCenteredRotationOut, TBCenter)</l>
<l>                dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>                dev_set_window (WindowHandle)</l>
<l>                dev_display (ImageDump)</l>
<c>                * </c>
<l>                MRow1 := Row</l>
<l>                MCol1 := Column</l>
<l>                PosesIn := PosesOut</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>    endif</l>
<l>    PosesOut := PosesIn</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="analyze_graph_event">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Reflect the pose change that was introduced by the user by moving the mouse</short>
<parameters>
<parameter id="AlphaOrig"/>
<parameter id="BackgroundImage"/>
<parameter id="Button"/>
<parameter id="ButtonHoldIn"/>
<parameter id="ButtonHoldOut"/>
<parameter id="CamParam"/>
<parameter id="Column"/>
<parameter id="GenParamName"/>
<parameter id="GenParamValue"/>
<parameter id="Information"/>
<parameter id="Labels"/>
<parameter id="MaxNumModels"/>
<parameter id="MouseMapping"/>
<parameter id="ObjectModel3DID"/>
<parameter id="PosesIn"/>
<parameter id="PosesOut"/>
<parameter id="Row"/>
<parameter id="Scene3D"/>
<parameter id="SelectedObjectIn"/>
<parameter id="SelectedObjectOut"/>
<parameter id="TBCenter"/>
<parameter id="TBSize"/>
<parameter id="Title"/>
<parameter id="TrackballSize"/>
<parameter id="VirtualTrackball"/>
<parameter id="WindowCenteredRotationOut"/>
<parameter id="WindowCenteredRotationlIn"/>
<parameter id="WindowHandle"/>
<parameter id="WindowHandleBuffer"/>
</parameters>
</docu>
</procedure>
<procedure name="append_length_or_values">
<interface>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Feature" base_type="ctrl" dimension="0"/>
<par name="AccumulatedResults" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ExtendedResults" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Auxiliary procedure used only by get_features and get_custom_features</c>
<c>* </c>
<l>if (Mode == 'get_lengths')</l>
<c>    * Output in 'get_lengths' mode is the length of the feature</c>
<l>    ExtendedResults := [AccumulatedResults,|Feature|]</l>
<l>elseif (Mode == 'calculate')</l>
<c>    * Output in 'calculate' mode is the feature vector</c>
<l>    ExtendedResults := [AccumulatedResults,Feature]</l>
<l>else</l>
<l>    ExtendedResults := AccumulatedResults</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="append_length_or_values">
<abstract lang="en_US">This procedure is an auxiliary procedure for the get_custom_features and get_features procedures.
Please do not use it in other contexts.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

See documentation of get_custom_features for details on how to integrate user-defined features into this library.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Auxiliary procedure for get_custom_features and get_features.</short>
<parameters>
<parameter id="AccumulatedResults">
<description lang="en_US">Accumulated results from get_features.</description>
<multivalue>optional</multivalue>
</parameter>
<parameter id="ExtendedResults">
<default_type>real</default_type>
<description lang="en_US">The accumulated results extended by the feature vector or its length.</description>
</parameter>
<parameter id="Feature">
<description lang="en_US">Current feature vector.</description>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Processing mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_lengths'</item>
<item>'get_groups'</item>
<item>'calculate'</item>
</value_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="append_names_or_groups">
<interface>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Name" base_type="ctrl" dimension="0"/>
<par name="Groups" base_type="ctrl" dimension="0"/>
<par name="CurrentName" base_type="ctrl" dimension="0"/>
<par name="AccumulatedResults" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ExtendedResults" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Auxiliary procedure used only by get_features and get_custom_features</c>
<c>* </c>
<l>ExtendedResults := AccumulatedResults</l>
<l>if (Mode == 'get_names')</l>
<l>    FirstOccurrence := |AccumulatedResults| == 0 or find(AccumulatedResults,Name) == -1</l>
<l>    BelongsToGroup := find([Name,Groups],CurrentName) != -1 or CurrentName == 'all'</l>
<l>    if (FirstOccurrence and BelongsToGroup)</l>
<c>        * Output in 'get_names' mode is the name of the feature</c>
<l>        ExtendedResults := [AccumulatedResults,Name]</l>
<l>    endif</l>
<l>elseif (Mode == 'get_groups')</l>
<l>    ExtendedResults := [AccumulatedResults,Groups]</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="append_names_or_groups">
<abstract lang="en_US">This procedure is an auxiliary procedure for the get_custom_features and get_features procedures. Please do not use it in other contexts.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

See documentation of get_custom_features for details on how to integrate user-defined features into this library.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Auxiliary procedure for get_custom_features and get_features.</short>
<parameters>
<parameter id="AccumulatedResults">
<description lang="en_US">Accumulated results from get_features.</description>
<multivalue>optional</multivalue>
</parameter>
<parameter id="CurrentName">
<default_type>string</default_type>
<description lang="en_US">Current feature or group name.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ExtendedResults">
<default_type>string</default_type>
<description lang="en_US">The accumulated results extended by the feature name or the feature groups.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Groups">
<default_type>string</default_type>
<description lang="en_US">Feature group names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Processing mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_lengths'</item>
<item>'get_groups'</item>
<item>'calculate'</item>
</value_list>
</parameter>
<parameter id="Name">
<default_type>string</default_type>
<description lang="en_US">Feature name.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="append_names_or_groups_pyramid">
<interface>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Groups" base_type="ctrl" dimension="0"/>
<par name="CurrentName" base_type="ctrl" dimension="0"/>
<par name="Names" base_type="ctrl" dimension="0"/>
<par name="NameRegExp" base_type="ctrl" dimension="0"/>
<par name="AccumulatedResults" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ExtendedResults" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Auxiliary procedure used only by get_features and get_custom_features</c>
<c>* </c>
<l>ExtendedResults := AccumulatedResults</l>
<l>if (Mode == 'get_names')</l>
<l>    BelongsToGroup := find(Groups,CurrentName) != -1 or CurrentName == 'all'</l>
<l>    if (CurrentName =~ NameRegExp)</l>
<l>        Names := CurrentName</l>
<l>    elseif (not BelongsToGroup)</l>
<l>        Names := []</l>
<l>    endif</l>
<l>    TmpNames := []</l>
<l>    for J := 0 to |Names| - 1 by 1</l>
<l>        FirstOccurrence := |AccumulatedResults| == 0 or find(AccumulatedResults,Names[J]) == -1</l>
<l>        if (FirstOccurrence)</l>
<c>            * Output in 'get_names' mode is the name of the feature</c>
<l>            TmpNames := [TmpNames,Names[J]]</l>
<l>        endif</l>
<l>    endfor</l>
<l>    ExtendedResults := [AccumulatedResults,TmpNames]</l>
<l>elseif (Mode == 'get_groups')</l>
<l>    ExtendedResults := [AccumulatedResults,Groups]</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="append_names_or_groups_pyramid">
<abstract lang="en_US">This procedure is an auxiliary procedure for the get_custom_features and get_features procedures. Please do not use it in other contexts.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

See documentation of get_custom_features for details on how to integrate user-defined features into this library.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Auxiliary procedure for get_features.</short>
<parameters>
<parameter id="AccumulatedResults">
<description lang="en_US">Accumulated results from get_features.</description>
</parameter>
<parameter id="CurrentName">
<default_type>string</default_type>
<description lang="en_US">Current feature or group name.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ExtendedResults">
<default_type>string</default_type>
<description lang="en_US">The accumulated results depending on the mode extended by the feature names or the feature groups.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Groups">
<default_type>string</default_type>
<description lang="en_US">Feature group names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Processing mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_lengths'</item>
<item>'get_groups'</item>
<item>'calculate'</item>
</value_list>
</parameter>
<parameter id="NameRegExp">
<default_type>string</default_type>
<description lang="en_US">Regular expression that describes the feature names.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Names">
<default_type>string</default_type>
<description lang="en_US">Feature names.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="apply_brightness_variation_spot" access="local">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageSpot" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="SpotSize" base_type="ctrl" dimension="0"/>
<par name="SpotRow" base_type="ctrl" dimension="0"/>
<par name="SpotColumn" base_type="ctrl" dimension="0"/>
<par name="BrightnessVariation" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure applies a brightness spot </c>
<c>* of a given intensity and size at a given location </c>
<c>* to the input image.</c>
<c>* The modified image is returned in ImageSpot.</c>
<c>*</c>
<l>if (BrightnessVariation &lt; 0)</l>
<l>    Direction := 0</l>
<l>    BrightnessVariation := -BrightnessVariation</l>
<l>else</l>
<l>    Direction := 1</l>
<l>endif</l>
<l>get_image_size (Image, Width, Height)</l>
<c>* Generate Gauss filter that simulates an illumination spot of size 'SpotSize'.</c>
<l>gen_gauss_filter (Filter, 1, 1, 0, 'none', 'dc_center', SpotSize, SpotSize)</l>
<c>* Shift the filter image to the given position.</c>
<l>ShiftRow := -(SpotSize/2-SpotRow)</l>
<l>ShiftCol := -(SpotSize/2-SpotColumn)</l>
<l>tile_images_offset (Filter, GaussImage, ShiftRow, ShiftCol, -1, -1, -1, -1, Width, Height)</l>
<l>full_domain (GaussImage, GaussFilter)</l>
<c>* Convert Gauss filter to target image type and apply brightness variation.</c>
<l>get_image_type (Image, Type)</l>
<l>scale_image (GaussFilter, Gauss, BrightnessVariation, 0)</l>
<l>convert_image_type (Gauss, GaussTargetType, Type)</l>
<c>* Add channels to fit input image.</c>
<l>count_channels (Image, NChannels)</l>
<l>copy_obj (GaussTargetType, AddImage, 1, 1)</l>
<l>for Index1 := 1 to NChannels-1 by 1</l>
<l>    append_channel (AddImage, GaussTargetType, AddImage)</l>
<l>endfor</l>
<c>* Apply on image.</c>
<l>if (Direction)</l>
<l>    add_image (Image, AddImage, ImageSpot, 1, 0)</l>
<l>else</l>
<l>    sub_image (Image, AddImage, ImageSpot, 1, 0)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="apply_brightness_variation_spot">
<chapters lang="de_DE">
<item>Bild</item>
</chapters>
<chapters lang="en_US">
<item>Image</item>
<item>Manipulation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="BrightnessVariation"/>
<parameter id="Image"/>
<parameter id="ImageSpot"/>
<parameter id="SpotColumn"/>
<parameter id="SpotRow"/>
<parameter id="SpotSize"/>
</parameters>
</docu>
</procedure>
<procedure name="apply_dl_classifier_batchwise">
<interface>
<ic>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
<par name="DLClassifierHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DLClassifierResultIDs" base_type="ctrl" dimension="0"/>
<par name="PredictedClasses" base_type="ctrl" dimension="1"/>
<par name="Confidences" base_type="ctrl" dimension="1"/>
</oc>
</interface>
<body>
<c>* This procedure classifies the images given as paths </c>
<c>* by ImageFiles using the operator apply_dl_classifier. </c>
<c>* To avoid that the main memory is overloaded, the images </c>
<c>* are classified batchwise, according to the hyperparameter 'batch_size', </c>
<c>* which is stored in the DLClassifierHandle. </c>
<c>* As result, the classification result handles for every batch </c>
<c>* are returned in DLClassifierResultIDs. </c>
<c>* Additionally, for every image the descending sorted </c>
<c>* Confidences and corresponding PredictedClasses </c>
<c>* are returned as vectors. </c>
<c>*</c>
<c>* Get batch size from handle.</c>
<l>get_dl_classifier_param (DLClassifierHandle, 'batch_size', BatchSize)</l>
<c>*</c>
<c>* Check the input parameters.</c>
<l>if (|ImageFiles| &lt; 1)</l>
<l>    throw ('ImageFiles must not be empty.')</l>
<l>endif</l>
<c>*</c>
<c>* Sequence is used for easier indexing of the images.</c>
<l>NumImages := |ImageFiles|</l>
<l>Sequence := [0:NumImages-1]</l>
<c>*</c>
<c>* Loop through all selected images.</c>
<l>PredictedClasses := {}</l>
<l>Confidences := {}</l>
<l>DLClassifierResultIDs := []</l>
<l>for BatchStartIndex := 0 to NumImages-1 by BatchSize</l>
<c>    * Select the data for the current batch.</c>
<l>    BatchIndices := Sequence[BatchStartIndex:min2(BatchStartIndex + BatchSize-1, NumImages-1)]</l>
<l>    BatchImageFiles := ImageFiles[BatchIndices]</l>
<c>    * Read the current batch images.</c>
<l>    read_image (BatchImages, BatchImageFiles)</l>
<c>    * Apply the classifier for this batch.</c>
<l>    try</l>
<l>        apply_dl_classifier (BatchImages, DLClassifierHandle, DLClassifierResultID) </l>
<l>    catch (Exception)</l>
<l>        if (sum(Exception[0] [==] [2106, 2107, 3122, 9001, 9003]))</l>
<l>            throw ('Images need to fulfill the network requirements, please provide preprocessed images.')</l>
<l>        else</l>
<l>            throw (Exception)</l>
<l>        endif</l>
<l>    endtry</l>
<c>    * Get results from result handle.</c>
<l>    NumImagesInBatch := |BatchImageFiles|</l>
<l>    for Index := 0 to NumImagesInBatch-1 by 1</l>
<l>        get_dl_classifier_result(DLClassifierResultID, Index, 'predicted_classes', PredictedClass)</l>
<l>        get_dl_classifier_result(DLClassifierResultID, Index, 'confidences', ClassConfidence)</l>
<c>        * Store the classification results.</c>
<l>        VectorIndex := BatchStartIndex + Index</l>
<l>        PredictedClasses.at(VectorIndex) := PredictedClass</l>
<l>        Confidences.at(VectorIndex) := ClassConfidence</l>
<l>    endfor</l>
<l>    DLClassifierResultIDs := [DLClassifierResultIDs, DLClassifierResultID]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="apply_dl_classifier_batchwise">
<abstract lang="de_DE">Diese Prozedur klassifiziert die Bilder, die als Pfade in ImageFiles übergeben werden, mit dem Operator apply_dl_classifier. Um zu verhindern, dass der Arbeitsspeicher überlastet wird, werden die Bilder batchweise klassifiziert, wobei die Größe der Batches durch den im DLClassifierHandle gespeicherte Hyperparameter 'batch_size' gegeben ist. Als Ergebnis werden die Result-Handles DLClassifierResultIDs für jeden Batch zurückgegeben. Außerdem werden in den beiden Vektoren Confidences und PredictedClasses für jedes Bild ein Tupel mit den Konfidenzen in absteigender Reihenfolge und ein Tupel mit den dazugehörigen gefolgerten Klassen zurückgegeben.

Die Reihenfolge der Tupel-Elemente der Ausgabe-Vektoren PredictedClasses und Confidences entspricht den Eingabe-Bildern ImageFiles. Die Bilder, die über ImageFiles gelesen werden, müssen schon so vorliegen wie vom Netzwerk erwartet (siehe Referenzeintrag von read_dl_classifier). Wenn die Bilder beim Training noch gesondert vorverarbeitet wurden, sollte auch diese Vorverarbeitung bereits auf die Bilder angewendet worden sein. 

Die Result-Handles DLClassifierResultIDs können zum Beispiel an evaluate_dl_classifier übergeben werden, um Messwerte für die Leistungsfähigkeit des Klassifikators zu erhalten. Wenn apply_dl_classifier_batchwise und evaluate_dl_classifier während dem Training benutzt werden, um den Fortschritt des Trainings zu evaluieren, kann es sinnvoll sein, die Menge an zu evaluierenden Daten zu reduzieren, um die Laufzeit zu senken. Dafür kann die Prozedur select_percentage_dl_classifier_data verwendet werden.

Diese Prozedur gibt ein Handle zurück. Wenn das Handle nicht mehr gebraucht wird, sollte der Speicher, der dafür alloziert wird, mit clear_dl_result freigegeben werden.</abstract>
<abstract lang="en_US">This procedure classifies the images given as paths by ImageFiles using the operator apply_dl_classifier. To avoid that the main memory is overloaded, the images are classified batchwise, according to the hyperparameter 'batch_size', which is stored in the DLClassifierHandle. As result, the classification result handles for every batch are returned in DLClassifierResultIDs. Additionally, for every image a tuple with the ascending sorted Confidences and corresponding PredictedClasses are returned in the vectors of that name. 

The tuples in the output vectors PredictedClasses and Confidences are sorted in the same order as the input ImageFiles. The read ImageFiles must already be preprocessed as specified by the network (see rerence entry of read_dl_classifier). If there was a custom preprocessing during training, this preprocessing should have been applied to the read images as well.

The result handles DLClassifierResultIDs can be passed on to the procedure evaluate_dl_classifier, to get evaluation measures of the classifier performance. If you use apply_dl_classifier_batchwise and evaluate_dl_classifier during training to evaluate the training progress, you might want to reduce the amount of data handed over to save runtime. The latter can be achieved using the procedure select_percentage_dl_classifier_data.

This procedure returns a handle. This handle should be cleared using clear_dl_result when it is not needed anymore, to free the allocated memory.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Klassifikation</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="de_DE">Zurückgeben des Klassifikationsergebnisse für die übergebenen Bilder.</short>
<short lang="en_US">Return the classification results for the given images.</short>
<parameters>
<parameter id="Confidences">
<default_type>real</default_type>
<description lang="de_DE">Die zu den Klassen gehörigen Konfidenzen.</description>
<description lang="en_US">The confidences belonging to the PredictedClasses.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DLClassifierHandle">
<default_type>integer</default_type>
<description lang="de_DE">Handle des Deep Learning-basierten Klassifikators.</description>
<description lang="en_US">Handle of the deep-learning-based classifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_classifier</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLClassifierResultIDs">
<default_type>integer</default_type>
<description lang="de_DE">Das Tuple mit den Resultat-Handles (jeweilige Ergebnisse von apply_dl_classifier).</description>
<description lang="en_US">The tuple of result handles (respective results of apply_dl_classifier).</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dl_classifier_result</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="de_DE">Tuple mit den Bildpfaden.</description>
<description lang="en_US">Tuple of the image paths. </description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="PredictedClasses">
<default_type>string</default_type>
<description lang="de_DE">Die vom Klassifikator vorhergesagten Klassen.</description>
<description lang="en_US">The classes predicted from the classifier.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="augment_images">
<interface>
<io>
<par name="Images" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImagesAugmented" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure can be used to augment given input Images</c>
<c>* using different methods, which can be specified using </c>
<c>* GenParamName and GenParamValue. The augmented images are returned</c>
<c>* in ImagesAugmented. </c>
<c>*</c>
<c>* Set default parameters.</c>
<c>*</c>
<c>* The percentages of the images that are to be augmented.</c>
<l>AugmentationPercentage := ['augmentation_percentage', 50]</l>
<c>* Fraction of image length and width that remains after cropping (in %).</c>
<l>CropPercentage := ['crop_percentage', 'off']</l>
<c>* Image length and width that remains after cropping (in pixel).</c>
<l>CropPixel := ['crop_pixel', 'off']</l>
<c>* Step size for possible rotations.</c>
<l>Rotation := ['rotate', 0]</l>
<c>* Step range for rotations with step size 1.</c>
<l>RotationRange := ['rotate_range', 0]</l>
<c>* Allowed mirroring methods coded by 'r' (row), 'c' (column).</c>
<l>Mirror := ['mirror', 'off']</l>
<c>* The absolute brightness change can vary in the range[-value, +value].</c>
<l>BrightnessVariation := ['brightness_variation', 0]</l>
<c>* The absolute brightness peak of a randomly positioned spot can vary in the range[-value, +value].</c>
<l>BrightnessVariationSpot := ['brightness_variation_spot', 0]</l>
<c>*</c>
<c>* Parse the generic parameters.</c>
<c>*</c>
<c>* Check if GenParamName matches GenParamValue.</c>
<l>if (|GenParamName| != |GenParamValue|)</l>
<l>    throw ('Number of generic parameters does not match number of generic parameter values')</l>
<l>endif</l>
<c>* Check for generic parameter names and overwrite defaults.</c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>    CurrentParamName := GenParamName[GenParamIndex]</l>
<l>    CurrentParamValue := GenParamValue[GenParamIndex]</l>
<c>    *</c>
<l>    if (CurrentParamName == AugmentationPercentage[0])</l>
<c>        * Set augmentation percentage.</c>
<l>        AugmentationPercentage[1] := CurrentParamValue</l>
<c>        * Check if input value is in range of 1-100 %.</c>
<l>        if (is_number(CurrentParamValue)) </l>
<l>            if (CurrentParamValue&lt;1 or CurrentParamValue &gt;100)</l>
<l>                throw ('The given value for augmentation_percentage has to be in the range 1-100.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('The given value for augmentation_percentage has to be in the range 1-100.')</l>
<l>        endif</l>
<l>    elseif (CurrentParamName == Rotation[0])</l>
<c>        * Set rotation.</c>
<l>        Rotation[1] := CurrentParamValue</l>
<c>        * Check if input value is in range of 0-180 deg.</c>
<l>        if (is_number(CurrentParamValue)) </l>
<l>            if (CurrentParamValue&lt;0 or CurrentParamValue&gt;180)</l>
<l>                throw ('The given value for rotate has to be in the range 0-180.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('The given value for rotate has to be in the range 0-180.')</l>
<l>        endif</l>
<l>    elseif (CurrentParamName == RotationRange[0])</l>
<c>        * Set rotation.</c>
<l>        RotationRange[1] := CurrentParamValue</l>
<c>        * Check if input value is in range of 0-180 deg.</c>
<l>        if (is_number(CurrentParamValue))</l>
<l>            if (CurrentParamValue&lt;0 or CurrentParamValue&gt;180)</l>
<l>                throw ('The given value for rotate_range has to be in the range 0-180."')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('The given value for rotate_range has to be in the range 0-180.')</l>
<l>        endif</l>
<l>    elseif (CurrentParamName == Mirror[0])</l>
<c>        * Set mirroring.</c>
<l>        Mirror[1] := CurrentParamValue</l>
<c>        * Check if input is string and is 'off' or contains the wanted strings.</c>
<l>        if (is_number(CurrentParamValue) or not(CurrentParamValue=='off' or CurrentParamValue == 'c' or CurrentParamValue == 'r' or CurrentParamValue == 'cr' or CurrentParamValue == 'rc'))</l>
<l>            throw('Unknown mirror method.')</l>
<l>        endif</l>
<l>    elseif (CurrentParamName == CropPercentage[0])</l>
<c>        * Set cropping with percentage.</c>
<l>        CropPercentage[1] := CurrentParamValue</l>
<c>        * Check if input value is in range of 1-100 %.</c>
<l>        if (is_number(CurrentParamValue)) </l>
<l>            if (CurrentParamValue&lt;1 or CurrentParamValue&gt;100)</l>
<l>                throw ('The given value for crop_percentage has to be in the range 1-100.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('The given value for crop_percentage has to be in the range 1-100.')</l>
<l>        endif</l>
<l>    elseif (CurrentParamName == CropPixel[0])</l>
<c>        * Set cropping with pixels.</c>
<l>        CropPixel[1] := CurrentParamValue</l>
<c>        * Check if input value is greater 0.</c>
<l>        if (is_number(CurrentParamValue)) </l>
<l>            if (CurrentParamValue&lt;1)</l>
<l>                throw ('The given value for crop_pixel has to be greater then or equal to 1.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('The given value for crop_pixel has to be a string.')</l>
<l>        endif</l>
<l>    elseif (CurrentParamName == BrightnessVariation[0])</l>
<c>        * Set brightness variation.</c>
<l>        BrightnessVariation[1] := CurrentParamValue</l>
<c>        * Check if input value is in range of 0-255.</c>
<l>        if (is_number(CurrentParamValue)) </l>
<l>            if (CurrentParamValue&lt;0 or CurrentParamValue&gt;255)</l>
<l>                throw ('The given value for brightness_variation has to be in the range 0-255.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('The given value for brightness_variation has to be in the range 0-255.')</l>
<l>        endif</l>
<l>    elseif (CurrentParamName == BrightnessVariationSpot[0])</l>
<c>        * Set brightness variation of spot.</c>
<l>        BrightnessVariationSpot[1] := CurrentParamValue</l>
<c>        * Check if input value is in range of 0-255.</c>
<l>        if (is_number(CurrentParamValue)) </l>
<l>            if (CurrentParamValue&lt;0 or CurrentParamValue&gt;255)</l>
<l>                throw ('The given value for brightness_variation_spot has to be in the range 0-255.')</l>
<l>            endif</l>
<l>        else</l>
<l>            throw ('The given value for brightness_variation_spot has to be in the range 0-255.')</l>
<l>        endif</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>*</c>
<c>* Aggregate all possible distortions and parameter values into a vector.</c>
<c>* </c>
<l>AvailableDistortions := {}</l>
<c>* Cropping percentage.</c>
<l>if (is_number(CropPercentage[1]))</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := CropPercentage</l>
<l>endif</l>
<c>* Cropping pixel.</c>
<l>if (is_number(CropPixel[1]))</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := CropPixel</l>
<l>endif</l>
<c>* Rotation with a given angular step size.</c>
<l>if ((Rotation[1]) &gt; 0)</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := Rotation</l>
<l>endif</l>
<c>* Rotation within a given range (step size 1).</c>
<l>if ((RotationRange[1]) &gt; 0)</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := RotationRange</l>
<l>endif</l>
<c>* Mirroring: in row and column direction are allowed.</c>
<l>if (Mirror[1]  =~ 'r' or Mirror[1]  =~ 'c')</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := Mirror</l>
<l>endif</l>
<c>* Brightness variation.</c>
<l>if (BrightnessVariation[1]&gt;0)</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := BrightnessVariation</l>
<l>endif</l>
<c>* Brightness variation spot.</c>
<l>if (BrightnessVariationSpot[1]&gt;0)</l>
<l>    AvailableDistortions.at(AvailableDistortions.length()) := BrightnessVariationSpot</l>
<l>endif</l>
<c>* Check number of available distortions</c>
<l>NumAvailableDistortions := AvailableDistortions.length()</l>
<l>if (NumAvailableDistortions == 0)</l>
<l>    ImagesAugmented := Images</l>
<l>    return ()</l>
<l>endif</l>
<c>*</c>
<c>* Randomly choose images and augmentation methods.</c>
<c>*</c>
<c>* Number of images to be augmented.</c>
<l>count_obj (Images, NumImages)</l>
<l>if (NumImages == 0)</l>
<l>    throw ('There are no images to be processed.')</l>
<l>endif</l>
<c>* Calculate how many images are to be augmented.</c>
<l>AugmentationRate := AugmentationPercentage[1]*0.01</l>
<l>NumAugmentations := int(ceil(AugmentationRate*NumImages))</l>
<c>* Select a random subset of images</c>
<c>* that are to be augmented.</c>
<l>tuple_shuffle ([0:NumImages-1], ImageIndices)</l>
<l>SelectedImages := ImageIndices[0:NumAugmentations-1]</l>
<c>* Select a random distortion method for each image.</c>
<l>SelectedDistortions := int(floor(rand(NumAugmentations) * (NumAvailableDistortions)))</l>
<c>* Fill up vector of distortions for all input images.</c>
<l>Distortions := {}</l>
<l>IndexDistortion := 0</l>
<l>for Index := 0 to NumImages-1 by 1</l>
<c>    * Check if Index corresponds to a selected image.</c>
<l>    if(sum(SelectedImages[==]Index)&gt;0)</l>
<c>        * Add a distortion method.</c>
<l>        Distortions.at(Index) := AvailableDistortions.at(SelectedDistortions[IndexDistortion])</l>
<l>        IndexDistortion := IndexDistortion+1</l>
<l>    else</l>
<c>        * Image will not be distorted.</c>
<l>        Distortions.at(Index) := ['none', 0]</l>
<l>    endif</l>
<l>endfor</l>
<c>*</c>
<c>* Augment (distort) the images.</c>
<c>*</c>
<c>* Generate output image array.</c>
<l>gen_empty_obj (ImagesAugmented)</l>
<c>* Loop over all images and apply distortions.</c>
<l>for ImageIndex := 0 to NumImages-1 by 1</l>
<c>    * Get distortion method.</c>
<l>    CurrentDistortion := Distortions.at(ImageIndex)</l>
<c>    * Get image to be processed.</c>
<l>    select_obj (Images, ImageSelected, ImageIndex+1)</l>
<l>    get_image_size (ImageSelected, Width, Height)</l>
<l>    if (CurrentDistortion[0] == CropPercentage[0])</l>
<c>        * Cropping:</c>
<c>        * Define cropping rectangle.</c>
<l>        CropRate := CurrentDistortion[1]*0.01</l>
<l>        Row1 := floor((1-CropRate) * Height * rand(1))</l>
<l>        Row2 := Row1 + CropRate*Height</l>
<l>        Column1 := floor((1-CropRate) * Width * rand(1))</l>
<l>        Column2 := Column1 + CropRate*Width</l>
<c>        * Crop the image and add to output.</c>
<l>        crop_rectangle1 (ImageSelected, ImagePart, Row1, Column1, Row2, Column2)</l>
<l>        concat_obj (ImagesAugmented, ImagePart, ImagesAugmented)</l>
<l>    elseif (CurrentDistortion[0] == CropPixel[0])</l>
<c>        * Cropping:</c>
<c>        * Define cropping rectangle.</c>
<l>        Length := CurrentDistortion[1] </l>
<l>        Row1 := rand(1) * (Height - Length)</l>
<l>        Row2 := Row1 + Length - 1</l>
<l>        Column1 := rand(1) * (Width - Length)</l>
<l>        Column2 := Column1 + Length - 1</l>
<c>        * Crop the image and add to output.</c>
<l>        crop_rectangle1 (ImageSelected, ImagePart, Row1, Column1, Row2, Column2)</l>
<l>        concat_obj (ImagesAugmented, ImagePart, ImagesAugmented)</l>
<l>    elseif (CurrentDistortion[0] == Rotation[0] or CurrentDistortion[0] == RotationRange[0])</l>
<c>        * Rotation:</c>
<l>        if (CurrentDistortion[0] == Rotation[0])</l>
<c>            * Determine rotation angle for method 'rotate' (angle in range [0:CurrentDistortion[1]:360)).</c>
<l>            RotationStep := CurrentDistortion[1]</l>
<l>            NumPossibleRotations := 360.0 / RotationStep</l>
<l>            CurrentRotation := RotationStep * (int(NumPossibleRotations * rand(1))+1) </l>
<l>        else</l>
<c>            * Determine rotation angle for method 'rotate_range' (angle in range [0:1:CurrentDistortion[1])).</c>
<l>            RotationStep := 1</l>
<l>            NumPossibleRotations := CurrentDistortion[1]</l>
<l>            CurrentRotation := RotationStep * (int(NumPossibleRotations * rand(1))+1) </l>
<c>            * Select direction of rotation randomly.</c>
<l>            if (round(rand(1))&gt;0.5)</l>
<l>                CurrentRotation:=360.0-CurrentRotation</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (int(CurrentRotation) == CurrentRotation and int(CurrentRotation) % 90 == 0)</l>
<c>            * Rotations around 90 degrees are faster with rotate_image</c>
<l>            rotate_image (ImageSelected, ImagePart, int(CurrentRotation), 'constant')</l>
<l>        else</l>
<c>            * Create rotation matrix.</c>
<l>            hom_mat2d_identity (HomMat2DIdentity)      </l>
<l>            hom_mat2d_rotate (HomMat2DIdentity, rad(CurrentRotation), Height/2.0, Width/2.0, HomMat2DRotate)</l>
<c>            * Apply rotation.</c>
<l>            affine_trans_image (ImageSelected, ImageRotated, HomMat2DRotate, 'constant', 'false')</l>
<c>            * Remove potential undefined domain.</c>
<l>            get_domain (ImageRotated, DomainRotated)</l>
<l>            inner_rectangle1 (DomainRotated, Row1, Column1, Row2, Column2)</l>
<l>            crop_rectangle1 (ImageRotated, ImagePart, Row1, Column1, Row2, Column2)</l>
<l>        endif</l>
<c>        * Add the image to the output.</c>
<l>        concat_obj (ImagesAugmented, ImagePart, ImagesAugmented)</l>
<l>    elseif (CurrentDistortion[0] == Mirror[0])</l>
<c>        * Mirroring:</c>
<c>        * If more than one method is allowed, chose mirroring method(s) to be applied.</c>
<l>        NumMirrorMethods := strlen(CurrentDistortion[1])</l>
<l>        PropabilityMethods := 1.0/NumMirrorMethods</l>
<l>        StrMirror := ''</l>
<l>        while (StrMirror == '')</l>
<l>            for StrIdx := 0 to NumMirrorMethods-1 by 1</l>
<l>                SelectedChar := CurrentDistortion[1]{StrIdx}</l>
<l>                if (rand(1) &lt; PropabilityMethods)</l>
<l>                    StrMirror := StrMirror + SelectedChar</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endwhile</l>
<c>        * Apply the chosen mirroring method(s).</c>
<l>        if (StrMirror  =~ 'c')</l>
<l>            mirror_image (ImageSelected, ImageSelected, 'column')</l>
<l>        endif</l>
<l>        if (StrMirror  =~ 'r')</l>
<l>            mirror_image (ImageSelected, ImageSelected, 'row')</l>
<l>        endif</l>
<c>        * Add the image to the output.</c>
<l>        concat_obj (ImagesAugmented, ImageSelected, ImagesAugmented)</l>
<l>    elseif (CurrentDistortion[0] == BrightnessVariation[0])</l>
<c>        * Brightness variation:</c>
<c>        * Add random brightness variation.</c>
<l>        BrightnessVariationValue := (rand(1)*2 - 1) * CurrentDistortion[1]</l>
<l>        scale_image (ImageSelected, ImageScaled, 1.0, BrightnessVariationValue)</l>
<c>        * Add the image to the output.</c>
<l>        concat_obj (ImagesAugmented, ImageScaled, ImagesAugmented)</l>
<l>    elseif (CurrentDistortion[0] == BrightnessVariationSpot[0])</l>
<c>        * Determine random brightness variation.</c>
<l>        BrightnessVariationValue := (rand(1)*2 - 1) * CurrentDistortion[1]</l>
<c>        * Determine random spot size between [0.5*Width, Width].</c>
<l>        SpotSize := Width * (rand(1)/2+.5)</l>
<c>        * Determine random spot position.</c>
<l>        SpotRow := rand(1) * Height</l>
<l>        SpotColumn := rand(1) * Width</l>
<l>        apply_brightness_variation_spot (ImageSelected, ImageSpot, SpotSize, SpotRow, SpotColumn, BrightnessVariationValue)</l>
<c>        * Add the image to the output.</c>
<l>        concat_obj (ImagesAugmented, ImageSpot, ImagesAugmented)</l>
<l>    else</l>
<c>        * Add unchanged image to the output.</c>
<l>        concat_obj (ImagesAugmented, ImageSelected, ImagesAugmented)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="augment_images">
<abstract lang="de_DE">Diese Prozedur kann benutzt werden, um die Eingabebilder Images mit verschiedenen Methoden zu augmentieren, die mit GenParamName and GenParamValue spezifiziert werden. Die augmentierten Bilder werden in ImagesAugmented zurückgegeben. Es ist stark vom jeweiligen Datensatz abhängig, welche Augmentierungsmethoden zu einer Verbesserung der Performance des trainierten Deep-Learning-basierten Netzwerks führen. 

Die Datenaugmentierung wird durchgeführt, indem ein Teil der Bilder modifiziert wird, d.h. die Anzahl der Bilder in Images und ImagesAugmented ist identisch. Um zu verhindern, dass alle Bilder augmentiert werden, d.h. keine 'Original-'Bilder verbleiben in ImagesAugmented, kann die Prozentsatz der augmentierten Bilder 'augmentation_percentage' mit GenParamName und GenParamValue gesetzt werden. Der Standardwert ist '50', es werden also 50% der Bilder unverändert zurückgegeben.

Für jedes zu augmentierende Bild wird eine der unten aufgeführten Methoden zufällig ausgewählt. Sie können angepasst oder deaktiviert werden, indem der Methodenname in GenParamName und der entsprechende Parameter in GenParamValue übergeben werden:

  * 'rotate': Dieser Wert bestimmt die Schrittweite der erlaubten Rotationen. Die zur Rotation ausgewählten Bilder werden um ein zufällig bestimmtes Vielfaches dieser Schrittweite rotiert. Die daraus resultierenden Rotationswinkel liegen im Bereich [0°:360°]. Falls nach der Rotation undefinierte Pixel entstehen würde, wird das Bild ausgeschnitten. Der Wertebereich ist 0 bis 180, der empfohlene Wert ist '90'. Mit '0' wird diese Methode deaktiviert, was auch der Standardwert ist.

  * 'rotate_range': Diese Rotationsmethode rotiert die ausgewählten Bilder um einen zufälligen Winkel im Bereich [-'rotate_range':1°:'rotate_range']. Falls nach der Rotation undefinierte Pixel entstehen würde, wird das Bild ausgeschnitten. Der Wertebereich ist  0 bis 180, der empfohlene Wert ist '5'. Mit '0' wird diese Methode deaktiviert, was auch der Standardwert ist.

  * 'crop_percentage': Dieser Parameter bestimmt, welcher Prozentsatz der Seitenlänge in Spalten- und Zeilenrichtung von einem Bild übrig bleibt, nachdem es zufällig ausgeschnitten wird. Die Position des ausgeschnitten Bereichs wird zufällig ausgewählt. Der Wertebereich ist von 1 bis 100 [%]. Mit '100' wird diese Methode deaktiviert. Der Standardwert ist '90'.

  * 'crop_pixel': Dieser Parameter bestimmt die Seitenlänge in Spalten- und Zeilenrichtung, welche von einem Bild übrig bleibt, nachdem es zufällig ausgeschnitten wird. Die Position des ausgeschnitten Bereichs wird zufällig ausgewählt. Der Wert muss größer gleich 1 sein. Mit 'off' wird diese Methode deaktiviert, was auch der Standardwert ist.

  * 'mirror': Dieser Parameter codiert die erlaubten Spiegelungsmethoden in der folgenden Art und Weise: 'r' (row/Zeile) und 'c' (column/Spalte). Es ist damit zum Beispiel möglich, beide Methoden zu erlauben, indem 'rc' übergeben wird. Mit 'off' wird keine Spiegelung durchgeführt, was auch der Standardwert ist.

  * 'brightness_variation': Mit dieser Methode wird eine globale Helligkeits-Veränderung durchgeführt, wobei der angegebene Wert die Änderung des Grauwertes zufällig vorgibt [-brightness_variation:brightness_variation]. Der Wertebereich ist von 0 bis 255, vorgeschlagener Wert z.B. '20'. Mit '0' wird diese Methode deaktiviert, was auch der Standardwert ist.

  * 'brightness_variation_spot': Mit dieser Methode wird eine lokaler Helligkeits-Veränderung in einem Lichtfleck durchgeführt, wobei der angegebene Wert die Änderung des Grauwertes zufällig vorgibt [-brightness_variation_spot:brightness_variation_spot]. Die Größe und Position des Lichtflecks wird zufällig ausgewählt. Der Wertebereich ist von 0 bis 255, vorgeschlagener Wert z.B. '20'. Mit '0' wird diese Methode deaktiviert, was auch der Standardwert ist.

ACHTUNG: Die Größe der Ausgabebilder wird durch die Rotationen (außer 180°) und 'crop_rand' verändert. Dadurch muss eventuell die Bild-Vorverarbeitung, die ggf. für Deep Learning Training Inferenz notwendig ist, z.B. mit preprocess_dl_classifier_image wiederholt werden. 

Außerdem ist zu beachten, dass ein Seed mit set_system gesetzt werden muss, wenn die Ergebnisse dieser Prozedur reproduzierbar sein sollen. 

</abstract>
<abstract lang="en_US">This procedure can be used to augment the given Images using different methods, which can be specified using  GenParamName and GenParamValue. The augmented images are returned in ImagesAugmented. Please note, it is highly data set dependent which methods are suitable to improve the performance of the trained deep learning classifier.

Data augmentation is achieved by modification of some of the images, i.e. the number of images in Images and ImagesAugmented is identical. To prevent augmentation of all input images, i.e. no 'original' images are left in ImagesAugmented, you can set the 'augmentation_percentage' using GenParamName and GenParamValue. The default is '50', meaning 50% of the images  are returned unchanged.

For each image that is augmented one augmentation method is selected randomly from the methods listed below. They can be adjusted or switched off by giving the method name in GenParamName and respective parameters in GenParamValue:
 
  * 'rotate': This value determines the step size of the allowed rotations. The images selected for rotation are rotated by a randomly chosen multiple of the given step size. The resulting rotation angle is in the range of [0°:360°]. Note that the image is cropped if undefined pixels would result from the rotation. The value range is 0 to 180, the suggested value is '90'. Use '0' to switch off rotation. The default is '0'.

  * 'rotate_range': This method rotates the images within a given angular range. The images selected for rotation by this method are rotated by a random angle in the range of [-'rotate_range':1°:'rotate_range']. Note that the image is cropped, if undefined pixels would result from the rotation. The value range is 0 to 180, the suggested value is '5'. Use '0' to switch off rotation. The default is '0'.

 * 'crop_percentage': This parameter determines the remaining percentage of the image side lengths in row and column direction after random cropping. The position of the cropped area is chosen randomly. The value range is 1 to 100 [%]. Set the parameter to 'off' or '100' to switch off random cropping. The default is 'off'.

 * 'crop_pixel': This parameter determines the remaining size of the image side lengths in row and column direction after random cropping. The position of the cropped area is chosen randomly. The value must be greater then or equal to '1'. Set the parameter to 'off' to switch off random cropping. The default is 'off'.

 * 'mirror': This parameter codes the allowed mirroring methods in the following way: 'r' (row) and 'c' (column). Is is possible to allow both methods, e.g. by giving 'rc'. An image augmented by mirroring will be mirrored by a random combination of the allowed methods. Alternatively, you can set it to 'off' to disable the mirroring. The default is 'off'.

 * 'brightness_variation': Apply a global, random brightness variation in the range of plus/minus the given gray value[-brightness_variation:brightness_variation]. The value range is 0-255, suggested value e.g. '20'.  Setting the parameter to '0' will disable this method. The default is '0'.

 * 'brightness_variation_spot': Apply one local brightness spot in the range of plus/minus the given gray value [-brightness_variation_spot:brightness_variation_spot]. The spot size and position in the image are chosen randomly. The value range is 0-255, suggested value e.g. '20'. Alternatively, you can set it to '0'. The default is '0'.

ATTENTION: Please note that the image size will be affected by rotations (other than 180°) and cropping. Therefore, the image preprocessing necessary for deep learning classification training and inference may have to be repeated, for example using preprocess_dl_classifier_image.

Also, please note that for reproducibility of the output images, the random seed has to be set using set_system before calling the procedure.

</abstract>
<chapters lang="de_DE">
<item>Bild</item>
<item>Manipulation</item>
</chapters>
<chapters lang="en_US">
<item>Image</item>
<item>Manipulation</item>
</chapters>
<keywords lang="en_US">
<item>augmentation</item>
<item>augment</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="de_DE">Augmentieren / verfälschen der Bilder</short>
<short lang="en_US">Augment/distort the given images.</short>
<parameters>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="de_DE">Name des generischen Parameters.</description>
<description lang="en_US">Name of the generic parameter.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.name</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'augmentation_percentage'</item>
<item>'rotate'</item>
<item>'rotate_range'</item>
<item>'crop_percentage, 'crop_pixel''</item>
<item>'mirror'</item>
<item>'brightness_variation'</item>
<item>'brightness_variation_spot'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="de_DE">Wert des generischen Parameters.</description>
<description lang="en_US">Value of the generic parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>0</item>
<item>5</item>
<item>10</item>
<item>25</item>
<item>50</item>
<item>70</item>
<item>90</item>
<item>180</item>
<item>255</item>
<item>'rc'</item>
<item>'r'</item>
<item>'c'</item>
<item>'off'</item>
</values>
</parameter>
<parameter id="Images">
<description lang="de_DE">Bilder, die augmentiert werden sollen.</description>
<description lang="en_US">Images that are to be augmented.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImagesAugmented">
<description lang="de_DE">Die augmentierten Bilder.</description>
<description lang="en_US">The augmented / distorted images.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_color_intensity" access="local">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="ColorSpace" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate color features</c>
<c>* </c>
<c>* Transform an RGB image into the given ColorSpace</c>
<c>* and calculate the mean gray value and the deviation</c>
<c>* for all three channels.</c>
<c>* </c>
<l>count_channels (Image, Channels)</l>
<l>if (Channels != 3)</l>
<l>    throw (['Error when calculating feature ' + ColorSpace + '_' + Mode,'Please use a 3-channel RGB image or remove color feature from the list.'])</l>
<l>endif</l>
<l>decompose3 (Image, R, G, B)</l>
<l>if (ColorSpace == 'rgb')</l>
<l>    intensity (Region, R, Mean1, Deviation1)</l>
<l>    intensity (Region, G, Mean2, Deviation2)</l>
<l>    intensity (Region, B, Mean3, Deviation3)</l>
<l>else</l>
<l>    trans_from_rgb (R, G, B, I1, I2, I3, ColorSpace)</l>
<l>    intensity (Region, I1, Mean1, Deviation1)</l>
<l>    intensity (Region, I2, Mean2, Deviation2)</l>
<l>    intensity (Region, I3, Mean3, Deviation3)</l>
<l>endif</l>
<l>if (Mode == 'mean')</l>
<l>    Tmp1 := Mean1</l>
<l>    Tmp2 := Mean2</l>
<l>    Tmp3 := Mean3</l>
<l>elseif (Mode == 'deviation')</l>
<l>    Tmp1 := Deviation1</l>
<l>    Tmp2 := Deviation2</l>
<l>    Tmp3 := Deviation3</l>
<l>endif</l>
<l>count_obj (Region, NumRegions)</l>
<l>if (NumRegions &gt; 0)</l>
<l>    Index := [0:3:3 * NumRegions - 1]</l>
<l>    Feature[Index] := Tmp1</l>
<l>    Feature[1 + Index] := Tmp2</l>
<l>    Feature[2 + Index] := Tmp3</l>
<l>else</l>
<l>    Feature := []</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="calc_feature_color_intensity">
<abstract lang="en_US">This procedure transforms the RGB image Image into the given ColorSpace and calculates the mean gray value and the deviation for all three channels.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate color intensity features.</short>
<parameters>
<parameter id="ColorSpace">
<default_type>string</default_type>
<default_value>'cielab'</default_value>
<description lang="en_US">Target color space.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'rgb'</item>
<item>'cielab'</item>
<item>'hls'</item>
</value_list>
</parameter>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">RGB image.</description>
<multichannel>true</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<default_value>'mean'</default_value>
<description lang="en_US">Feature that is calculated from the transformed color values.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'mean'</item>
<item>'deviation'</item>
</values>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined. </description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_edge_density" access="local">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate the edge density, i.e.</c>
<c>* the ratio of the edge amplitudes to the area of the region.</c>
<c>* </c>
<l>union1 (Region, RegionUnion)</l>
<l>reduce_domain (Image, RegionUnion, ImageReduced)</l>
<l>area_center (Region, Area, Row, Column)</l>
<l>get_image_size (ImageReduced, Width, Height)</l>
<l>if (Width &gt; 1 and Height &gt; 1)</l>
<l>    sobel_amp (ImageReduced, EdgeAmplitude, 'sum_abs', 3)</l>
<l>    area_center_gray (Region, EdgeAmplitude, AreaGray, Row, Column)</l>
<l>    ZeroIndex := find(Area,0)</l>
<l>    if (ZeroIndex != -1)</l>
<l>        Area[ZeroIndex] := 1</l>
<l>        AreaGray[ZeroIndex] := 0</l>
<l>    endif</l>
<l>    Feature := AreaGray / Area</l>
<l>else</l>
<l>    Feature := gen_tuple_const(|Area|,0.0)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="calc_feature_edge_density">
<abstract lang="en_US">Calculate the edge density, i.e., the ratio of the edge amplitudes to the area of the region.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate edge density.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_edge_density_histogram" access="local">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="NumBins" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate the edge density histogram, i.e.</c>
<c>* the ratio of the edge amplitude histogram to the area of the region.</c>
<c>* </c>
<l>Feature := []</l>
<l>get_image_size (Image, ImageWidth, ImageHeight)</l>
<l>count_obj (Region, NumRegions)</l>
<l>if (ImageWidth &gt; 1 and ImageHeight &gt; 1)</l>
<l>    access_channel (Image, Channel1, 1)</l>
<l>    sobel_amp (Channel1, EdgeAmplitude, 'sum_abs', 3)</l>
<l>    for J := 1 to NumRegions by 1</l>
<l>        select_obj (Region, RegionSelected, J)</l>
<l>        area_center (RegionSelected, Area, Row, Column)</l>
<l>        if (Area &gt; 0)</l>
<l>            gray_histo_range (RegionSelected, EdgeAmplitude, 0, 255, NumBins, Histo, BinSize)</l>
<l>            Feature := [Feature,real(Histo) / sum(Histo)]</l>
<l>        else</l>
<l>            Feature := [Feature,1.0,gen_tuple_const(NumBins - 1,0.0)]</l>
<l>        endif</l>
<l>    endfor</l>
<l>else</l>
<l>    Feature := gen_tuple_const(NumRegions * NumBins,0.0)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="calc_feature_edge_density_histogram">
<abstract lang="en_US">Calculate the edge density histogram, i.e. the ratio of the edge amplitude histogram to the area of the region.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate edge density histogram feature.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="NumBins">
<default_type>integer</default_type>
<default_value>4</default_value>
<description lang="en_US">Number of bins of the edge density histogram.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>1</value_min>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_grad_dir_histo" access="local">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="NumBins" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate gradient direction histogram</c>
<c>* </c>
<l>access_channel (Image, Channel1, 1)</l>
<l>count_obj (Region, NumRegions)</l>
<l>Feature := []</l>
<l>for Index := 1 to NumRegions by 1</l>
<l>    select_obj (Region, RegionSelected, Index)</l>
<l>    reduce_domain (Channel1, RegionSelected, ImageReduced)</l>
<l>    sobel_dir (ImageReduced, EdgeAmplitude, EdgeDirection, 'sum_abs_binomial', 3)</l>
<l>    gray_histo_range (RegionSelected, EdgeDirection, 0, 179, NumBins, Histo, BinSize)</l>
<l>    Sum := sum(Histo)</l>
<l>    if (Sum != 0)</l>
<l>        Feature := [Feature,real(Histo) / Sum]</l>
<l>    else</l>
<l>        Feature := [Feature,Histo]</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="calc_feature_grad_dir_histo">
<abstract lang="en_US">Calculate the gradient direction histogram.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate the gradient direction histogram.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="NumBins">
<default_type>integer</default_type>
<default_value>20</default_value>
<description lang="en_US">Number of bins of the gradient direction histogram.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>1</value_min>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_gray_proj">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Size" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate gray-value projections and their histograms</c>
<c>* </c>
<l>count_obj (Region, NumRegions)</l>
<l>Feature := []</l>
<c>* </c>
<l>for Index := 1 to NumRegions by 1</l>
<l>    select_obj (Region, RegionTmp, Index)</l>
<c>    * Test empty region</c>
<l>    get_region_points (RegionTmp, RowsTmp, ColumnsTmp)</l>
<l>    if (|RowsTmp| == 0)</l>
<l>        HorProjectionFilledUp := gen_tuple_const(Size,-1.0)</l>
<l>        VertProjectionFilledUp := gen_tuple_const(Size,-1.0)</l>
<l>    else</l>
<c>        * Zoom image and region to Size x Size pixels</c>
<l>        smallest_rectangle1 (RegionTmp, Row1, Column1, Row2, Column2)</l>
<l>        move_region (RegionTmp, RegionMoved, -Row1, -Column1)</l>
<l>        crop_rectangle1 (Image, ImageTmp, Row1, Column1, Row2, Column2)</l>
<l>        ScaleHeight := real(Size) / (Row2 - Row1 + 1)</l>
<l>        ScaleWidth := real(Size) / (Column2 - Column1 + 1)</l>
<l>        zoom_image_factor (ImageTmp, ImageTmp, ScaleWidth, ScaleHeight, 'constant')</l>
<l>        zoom_region (RegionMoved, RegionTmp, ScaleWidth, ScaleHeight)</l>
<c>        * Calculate gray value projection</c>
<l>        gray_projections (RegionTmp, ImageTmp, 'simple', HorProjection, VertProjection)</l>
<c>        * Fill up projection in case the zoomed region is smaller than</c>
<c>        * Size x Size pixels due to interpolation effects</c>
<l>        smallest_rectangle1 (RegionTmp, Row1, Column1, Row2, Column2)</l>
<l>        HorProjectionFilledUpFront := [gen_tuple_const(max2(0,Row1),-1.0),HorProjection]</l>
<l>        HorProjectionFilledUp := [HorProjectionFilledUpFront,gen_tuple_const(Size - |HorProjectionFilledUpFront|,-1.0)]</l>
<l>        VertProjectionFilledUpFront := [gen_tuple_const(max2(0,Column1),-1.0),VertProjection]</l>
<l>        VertProjectionFilledUp := [VertProjectionFilledUpFront,gen_tuple_const(Size - |VertProjectionFilledUpFront|,-1.0)]</l>
<l>    endif</l>
<l>    if (Mode == 'hor')</l>
<l>        Feature := [Feature,HorProjectionFilledUp]</l>
<l>    elseif (Mode == 'vert')</l>
<l>        Feature := [Feature,VertProjectionFilledUp]</l>
<l>    elseif (Mode == 'hor_histo')</l>
<l>        tuple_histo_range (HorProjectionFilledUp, 0, 255, Size, Histo, BinSize)</l>
<l>        Feature := [Feature,Histo]</l>
<l>    elseif (Mode == 'vert_histo')</l>
<l>        tuple_histo_range (VertProjectionFilledUp, 0, 255, Size, Histo, BinSize)</l>
<l>        Feature := [Feature,Histo]</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="calc_feature_gray_proj">
<abstract lang="en_US">Calculate gray-value projections and their histograms.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate gray-value projections and their histograms.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<default_value>'hor'</default_value>
<description lang="en_US">Calculation mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'hor'</item>
<item>'vert'</item>
<item>'hor_histo'</item>
<item>'vert_histo'</item>
</value_list>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
<parameter id="Size">
<default_type>integer</default_type>
<default_value>20</default_value>
<description lang="en_US">Resolution of the gray value projection.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>extent</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_polar_gray_proj" access="local">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Features" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate gray-value projections of</c>
<c>* polar-transformed image regions.</c>
<c>* </c>
<l>count_obj (Region, NumRegions)</l>
<l>Features := []</l>
<l>for Index := 1 to NumRegions by 1</l>
<l>    select_obj (Region, RegionSelected, Index)</l>
<l>    smallest_circle (RegionSelected, Row, Column, Radius)</l>
<l>    polar_trans_image_ext (Image, PolarTransImage, Row, Column, 0, rad(360), 0, max([Radius,1]), Width, Height, 'bilinear')</l>
<c>    * </c>
<l>    if (Mode == 'hor_gray')</l>
<l>        gray_projections (PolarTransImage, PolarTransImage, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,HorProjection]</l>
<l>    elseif (Mode == 'vert_gray')</l>
<l>        gray_projections (PolarTransImage, PolarTransImage, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,VertProjection]</l>
<l>    elseif (Mode == 'hor_sobel_amp')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'sum_abs', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,HorProjection]</l>
<l>    elseif (Mode == 'vert_sobel_amp')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'sum_abs', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,VertProjection]</l>
<l>    elseif (Mode == 'hor_sobel_x')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'x_binomial', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,HorProjection]</l>
<l>    elseif (Mode == 'vert_sobel_x')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'x_binomial', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,VertProjection]</l>
<l>    elseif (Mode == 'hor_sobel_y')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'y_binomial', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,HorProjection]</l>
<l>    elseif (Mode == 'vert_sobel_y')</l>
<l>        sobel_amp (PolarTransImage, EdgeAmplitude, 'y_binomial', 3)</l>
<l>        abs_image (EdgeAmplitude, ImageAbs)</l>
<l>        gray_projections (ImageAbs, ImageAbs, 'simple', HorProjection, VertProjection)</l>
<l>        Features := [Features,VertProjection]</l>
<l>    else</l>
<l>        throw ('Unknown Mode: ' + Mode + ' in calc_feature_polar_proj')</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="calc_feature_polar_gray_proj">
<abstract lang="en_US">Calculate gray-value projections of polar-transformed image regions.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate gray-value projections of polar-transformed image regions.</short>
<parameters>
<parameter id="Features">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Height">
<default_type>integer</default_type>
<default_value>40</default_value>
<description lang="en_US">Height of the polar transformed image.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>extent.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray value image.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Calculation mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'hor_gray'</item>
<item>vert_gray'</item>
<item>'hor_sobel_amp'</item>
<item>'vert_sobel_amp'</item>
<item>'hor_sobel_x'</item>
<item>'vert_sobel_x'</item>
<item>'hor_sobel_y'</item>
<item>'vert_sobel_y'</item>
</value_list>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
<parameter id="Width">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">Width of the polar transformed image.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>extent.x</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calc_feature_pyramid" access="local">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="FeatureName" base_type="ctrl" dimension="0"/>
<par name="NumLevels" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Feature" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate a feature for different pyramid levels</c>
<c>* </c>
<l>Zoom := 0.5</l>
<l>Feature := []</l>
<l>count_obj (Region, NumRegions)</l>
<l>if (NumRegions &gt; 0)</l>
<l>    for I := 1 to NumLevels by 1</l>
<l>        if (I &gt; 1)</l>
<l>            zoom_image_factor (ImageZoom, ImageZoom, Zoom, Zoom, 'constant')</l>
<l>            zoom_region (RegionZoom, RegionZoom, Zoom, Zoom)</l>
<l>            calculate_features (RegionZoom, ImageZoom, FeatureName, Features)</l>
<l>        else</l>
<l>            copy_obj (Image, ImageZoom, 1, 1)</l>
<l>            copy_obj (Region, RegionZoom, 1, NumRegions)</l>
<l>            calculate_features (RegionZoom, ImageZoom, FeatureName, Features)</l>
<l>            FeatureLength := |Features| / NumRegions</l>
<l>            Step := NumLevels * FeatureLength</l>
<l>        endif</l>
<l>        Indices := []</l>
<l>        for J := 0 to NumRegions - 1 by 1</l>
<l>            Start := J * Step + (I - 1) * FeatureLength</l>
<l>            End := Start + FeatureLength - 1</l>
<l>            Indices := [Indices,[Start:End]]</l>
<l>        endfor</l>
<l>        Feature[Indices] := Features</l>
<l>    endfor</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="calc_feature_pyramid">
<abstract lang="en_US">Calculate a feature on multiple image pyramid levels.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate a feature on different image pyramid levels.</short>
<parameters>
<parameter id="Feature">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="FeatureName">
<default_type>string</default_type>
<description lang="en_US">Name of the feature that shall be calculated on multiple pyramid levels.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Input image.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="NumLevels">
<default_type>integer</default_type>
<default_value>4</default_value>
<description lang="en_US">Number of pyramid levels.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>1</value_min>
<values>
<item>2</item>
<item>3</item>
<item>4</item>
</values>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calculate_features">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="FeatureNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Features" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate features given in FeatureNames</c>
<c>* for the input regions in Region</c>
<c>* (if needed supported by the underlying</c>
<c>* gray-value or color image Image).</c>
<c>* </c>
<l>get_features (Region, Image, FeatureNames, 'calculate', Features)</l>
<l>return ()</l>
</body>
<docu id="calculate_features">
<abstract lang="en_US">calculate_features calculates the features indicated in FeatureNames for each input region in Region, if necessary using the underlying gray values of  Image, and returns the feature vectors in Features. If the input region contains several unconnected components that are to be classified individually, they should be separated, e.g., using connection before calculating the features.

The feature vectors in Features are sorted as follows:
The full first feature comes first for regions, then the second feature, and so on ([F1R1, F1R2,...,F1Rm,F2R1,...,F2Rm,...,FnRm] with FiRj being the feature vector for the i-th feature and the j-th region). This corresponds to the 'feature_column' order used by add_sample_class_train_data.

_____________________________________________________

HOW TO USE THE CALCULATE_FEATURE_SET.HDPL LIBRARY
_____________________________________________________

1. Overview

The library contains a set of convenience procedures to calculate features of pre-segmented regions and images. The contained features belong to several groups. This makes it easier to access only features with particular characteristics.

2. Available procedures

- query_feature_group_names
Query all available feature groups.

- query_feature_names_by_group
Get a list of all features and the groups they belong to.

- get_feature_names
Get a list of all features belonging to one or more given groups.

- get_feature_lengths
Get the lengths of the feature vectors of given features.

- calculate_features
Calculate multiple features of one or more input regions in one call.

While already a large number of features is contained in the library, it is designed in a way that it can be easily extended by user-defined features. To do this, simply follow the instructions contained in the comments of the get_custom_feature procedure. There also exists a convenience procedure that allows to test if features are implemented according to the library specifications.

- test_features (Names)
 If a problem is detected, the test_features procedure throws an exception.

3. Usage

The procedure is designed to be used together with HALCON's automatic feature selection.
First, choose the features of the group(s) that are suitable for your application. E.g.:

get_feature_names ('REGION', RegionFeatureNames)

Then, prepare training data structure for automatic feature selection:

get_feature_lengths (RegionFeatureNames, Lengths)
create_class_train_data (sum(Lengths), ClassTrainDataHandle)
set_feature_lengths_class_train_data (ClassTrainDataHandle, Lengths, RegionFeatureNames)

Then, calculate features for the samples and add them to the class_train_data:

calculate_features (RegionsClass0, Image, RegionFeatureNames, Features0)
add_sample_class_train_data (ClassTrainDataHandle, 'feature_column', Features0, 0)
calculate_features (RegionsClass1, Image, RegionFeatureNames, Features1)
add_sample_class_train_data (ClassTrainDataHandle, 'feature_column', Features1, 1)

Then, select the best features automatically:

select_feature_set_mlp (ClassTrainDataHandle, 'greedy', [], [], MLPHandle, SelectedFeatures, Score)

Finally, use the resulting classifier to classify the data:

calculate_features (ObjectSelected, Image, SelectedFeatures, Features)
classify_class_mlp (MLPHandle, Features, 1, Class, Confidence)

For more information of the implemented features, see get_features.
</abstract>
<alternatives>
<item>region_features</item>
<item>gray_features</item>
</alternatives>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<example lang="en_US">* Query group names and corresponding features 
query_feature_group_names (AllGroupNames)
query_feature_names_by_group (AllGroupNames, FeatureNames, Groups)
* Get region features and their lengths
get_feature_names ('REGION', RegionFeatureNames)
get_feature_lengths (RegionFeatureNames, Lengths)
* Prepare training data structure 
create_class_train_data (sum(Lengths), ClassTrainDataHandle)
set_feature_lengths_class_train_data (ClassTrainDataHandle, Lengths, RegionFeatureNames)
* Segment training samples
read_image (Image, 'clip')
binary_threshold (Image, Region, 'otsu', 'dark', UsedThreshold)
connection (Region, ConnectedRegions)
select_obj (ConnectedRegions, RegionsClass0, [2,5,9]) 
select_obj (ConnectedRegions, RegionsClass1, [3,8,13])
* Train class 0
calculate_features (RegionsClass0, Image, RegionFeatureNames, Features0)
add_sample_class_train_data (ClassTrainDataHandle, 'feature_column', Features0, 0)
* Train class 1
calculate_features (RegionsClass1, Image, RegionFeatureNames, Features1)
add_sample_class_train_data (ClassTrainDataHandle, 'feature_column', Features1, 1)
* Select suitable features
select_feature_set_mlp (ClassTrainDataHandle, 'greedy', [], [], MLPHandle, SelectedFeatures, Score)
* Classify all regions with selected feature(s)
Color := ['blue','orange']
count_obj (ConnectedRegions, Number)
for I := 1 to Number by 1
select_obj (ConnectedRegions, ObjectSelected, I)
calculate_features (ObjectSelected, Image, SelectedFeatures, Features)
classify_class_mlp (MLPHandle, Features, 1, Class, Confidence)
dev_set_color (Color[Class])
dev_display (ObjectSelected)
endfor

</example>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>connection</item>
<item>select_shape</item>
<item>get_feature_names</item>
<item>get_feature_lengths</item>
</predecessor>
<see_also>
<item>get_feature_names</item>
<item>get_feature_lengths</item>
<item>add_sample_class_train_data</item>
<item>select_feature_set_knn</item>
<item>select_feature_set_svm</item>
<item>select_feature_set_mlp</item>
</see_also>
<short lang="en_US">Calculate one or more features of a given image and/or region.</short>
<successor>
<item>add_sample_class_train_data</item>
<item>classify_class_knn</item>
<item>classify_class_svm</item>
<item>classify_class_mlp</item>
</successor>
<parameters>
<parameter id="FeatureNames">
<default_type>string</default_type>
<default_value>'area'</default_value>
<description lang="en_US">Names of the feature to be calculated. These names are typically obtained from get_feature_names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'area'</item>
<item>'width'</item>
<item>'height'</item>
<item>'ra'</item>
<item>'rb'</item>
<item>'phi'</item>
<item>'roundness'</item>
<item>'num_sides'</item>
<item>'num_connected'</item>
<item>'num_holes'</item>
<item>'area_holes'</item>
<item>'max_diameter'</item>
<item>'orientation'</item>
<item>'outer_radius'</item>
<item>'inner_radius'</item>
<item>'inner_width'</item>
<item>'inner_height'</item>
<item>'circularity'</item>
<item>'compactness'</item>
<item>'convexity'</item>
<item>'rectangularity'</item>
<item>'anisometry'</item>
<item>'bulkiness'</item>
<item>'struct_factor'</item>
<item>'dist_mean'</item>
<item>'dist_deviation'</item>
<item>'euler_number'</item>
<item>'rect2_phi'</item>
<item>'rect2_len1'</item>
<item>'rect2_len2'</item>
<item>'contlength'</item>
<item>'porosity'</item>
<item>'gray_area'</item>
<item>'gray_ra'</item>
<item>'gray_rb'</item>
<item>'gray_phi'</item>
<item>'gray_min'</item>
<item>'gray_max'</item>
<item>'gray_range'</item>
<item>'gray_mean'</item>
<item>'gray_deviation'</item>
<item>'gray_plane_deviation'</item>
<item>'gray_anisotropy'</item>
<item>'gray_entropy'</item>
<item>'gray_hor_proj'</item>
<item>'gray_vert_proj'</item>
<item>'gray_hor_proj_histo'</item>
<item>'gray_vert_proj_histo'</item>
<item>'grad_dir_histo'</item>
<item>'edge_density'</item>
<item>'edge_density_histogram'</item>
<item>'edge_density_pyramid_2'</item>
<item>'edge_density_pyramid_3'</item>
<item>'edge_density_pyramid_4'</item>
<item>'edge_density_histogram_pyramid_2'</item>
<item>'edge_density_histogram_pyramid_3'</item>
<item>'edge_density_histogram_pyramid_4'</item>
<item>'cooc'</item>
<item>'cooc_pyramid_2'</item>
<item>'cooc_pyramid_3'</item>
<item>'cooc_pyramid_4'</item>
<item>'polar_gray_proj'</item>
<item>'polar_grad_proj'</item>
<item>'polar_grad_x_proj'</item>
<item>'polar_grad_y_proj'</item>
<item>'polar_gray_proj_histo'</item>
<item>'cielab_mean'</item>
<item>'cielab_dev'</item>
<item>'hls_mean'</item>
<item>'hls_dev'</item>
<item>'rgb_mean'</item>
<item>'rgb_dev'</item>
</values>
</parameter>
<parameter id="Features">
<default_type>real</default_type>
<description lang="en_US">Calculated feature values.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Input image, from which the features are calculated.</description>
<sem_type>image</sem_type>
</parameter>
<parameter id="Region">
<description lang="en_US">Input region(s), from which the features are calculated.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calculate_lines_gauss_parameters">
<interface>
<ic>
<par name="MaxLineWidth" base_type="ctrl" dimension="0"/>
<par name="Contrast" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Sigma" base_type="ctrl" dimension="0"/>
<par name="Low" base_type="ctrl" dimension="0"/>
<par name="High" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Check control parameters</c>
<l>if (|MaxLineWidth| != 1)</l>
<l>    throw ('Wrong number of values of control parameter: 1')</l>
<l>endif</l>
<l>if (not is_number(MaxLineWidth))</l>
<l>    throw ('Wrong type of control parameter: 1')</l>
<l>endif</l>
<l>if (MaxLineWidth &lt;= 0)</l>
<l>    throw ('Wrong value of control parameter: 1')</l>
<l>endif</l>
<l>if (|Contrast| != 1 and |Contrast| != 2)</l>
<l>    throw ('Wrong number of values of control parameter: 2')</l>
<l>endif</l>
<l>if (min(is_number(Contrast)) == 0)</l>
<l>    throw ('Wrong type of control parameter: 2')</l>
<l>endif</l>
<c>* Set and check ContrastHigh</c>
<l>ContrastHigh := Contrast[0]</l>
<l>if (ContrastHigh &lt; 0)</l>
<l>    throw ('Wrong value of control parameter: 2')</l>
<l>endif</l>
<c>* Set or derive ContrastLow</c>
<l>if (|Contrast| == 2)</l>
<l>    ContrastLow := Contrast[1]</l>
<l>else</l>
<l>    ContrastLow := ContrastHigh / 3.0</l>
<l>endif</l>
<c>* Check ContrastLow</c>
<l>if (ContrastLow &lt; 0)</l>
<l>    throw ('Wrong value of control parameter: 2')</l>
<l>endif</l>
<l>if (ContrastLow &gt; ContrastHigh)</l>
<l>    throw ('Wrong value of control parameter: 2')</l>
<l>endif</l>
<c>* </c>
<c>* Calculate the parameters Sigma, Low, and High for lines_gauss</c>
<l>if (MaxLineWidth &lt; sqrt(3.0))</l>
<c>    * Note that LineWidthMax &lt; sqrt(3.0) would result in a Sigma &lt; 0.5,</c>
<c>    * which does not make any sense, because the corresponding smoothing</c>
<c>    * filter mask would be of size 1x1.</c>
<c>    * To avoid this, LineWidthMax is restricted to values greater or equal</c>
<c>    * to sqrt(3.0) and the contrast values are adapted to reflect the fact</c>
<c>    * that lines that are thinner than sqrt(3.0) pixels have a lower contrast</c>
<c>    * in the smoothed image (compared to lines that are sqrt(3.0) pixels wide).</c>
<l>    ContrastLow := ContrastLow * MaxLineWidth / sqrt(3.0)</l>
<l>    ContrastHigh := ContrastHigh * MaxLineWidth / sqrt(3.0)</l>
<l>    MaxLineWidth := sqrt(3.0)</l>
<l>endif</l>
<c>* Convert LineWidthMax and the given contrast values into the input parameters</c>
<c>* Sigma, Low, and High required by lines_gauss</c>
<l>HalfWidth := MaxLineWidth / 2.0</l>
<l>Sigma := HalfWidth / sqrt(3.0)</l>
<l>Help := -2.0 * HalfWidth / (sqrt(6.283185307178) * pow(Sigma,3.0)) * exp(-0.5 * pow(HalfWidth / Sigma,2.0))</l>
<l>High := fabs(ContrastHigh * Help)</l>
<l>Low := fabs(ContrastLow * Help)</l>
<l>return ()</l>
</body>
<docu id="calculate_lines_gauss_parameters">
<abstract lang="en_US">calculate_lines_gauss_parameters calculates the parameters Sigma, Low, and High for lines_gauss from the maximum width and the contrast of the lines to be extracted.

MaxLineWidth defines the maximum width of the lines to be extracted with lines_gauss.

Contrast should be set to the gray value contrast of a typical line to be extracted. All lines that have a higher contrast will be extracted in any case.

Optionally, the parameter Contrast may contain a second value, which then defines the minimum contrast of the lines to be extracted. This second value of the parameter Contrast must not be larger than the first value. If only one value is given, the minimum contrast is set to Contrast/3.0. A smaller value for the minimum contrast results in longer lines, which extend into areas with low contrast. A higher value results in shorter but more salient lines.

Note that lines_gauss uses a hysteresis thresholding approach, that uses the parameters Low and High, which are calculated from MaxLineWidth and the two contrast values described above. In simple terms, the hysteresis thresholding approach works such that all points that lie on lines with a contrast above (the first value of) Contrast are considered as salient line points. These salient line points are extended with neighboring line points as long as those line points have a contrast above the minimum contrast.</abstract>
<chapters lang="de_DE">
<item>Filter</item>
<item>Linien</item>
</chapters>
<chapters lang="en_US">
<item>Filters</item>
<item>Lines</item>
</chapters>
<example lang="en_US">read_image (Image, 'mreut')
*
calculate_lines_gauss_parameters (30, 60, Sigma, Low, High)
*
lines_gauss (Image, Lines, Sigma, Low, High, 'light', 'true', 'bar-shaped', 'true')
dev_display (Image)
dev_display (Lines)</example>
<keywords lang="en_US">
<item>extract lines</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<references lang="en_US">Carsten Steger: Unbiased Extraction of Curvilinear Structures from 2D and 3D Images. Dissertation. Fakultät für Informatik, Technische Universität München, 1998.</references>
<short lang="en_US">Calculates the parameters Sigma, Low, and High for lines_gauss from the maximum width and the contrast of the lines to be extracted.</short>
<successor>
<item>lines_gauss</item>
</successor>
<parameters>
<parameter id="Contrast">
<default_type>real</default_type>
<default_value>60</default_value>
<description lang="en_US">Typical contrast of the lines to be extracted with lines_gauss. Optionally, a tuple with two values may be given. Then, the second value defines the minimum contrast of the lines to be extracted and must not be larger than the first value.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>20</item>
<item>40</item>
<item>60</item>
<item>80</item>
<item>100</item>
<item>150</item>
<item>[60,5]</item>
<item>[60, 50]</item>
</values>
</parameter>
<parameter id="High">
<default_type>real</default_type>
<description lang="en_US">Parameter High to be used with lines_gauss.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Low">
<default_type>real</default_type>
<description lang="en_US">Parameter Low to be used with lines_gauss.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="MaxLineWidth">
<default_type>real</default_type>
<default_value>5</default_value>
<description lang="en_US">Maximum width of the lines to be extracted with lines_gauss.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>3</item>
<item>5</item>
<item>10</item>
<item>20</item>
<item>30</item>
</values>
</parameter>
<parameter id="Sigma">
<default_type>real</default_type>
<description lang="en_US">Parameter Sigma to be used with lines_gauss.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calculate_tool_in_base_robot_path_poses">
<interface>
<ic>
<par name="ToolInModelRobotPathPoses" base_type="ctrl" dimension="1"/>
<par name="ModelInBasePose" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ToolInBaseRobotPathPoses" base_type="ctrl" dimension="1"/>
</oc>
</interface>
<body>
<c>*</c>
<l>read_message_tuple (Poses, 'OrderOfTransform', OrderOfTransform)</l>
<l>read_message_tuple (Poses, 'OrderOfRotation', OrderOfRotation)</l>
<l>read_message_tuple (Poses, 'ViewOfTransform', ViewOfTransform)</l>
<c>*</c>
<l>for Index1 := 0 to ToolInModelRobotPathPoses.length()-1 by 1</l>
<l>    pose_compose (ModelInBasePose, ToolInModelRobotPathPoses.at(Index1), ToolInBaseRobotPathPose)</l>
<l>    convert_pose_type (ToolInBaseRobotPathPose,OrderOfTransform, OrderOfRotation, ViewOfTransform, ToolInBaseRobotPathPose)</l>
<l>    ToolInBaseRobotPathPoses.at(Index1) := ToolInBaseRobotPathPose</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="calculate_tool_in_base_robot_path_poses">
<abstract lang="en_US">This procedure uses the pose of an object ModelInBasePose and the robot path poses ToolInModelRobotPathPoses to calculate the poses which can be used to approach, grasp, ... the object. 

To get the correct pose type for your robot, the input message Poses must contain the parameters OrderOfTransform, OrderOfRotation, and ViewOfTransform.</abstract>
<chapters lang="de_DE">
<item>Transformationen</item>
<item>Posen</item>
</chapters>
<chapters lang="en_US">
<item>Transformations</item>
<item>Poses</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculate the poses to grasp an object.</short>
<parameters>
<parameter id="ModelInBasePose">
<default_type>real</default_type>
<description lang="en_US">Pose of the current match.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Must contain the parameters OrderOfTransform, OrderOfRotation, and ViewOfTransform.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ToolInBaseRobotPathPoses">
<default_type>real</default_type>
<description lang="en_US">Poses to approach, grasp, ... the current object.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInModelRobotPathPoses">
<default_type>real</default_type>
<description lang="en_US">Trained poses to approach, grasp, ... an object.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calibrate_camera_and_plane_single_image">
<interface>
<ic>
<par name="CalibObjectData" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>read_message_obj (ImageCaltab, CalibObjectData, 'ImageCaltab')</l>
<l>read_message_tuple (CalibObjectData, 'CalPlateDescr', CalPlateDescr)</l>
<l>read_message_tuple (CalibObjectData, 'CalPlateThickness', CalPlateThickness)</l>
<l>read_message_tuple (CalibObjectData, 'StartCamParam', StartCamParam)</l>
<c>*</c>
<c>* Check input</c>
<l>if (StartCamParam[0] == 'line_scan')</l>
<l>    throw ('Line-scan cameras are not supported')</l>
<l>endif</l>
<c>*</c>
<c>* Create a HALCON calibration data model.</c>
<l>create_calib_data ('calibration_object', 1, 1, CalibDataID)</l>
<c>* Set the needed calibration information.</c>
<l>set_calib_data_cam_param (CalibDataID, 0, [], StartCamParam)</l>
<l>set_calib_data_calib_object (CalibDataID, 0, CalPlateDescr)</l>
<c>* Find the calibration plate.</c>
<l>find_calib_object (ImageCaltab, CalibDataID, 0, 0, 0, [], [])</l>
<c>* Calibrating from only one view requires some parameter to be excluded </c>
<c>* from the optimization.</c>
<l>set_calib_data (CalibDataID, 'camera', 0, 'excluded_settings', 'focus')</l>
<c>* Calibrate the camera.</c>
<l>calibrate_cameras (CalibDataID, ErrorCamCalibInPixel)</l>
<c>* Get the calibration results.</c>
<l>get_calib_data (CalibDataID, 'camera', 0, 'params', CamParam)</l>
<l>get_calib_data (CalibDataID, 'calib_obj_pose', [0,0], 'pose', PlaneInCamPose0)</l>
<l>set_origin_pose (PlaneInCamPose0, 0, 0, CalPlateThickness, PlaneInCamPose)</l>
<c>* Convert pose to standard pose type.</c>
<l>convert_pose_type (PlaneInCamPose, 'Rp+T', 'gba', 'point', PlaneInCamPose)</l>
<c>*</c>
<c>* Add data to output message.</c>
<l>set_message_tuple (CalibObjectData, 'ErrorCamCalibInPixel', ErrorCamCalibInPixel)</l>
<l>set_message_tuple (CalibObjectData, 'CamParam', CamParam)</l>
<l>set_message_tuple (CalibObjectData, 'PlaneInCamPose', PlaneInCamPose)</l>
<c>* Clean up.</c>
<l>clear_calib_data (CalibDataID)</l>
<l>return ()</l>
</body>
<docu id="calibrate_camera_and_plane_single_image">
<abstract lang="en_US">This procedure calibrates a camera with a single image of a calibration plate in the measurement plane. The input message CalibObjectData containing the necessary data can easily be collected with the procedure collect_single_image_calibration_data.

The optimized camera parameters are stored in CamParam.
The output parameter ErrorCamCalibInPixel returns the error of the camera calibration of the current setup.
The plane that is defined by the calibration plate is first corrected using the thickness of the calibration plate and then stored in the parameter PlaneInCamPose. These three parameters are saved in the message CalibObjectData, in addition to the already available input parameters.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Monokular</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Monocular</item>
</chapters>
<keywords lang="en_US">
<item>set_message_tuple</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>collect_single_image_calibration_data</item>
</predecessor>
<short lang="en_US">Calibrate a camera with a single image.</short>
<successor>
<item>get_message_tuple</item>
</successor>
<parameters>
<parameter id="CalibObjectData">
<default_type>integer</default_type>
<description lang="en_US">Calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calibrate_hand_eye_stationary_cam_approx">
<interface>
<ic>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
<par name="RowsTouchingPointInPlane" base_type="ctrl" dimension="0"/>
<par name="ColumnsTouchingPointInPlane" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePoses" base_type="ctrl" dimension="1"/>
<par name="CalibObjectData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*</c>
<l>read_message_tuple (CalibObjectData, 'CamParam', CamParam)</l>
<l>read_message_tuple (CalibObjectData, 'CalPlateThickness', CalPlateThickness)</l>
<l>read_message_tuple (CalibObjectData, 'PlaneInCamPose', PlaneInCamPose)</l>
<c>*</c>
<c>* Check input</c>
<l>if (|RowsTouchingPointInPlane| &lt; 3 or |ColumnsTouchingPointInPlane| &lt; 3 or ToolInBasePoses.length() &lt; 3)</l>
<l>    throw ('Please specify at least three image coordinates and robot poses.')</l>
<l>endif</l>
<l>if (|RowsTouchingPointInPlane| != |ColumnsTouchingPointInPlane| or |RowsTouchingPointInPlane| != ToolInBasePoses.length())</l>
<l>    throw ('The number of image coordinates and robot poses have to be equal.')</l>
<l>endif</l>
<l>if (CamParam[0] == 'line_scan')</l>
<l>    throw ('Line-scan cameras are not supported')</l>
<l>endif</l>
<c>*</c>
<c>* If points on top of the calibration plate are approached, we have to adapt the PlaneInCamPose accordingly.</c>
<l>set_origin_pose (PlaneInCamPose, 0, 0, -CalPlateThickness, PlaneInCamPose)</l>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePoses.at(0), OrderOfTransform0, OrderOfRotation0, ViewOfTransform0)</l>
<l>convert_pose_type (ToolInBasePoses.at(0), 'Rp+T', 'gba', 'point', ToolInBasePoses.at(0))</l>
<l>for Index := 1 to ToolInBasePoses.length()-1 by 1</l>
<l>    get_pose_type (ToolInBasePoses.at(Index), OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<l>    if (OrderOfTransform0 # OrderOfTransform or OrderOfRotation0 # OrderOfRotation or ViewOfTransform0 # ViewOfTransform)</l>
<l>        throw('ToolInBasePoses have different pose types.')</l>
<l>    endif</l>
<c>    * Convert to default pose type.</c>
<l>    convert_pose_type (ToolInBasePoses.at(Index), 'Rp+T', 'gba', 'point', ToolInBasePoses.at(Index))</l>
<l>endfor</l>
<c>*</c>
<c>* Collect the robot translations.</c>
<l>create_pose (RobotTouchingPointInToolCoordinates[0], RobotTouchingPointInToolCoordinates[1], RobotTouchingPointInToolCoordinates[2], 0, 0, 0, 'Rp+T', 'gba', 'point', TouchingPointInToolPose)</l>
<l>XBase := []</l>
<l>YBase := []</l>
<l>ZBase := []</l>
<l>for Index := 0 to |RowsTouchingPointInPlane|-1 by 1</l>
<l>    pose_compose (ToolInBasePoses.at(Index), TouchingPointInToolPose, TouchingPointInBasePose)</l>
<l>    XBase := [XBase, TouchingPointInBasePose[0]]</l>
<l>    YBase := [YBase, TouchingPointInBasePose[1]]</l>
<l>    ZBase := [ZBase, TouchingPointInBasePose[2]]</l>
<l>endfor</l>
<c>* </c>
<c>* Get the plane coordinates of the input image points.</c>
<l>image_points_to_world_plane (CamParam, PlaneInCamPose, RowsTouchingPointInPlane, ColumnsTouchingPointInPlane, 'm', XPlane, YPlane)</l>
<l>tuple_gen_const (|XPlane|, 0, ZPlane)</l>
<l>vector_to_hom_mat3d ('rigid', XPlane, YPlane, ZPlane, XBase, YBase, ZBase, HomMat3DPlaneToBase)</l>
<l>hom_mat3d_to_pose (HomMat3DPlaneToBase, PlaneInBasePose)</l>
<c>* If points on top of the calibration plate are approached, we have to readapt the Plane accordingly.</c>
<l>set_origin_pose (PlaneInCamPose, 0, 0, CalPlateThickness, PlaneInCamPose)</l>
<l>set_origin_pose (PlaneInBasePose, 0, 0, CalPlateThickness, PlaneInBasePose)</l>
<l>pose_invert (PlaneInBasePose, BaseInPlanePose)</l>
<l>pose_compose (PlaneInCamPose, BaseInPlanePose, BaseInCamPose)</l>
<c>* </c>
<c>* Get the BaseInCamPose.</c>
<l>pose_invert (PlaneInBasePose, BaseInPlanePose)</l>
<l>pose_compose (PlaneInCamPose, BaseInPlanePose, BaseInCamPose)</l>
<c>* Convert to output pose type.</c>
<l>convert_pose_type (BaseInCamPose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, BaseInCamPose)</l>
<l>convert_pose_type (PlaneInBasePose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, PlaneInBasePose)</l>
<c></c>
<c>* Get the difference of the points in the plane as seen by the camera </c>
<c>* to the points in the plane as approached by the robot.</c>
<l>affine_trans_point_3d (HomMat3DPlaneToBase, XPlane, YPlane, ZPlane, XPlaneBase, YPlaneBase, ZPlaneBase)</l>
<l>DiffX := XPlaneBase-XBase</l>
<l>DiffY := YPlaneBase-YBase</l>
<l>DiffZ := ZPlaneBase-ZBase</l>
<l>SqrDiff := DiffX*DiffX+DiffY*DiffY+DiffZ*DiffZ</l>
<l>PlanePointsRMS := sqrt(sum(SqrDiff)/|DiffX|)</l>
<l>PlanePointsMaxDiff := max(sqrt(SqrDiff))</l>
<c>*</c>
<c>* Create output message.</c>
<l>create_message (HandEyeCalibData)</l>
<l>set_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>set_message_tuple (HandEyeCalibData, 'BaseInCamPose', BaseInCamPose)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlaneInBasePose', PlaneInBasePose)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlaneInCamPose0', PlaneInCamPose)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlanePointsRMS', PlanePointsRMS)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlanePointsMaxDiff', PlanePointsMaxDiff)</l>
<l>return ()</l>
</body>
<docu id="calibrate_hand_eye_stationary_cam_approx">
<abstract lang="en_US">This procedures performs an approximate hand-eye calibration of a six-axis robot for the case where a camera is stationary with respect to the robot. The measurement plane of the robot has to be observable and known with respect to the camera.

The parameter RobotTouchingPointInToolCoordinates describes a point on the gripper that touches the measurement plane. If the tool coordinate system already lies in the gripper, the touching point is a 1 x 3 vector with all its entries being zero. Otherwise, the vector describes the translation in x-, y- and z-direction of the tool origin to the touching point.
Please note that the touching point has to be fixed w.r.t. the tool coordinate system, but does not have to be located on the surface of the gripper, i.e. it can lie halfway between two fingers of a gripper.

The parameters RowsTouchingPointInPlane and ColsTouchingPointInPlane are the image coordinates in row and column direction, respectively that have been approached by the touching point. The corresponding robot poses have to be specified in the parameter ToolInBasePoses. 

Please note that at least three row, column and robot poses have to be used and that these parameters have to be of equal
size. It is further important that all row and column coordinates lie in the plane PlaneInCamPose and that the touching point of the robot has to approach the plane exactly at these points.

The input message CalibObjectData must contain the following data: 
  - The internal camera parameters have to be specified in the parameter CamParam.
  - The parameter PlaneInCamPose describes the measurement plane with respect to the camera.
  - The parameter CalPlateThickness describes the thickness of the calibration plate, in meters.

The output parameters are stored in the message HandEyeCalibData. The following data is stored:
  - The camera parameters CamParam.
  - The parameter BaseInCamPose, which is the pose of the robot's base with respect to the camera.
  - The parameter PlaneInBasePose, which is the pose of the plane with respect to the robot's base.
  - The parameters PlaneInCamPose, which is the pose of the plane with respect to the camera.
  - A qualitative statement about the calibration and the measurement plane is given in the parameters PlanePointsRMS and PlanePointsMaxDiff: The PlanePointsRMS describes the root mean square error of the difference between the rows and columns projected into the measurement plane and the identical points that have been approached by the touching point. The PlanePointsMaxDiff describes the maximum error of the Euclidean distances of the projected and the approached points. </abstract>
<alternatives>
<item>calibrate_hand_eye_stationary_cam_approx_without_calib_plate</item>
<item>calibrate_hand_eye</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>get_nearest_finder_pattern_coordinates</item>
</predecessor>
<short lang="en_US">Perform a hand-eye calibration with a stationary camera.</short>
<parameters>
<parameter id="CalibObjectData">
<default_type>integer</default_type>
<description lang="en_US">Calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ColumnsTouchingPointInPlane">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Column coordinates of points in the measurement plane that have been approached by the robot's touching point.</description>
<multivalue>true</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US"> Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RobotTouchingPointInToolCoordinates">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">A point on the gripper that has been used to approach points in the measurement plane of the robot.</description>
<multivalue>true</multivalue>
<sem_type>coordinates</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="RowsTouchingPointInPlane">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Row coordinates of points in the measurement plane that have been approached by the robot's touching point.</description>
<multivalue>true</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInBasePoses">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Robot positions that have been acquired while touching the corresponding image points.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calibrate_hand_eye_stationary_cam_approx_without_calib_plate">
<interface>
<ic>
<par name="RowsTouchingPointInPlane" base_type="ctrl" dimension="0"/>
<par name="ColumnsTouchingPointInPlane" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePoses" base_type="ctrl" dimension="1"/>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
<par name="DistanceObjectTouchingPointToPlane" base_type="ctrl" dimension="0"/>
<par name="DistancePlaneToCamera" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Check input.</c>
<l>if (|RowsTouchingPointInPlane| &lt; 4 or |ColumnsTouchingPointInPlane| &lt; 4 or ToolInBasePoses.length() &lt; 4)</l>
<l>    throw ('Please specify at least four image coordinates and robot poses.')</l>
<l>endif</l>
<l>if (|RowsTouchingPointInPlane| # |ColumnsTouchingPointInPlane| or |RowsTouchingPointInPlane| # ToolInBasePoses.length())</l>
<l>    throw ('The number of image coordinates and robot poses have to be equal.')</l>
<l>endif</l>
<l>if (Width &lt;= 0 or Height &lt;= 0)</l>
<l>    throw('Width or Height must be greater than 0.')</l>
<l>endif</l>
<l>if (DistancePlaneToCamera &lt;= 0)</l>
<l>    throw('DistancePlaneToCamera must be greater than 0.')</l>
<l>endif</l>
<l>if (DistancePlaneToCamera &lt;= 0)</l>
<l>    throw('DistanceObjectTouchingPointToPlane must be greater than 0.')</l>
<l>endif</l>
<c>* </c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePoses.at(0), OrderOfTransform0, OrderOfRotation0, ViewOfTransform0)</l>
<l>convert_pose_type (ToolInBasePoses.at(0), 'Rp+T', 'gba', 'point', ToolInBasePoses.at(0))</l>
<l>for Index := 1 to ToolInBasePoses.length()-1 by 1</l>
<l>    get_pose_type (ToolInBasePoses.at(Index), OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<l>    if (OrderOfTransform0 # OrderOfTransform or OrderOfRotation0 # OrderOfRotation or ViewOfTransform0 # ViewOfTransform)</l>
<l>        throw ('ToolInBasePoses have different pose types.')</l>
<l>    endif</l>
<c>    * Convert to default pose type.</c>
<l>    convert_pose_type (ToolInBasePoses.at(Index), 'Rp+T', 'gba', 'point', ToolInBasePoses.at(Index))</l>
<l>endfor</l>
<c>* </c>
<c>* Collect the robot translations.</c>
<l>create_pose (RobotTouchingPointInToolCoordinates[0], RobotTouchingPointInToolCoordinates[1], RobotTouchingPointInToolCoordinates[2], 0, 0, 0, 'Rp+T', 'gba', 'point', RobotTouchingPointToToolXYZPose)</l>
<l>XBase := []</l>
<l>YBase := []</l>
<l>ZBase := []</l>
<l>for Index := 0 to |RowsTouchingPointInPlane|-1 by 1</l>
<l>    pose_compose (ToolInBasePoses.at(Index), RobotTouchingPointToToolXYZPose, TouchingPointInBasePose)</l>
<l>    XBase := [XBase, TouchingPointInBasePose[0]]</l>
<l>    YBase := [YBase, TouchingPointInBasePose[1]]</l>
<l>    ZBase := [ZBase, TouchingPointInBasePose[2]]</l>
<l>endfor</l>
<c>* </c>
<c>*  Use the specified robot translations to obtain the PlaneInBasePose.</c>
<l>gen_object_model_3d_from_points (XBase, YBase, ZBase, OM3DPlanePoints)</l>
<l>fit_primitives_object_model_3d (OM3DPlanePoints, 'primitive_type', 'plane', OM3DPlane)</l>
<l>get_object_model_3d_params (OM3DPlane, 'primitive_pose', TouchingPointPlaneInBasePose)</l>
<c>* </c>
<c>* Obtain fictitious camera parameters.</c>
<l>FocusOrig := 0.008</l>
<l>DiffRow := RowsTouchingPointInPlane[0:|RowsTouchingPointInPlane|-2]-RowsTouchingPointInPlane[1:|RowsTouchingPointInPlane|-1]</l>
<l>DiffCol := ColumnsTouchingPointInPlane[0:|ColumnsTouchingPointInPlane|-2]-ColumnsTouchingPointInPlane[1:|ColumnsTouchingPointInPlane|-1]</l>
<l>DistPixel := sqrt(DiffRow*DiffRow+DiffCol*DiffCol)</l>
<l>DiffX := XBase[0:|XBase|-2]-XBase[1:|XBase|-1]</l>
<l>DiffY := YBase[0:|YBase|-2]-YBase[1:|YBase|-1]</l>
<l>DiffZ := ZBase[0:|ZBase|-2]-ZBase[1:|ZBase|-1]</l>
<l>DistWorld := sqrt(DiffX*DiffX+DiffY*DiffY+DiffZ*DiffZ)</l>
<l>Quotient := median(DistWorld/DistPixel)</l>
<c>* Camera parameter will be generated in the following form:</c>
<l>* SX := Quotient*FocusOrig/DistancePlaneToCamera</l>
<l>* SY := SX</l>
<l>* gen_cam_par_area_scan_division (FocusOrig, 0, SX, SY, Width/2.0, Height/2.0, Width, Height, HandEyeCalibData)</l>
<c>* </c>
<c>* Use the specified image points and robot translations to obtain the BaseInCamPose.</c>
<l>FocusShift := [0.1,0.2,0.33,0.5,0.75,1.0,1.5,2,3,3.125,3.5,4]</l>
<l>BestIndex := -1</l>
<c>* The value of focus should not have much influence when camera and plane are parallel, </c>
<c>* but just in case, check different values.</c>
<l>ErrorBasePoseInPixel := 1e9</l>
<l>for NumFocus := 0 to |FocusShift|-1 by 1</l>
<l>    Focus := FocusOrig*FocusShift[NumFocus]</l>
<l>    SX := Quotient*Focus/DistancePlaneToCamera</l>
<l>    SY := SX</l>
<l>    gen_cam_par_area_scan_division (Focus, 0, SX, SY, Width/2.0, Height/2.0, Width, Height, CamParam0)</l>
<l>    vector_to_pose (XBase, YBase, ZBase, RowsTouchingPointInPlane, ColumnsTouchingPointInPlane, CamParam0, 'iterative', 'error', BaseInCamPose0, ErrorBasePoseInPixelTmp)</l>
<l>    if (ErrorBasePoseInPixel &gt; ErrorBasePoseInPixelTmp)</l>
<l>        BaseInCamPose := BaseInCamPose0</l>
<l>        ErrorBasePoseInPixel := ErrorBasePoseInPixelTmp</l>
<l>        CamParam := CamParam0</l>
<l>    endif</l>
<l>endfor</l>
<c>* Get the PlaneInCamPose.</c>
<l>pose_compose (BaseInCamPose, TouchingPointPlaneInBasePose, TouchingPointPlaneInCamPose)</l>
<c>* </c>
<c>* The z-axis of the plane should point away from the camera.</c>
<l>TouchingPointPlaneInCamPose0Rot := TouchingPointPlaneInCamPose</l>
<l>TouchingPointPlaneInCamPose0Rot[0:2] := [0,0,0]</l>
<l>pose_to_hom_mat3d (TouchingPointPlaneInCamPose0Rot, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, 0, 0, 1, Qx, Qy, CosAngleBetweenZAxis)</l>
<l>if (CosAngleBetweenZAxis&lt;0)</l>
<l>    create_pose (0, 0, 0, 180, 0, 0, 'Rp+T', 'gba', 'point', SwitchZDirection)</l>
<l>    pose_compose (TouchingPointPlaneInCamPose, SwitchZDirection, TouchingPointPlaneInCamPose1)</l>
<l>    TouchingPointPlaneInCamPose := TouchingPointPlaneInCamPose1</l>
<l>    pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>    pose_compose (CamInBasePose, TouchingPointPlaneInCamPose, TouchingPointPlaneInBasePose)</l>
<l>endif</l>
<c>*</c>
<c>* Get the difference of the points in the plane as seen by the camera </c>
<c>* to the points in the plane as approached by the robot.</c>
<l>image_points_to_world_plane (CamParam, TouchingPointPlaneInCamPose, RowsTouchingPointInPlane, ColumnsTouchingPointInPlane, 'm', TouchingPointPlanePointsCamX, TouchingPointPlanePointsCamY)</l>
<l>tuple_gen_const (|TouchingPointPlanePointsCamY|, 0.0, TouchingPointPlanePointsCamZ)</l>
<l>pose_invert (TouchingPointPlaneInBasePose, BaseInTouchingPointPlanePose)</l>
<l>pose_to_hom_mat3d (BaseInTouchingPointPlanePose, HomMat3D1)</l>
<l>affine_trans_point_3d (HomMat3D1, XBase, YBase, ZBase, TouchingPointPlanePointsToolX, TouchingPointPlanePointsToolY, TouchingPointPlanePointsToolZ)</l>
<l>DiffX := TouchingPointPlanePointsCamX-TouchingPointPlanePointsToolX</l>
<l>DiffY := TouchingPointPlanePointsCamY-TouchingPointPlanePointsToolY</l>
<l>DiffZ := TouchingPointPlanePointsCamZ-TouchingPointPlanePointsToolZ</l>
<l>SqrDiff := DiffX*DiffX+DiffY*DiffY+DiffZ*DiffZ</l>
<l>PlanePointsRMS := sqrt(sum(SqrDiff)/|DiffX|)</l>
<l>PlanePointsMaxDiff := max(sqrt(SqrDiff))</l>
<c>*</c>
<l>set_origin_pose (TouchingPointPlaneInBasePose, 0, 0, DistanceObjectTouchingPointToPlane, PlaneInBasePose)</l>
<l>set_origin_pose (TouchingPointPlaneInCamPose, 0, 0, DistanceObjectTouchingPointToPlane, PlaneInCamPose)</l>
<c>* </c>
<c>* Convert to output pose type.</c>
<l>convert_pose_type (BaseInCamPose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, BaseInCamPose)</l>
<l>convert_pose_type (PlaneInBasePose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, PlaneInBasePose)</l>
<l>convert_pose_type (PlaneInCamPose, OrderOfTransform0, OrderOfRotation0, ViewOfTransform0, PlaneInCamPose)</l>
<c>*</c>
<c>* Create output message.</c>
<l>create_message (HandEyeCalibData)</l>
<l>set_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>set_message_tuple (HandEyeCalibData, 'BaseInCamPose', BaseInCamPose)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlaneInBasePose', PlaneInBasePose)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlaneInCamPose0', PlaneInCamPose)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlanePointsRMS', PlanePointsRMS)</l>
<l>set_message_tuple (HandEyeCalibData, 'PlanePointsMaxDiff', PlanePointsMaxDiff)</l>
<l>return ()</l>
</body>
<docu id="calibrate_hand_eye_stationary_cam_approx_without_calib_plate">
<abstract lang="en_US">This procedures performs a hand-eye calibration of a six-axis robot for the case where a camera is stationary with respect to the robot. For the camera calibration part of this procedure, the internal camera parameters neither have to be specified nor known. Note that the camera has to look perpendicularly onto the plane.

The parameters RowsTouchingPointInPlane and ColumnsTouchingPointInPlane are the image coordinates that have been approached by the touching point of the robot. The corresponding robot poses have to be specified in the parameter ToolInBasePoses.
Please note that at least four row, column and robot poses have to be used and that these parameters have to be of equal size. To achieve reliable results it is important that these points are well distributed over the entire field of view. To increase the accuracy of the estimation, it is recommended to use more than just four correspondences. 

The parameter RobotTouchingPointInToolCoordinates describes the the touching point of the robot, i. e., a point on the gripper that touches the measurement plane. If the tool coordinate system already lies in the gripper, the touching point is a 1 x 3 vector with all its entries being zero. Otherwise, the vector describes the translation in x-, y- and z-direction of the tool origin to the touching point.
Please note that the touching point has to be fixed with respect to the tool coordinate system, but does not have to be located on the surface of the gripper, i.e. it can lie halfway between two fingers of a gripper.

The parameter DistancePlaneToCamera describes the (orthogonal) distance between the measurement plane and the camera center.

The image size has to be specified in the parameter Width and Height.

If you approached a three-dimensional object to gather the parameters RowsTouchingPointInPlane and ColumnsTouchingPointInPlane, you have to specify the height of this object's touching point above the plane in DistanceObjectTouchingPointToPlane.

The output parameters are stored in the message HandEyeCalibData. The following data is stored:
  - The result of the camera calibration is returned in the parameter CamParam.
  - The parameter BaseInCamPose, which is the pose of the robot's base with respect to the camera.
  - The parameter PlaneInBasePose, which is the pose of the plane with respect to the robot's base.
  - The parameters PlaneInCamPose, which is the pose of the plane with respect to the camera.
  - A qualitative statement about the calibration and the measurement plane is given in the parameters PlanePointsRMS and PlanePointsMaxDiff: The PlanePointsRMS describes the root mean square error of the difference between the rows and columns projected into the measurement plane and the identical points that have been approached by the touching point. The PlanePointsMaxDiff describes the maximum error of the Euclidean distances of the projected and the approached points. 
</abstract>
<alternatives>
<item>calibrate_hand_eye_stationary_cam</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>calibrate_robot_touching_point</item>
<item>get_image_size</item>
</predecessor>
<short lang="en_US">Perform a hand-eye calibration with a stationary camera.</short>
<parameters>
<parameter id="ColumnsTouchingPointInPlane">
<default_type>real</default_type>
<description lang="en_US">Column coordinates of points in the measurement plane that have been approached by the robot's touching point.</description>
<multivalue>true</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DistanceObjectTouchingPointToPlane">
<default_type>real</default_type>
<description lang="en_US"> Height of the touching point above the plane.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DistancePlaneToCamera">
<default_type>real</default_type>
<description lang="en_US">Perpendicular distance from camera to plane.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Height">
<default_type>integer</default_type>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>extent.y</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RobotTouchingPointInToolCoordinates">
<default_type>real</default_type>
<description lang="en_US">A point on the gripper that has been used to approach points in the measurement plane of the robot.</description>
<multivalue>true</multivalue>
<sem_type>coordinates</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="RowsTouchingPointInPlane">
<default_type>real</default_type>
<description lang="en_US">Row coordinates of points in the measurement plane that have been approached by the robot's touching point.</description>
<multivalue>true</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInBasePoses">
<default_type>real</default_type>
<description lang="en_US">Robot positions that have been acquired while touching the corresponding image points.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Width">
<default_type>integer</default_type>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>extent.x</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="calibrate_robot_touching_point">
<interface>
<ic>
<par name="DataDir" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*</c>
<c>* Open a new window.</c>
<l>open_new_window (WindowHandle, WindowHandleGraphics)</l>
<c>* Display introduction.</c>
<l>dev_disp_introduction (WindowHandle, WindowHandleGraphics)</l>
<l>stop ()</l>
<c>*</c>
<c>* Read three ToolInBasesPoses which are used </c>
<c>* to calibrate the RobotTouchingPointInToolCoordinates.</c>
<l>for Index := 1 to 3 by 1</l>
<l>    read_pose (DataDir + 'tool_in_base_pose_touching_point_0' + Index + '.dat', ToolInBasePoseTouchingPoint)</l>
<l>    dev_disp_approach_pose_touching_point_instructions (WindowHandle, WindowHandleGraphics, Index)</l>
<l>    stop()</l>
<c>    * Collect poses in vector.</c>
<l>    ToolInBasePosesTouchingPoint.at(Index-1) := ToolInBasePoseTouchingPoint</l>
<l>endfor</l>
<l>dev_set_window (WindowHandleGraphics)</l>
<l>dev_close_window ()</l>
<c>*</c>
<c>* Calculate the coordinates of the touching point</c>
<c>* of the robot with respect to the robot's tool.</c>
<l>get_robot_touching_point_in_tool_coordinates (ToolInBasePosesTouchingPoint, RobotTouchingPointInToolCoordinates)</l>
<c>*</c>
<c>* Visualize results.</c>
<l>visualize_calibrated_touching_point (RobotTouchingPointInToolCoordinates, ToolInBasePosesTouchingPoint, WindowHandle)</l>
<l>return ()</l>
</body>
<docu id="calibrate_robot_touching_point">
<abstract lang="en_US">This procedure helps you to calibrate the touching point of your robot, i.e., the touching point with respect to the tool coordinate system of the robot.

These coordinates are necessary, for example, for the hand-eye calibration in the HDevelop example program calibrate_hand_eye_stationary_cam_approx.hdev.</abstract>
<alternatives>
<item>get_robot_touching_point_in_tool_coordinates</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calibrate the X, Y, Z coordinates of a touching point of a robot.</short>
<parameters>
<parameter id="DataDir">
<default_type>string</default_type>
<default_value>''</default_value>
<description lang="en_US">Directory where the camera parameters and poses are read.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="RobotTouchingPointInToolCoordinates">
<default_type>real</default_type>
<description lang="en_US">The X, Y, Z coordinates of the touching point relative to the tool of the robot.</description>
<multivalue>true</multivalue>
<sem_type>coordinates</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="check_hand_eye_calibration_input_poses">
<interface>
<ic>
<par name="CalibDataID" base_type="ctrl" dimension="0"/>
<par name="RotationTolerance" base_type="ctrl" dimension="0"/>
<par name="TranslationTolerance" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Warnings" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure checks the hand-eye calibration input poses that are stored in</c>
<c>* the calibration data model CalibDataID for consistency.</c>
<c>* </c>
<c>* For this check, it is necessary to know the accuracy of the input poses.</c>
<c>* Therefore, the RotationTolerance and TranslationTolerance must be</c>
<c>* specified that approximately describe the error in the rotation and in the</c>
<c>* translation part of the input poses, respectively. The rotation tolerance must</c>
<c>* be passed in RotationTolerance in radians. The translation tolerance must be</c>
<c>* passed in TranslationTolerance in the same unit in which the input poses were</c>
<c>* given, i.e., typically in meters. Therefore, the more accurate the</c>
<c>* input poses are, the lower the values for RotationTolerance and</c>
<c>* TranslationTolerance should be chosen. If the accuracy of the robot's tool</c>
<c>* poses is different from the accuracy of the calibration object poses, the</c>
<c>* tolerance values of the poses with the lower accuracy (i.e., the higher</c>
<c>* tolerance values) should be passed.</c>
<c>* </c>
<c>* Typically, check_hand_eye_calibration_input_poses is called after all</c>
<c>* calibration poses have been set in the calibration data model and before the</c>
<c>* hand eye calibration is performed. The procedure checks all pairs of robot</c>
<c>* tool poses and compares them to the corresponding pair of calibration object</c>
<c>* poses. For each inconsistent pose pair, a string is returned in Warnings that</c>
<c>* indicates the inconsistent pose pair. For larger values for RotationTolerance</c>
<c>* or TranslationTolerance, i.e., for less accurate input poses, fewer warnings</c>
<c>* will be generated because the check is more tolerant, and vice versa. The</c>
<c>* procedure is also helpful if the errors that are returned by the hand-eye</c>
<c>* calibration are larger than expected to identify potentially erroneous poses.</c>
<c>* Note that it is not possible to check the consistency of a single pose but</c>
<c>* only of pose pairs. Nevertheless, if a certain pose occurs multiple times in</c>
<c>* different warning messages, it is likely that the pose is erroneous.</c>
<c>* Erroneous poses that result in inconsistent pose pairs should removed</c>
<c>* from the calibration data model by using remove_calib_data_observ and</c>
<c>* remove_calib_data before performing the hand-eye calibration.</c>
<c>* </c>
<c>* check_hand_eye_calibration_input_poses also checks whether enough calibration</c>
<c>* pose pairs are passed with a significant relative rotation angle, which</c>
<c>* is necessary for a robust hand-eye calibration.</c>
<c>* </c>
<c>* check_hand_eye_calibration_input_poses also verifies that the correct</c>
<c>* calibration model was chosen in create_calib_data. If a model of type</c>
<c>* 'hand_eye_stationary_cam' or 'hand_eye_moving_cam' was chosen, the calibration</c>
<c>* of an articulated robot is assumed. For 'hand_eye_scara_stationary_cam' or</c>
<c>* 'hand_eye_scara_moving_cam', the calibration of a SCARA robot is assumed.</c>
<c>* Therefore, if all input poses for an articulated robot are parallel or if some</c>
<c>* robot poses for a SCARA robot are tilted, a corresponding message is returned</c>
<c>* in Warnings. Furthermore, if the number of tilted input poses for articulated</c>
<c>* robots is below a certain value, a corresponding message in Warnings indicates</c>
<c>* that the accuracy of the result of the hand-eye calibration might be low.</c>
<c>* </c>
<c>* If no problems have been detected in the input poses, an empty tuple is</c>
<c>* returned in Warnings.</c>
<c>* </c>
<c>* </c>
<c>* Define the minimum fraction of pose pairs with a rotation angle exceeding</c>
<c>* 2*RotationTolerance.</c>
<l>MinLargeRotationFraction := 0.1</l>
<c>* Define the minimum fraction of screw axes pairs with an angle exceeding</c>
<c>* 2*RotationTolerance for articulated robots.</c>
<l>MinLargeAnglesFraction := 0.1</l>
<c>* Factor that is used to multiply the standard deviations to obtain an error</c>
<c>* threshold.</c>
<l>StdDevFactor := 3.0</l>
<c>* </c>
<c>* Check input control parameters.</c>
<l>if (|CalibDataID| != 1)</l>
<l>    throw ('Wrong number of values of control parameter: 1')</l>
<l>endif</l>
<l>if (|RotationTolerance| != 1)</l>
<l>    throw ('Wrong number of values of control parameter: 2')</l>
<l>endif</l>
<l>if (|TranslationTolerance| != 1)</l>
<l>    throw ('Wrong number of values of control parameter: 3')</l>
<l>endif</l>
<l>dev_get_preferences ('suppress_handled_exceptions_dlg', SuppressHandledExceptionsDlg)</l>
<l>dev_set_preferences ('suppress_handled_exceptions_dlg', 'false')</l>
<l>try</l>
<l>    get_calib_data (CalibDataID, 'model', 'general', 'type', Type)</l>
<l>catch (Exception)</l>
<l>    throw ('Wrong value of control parameter: 1')</l>
<l>endtry</l>
<l>dev_set_preferences ('suppress_handled_exceptions_dlg', SuppressHandledExceptionsDlg)</l>
<l>if (RotationTolerance &lt; 0)</l>
<l>    throw ('Wrong value of control parameter: 2')</l>
<l>endif</l>
<l>if (TranslationTolerance &lt; 0)</l>
<l>    throw ('Wrong value of control parameter: 3')</l>
<l>endif</l>
<c>* </c>
<c>* Read out the calibration data model.</c>
<l>IsHandEyeScara := Type == 'hand_eye_scara_stationary_cam' or Type == 'hand_eye_scara_moving_cam'</l>
<l>IsHandEyeArticulated := Type == 'hand_eye_stationary_cam' or Type == 'hand_eye_moving_cam'</l>
<c>* This procedure only works for hand-eye calibration applications.</c>
<l>if (not IsHandEyeScara and not IsHandEyeArticulated)</l>
<l>    throw ('check_hand_eye_calibration_input_poses only works for hand-eye calibrations')</l>
<l>endif</l>
<l>get_calib_data (CalibDataID, 'model', 'general', 'num_cameras', NumCameras)</l>
<l>get_calib_data (CalibDataID, 'model', 'general', 'num_calib_objs', NumCalibObjs)</l>
<c>* </c>
<c>* Get all valid calibration pose indices.</c>
<l>query_calib_data_observ_indices (CalibDataID, 'camera', 0, I1, PosesIdx)</l>
<l>RefCalibDataID := CalibDataID</l>
<l>UseTemporaryCopy := false</l>
<c>* If necessary, calibrate the interior camera parameters.</c>
<l>if (IsHandEyeArticulated)</l>
<c>    * For articulated (non-SCARA) robots, we have to check whether the camera</c>
<c>    * is already calibrated. Otherwise, the queried poses might not be very</c>
<c>    * accurate.</c>
<l>    dev_get_preferences ('suppress_handled_exceptions_dlg', SuppressHandledExceptionsDlg)</l>
<l>    dev_set_preferences ('suppress_handled_exceptions_dlg', 'true')</l>
<l>    try</l>
<l>        get_calib_data (CalibDataID, 'calib_obj_pose', [0,PosesIdx[0]], 'pose', CamPoseCal)</l>
<l>    catch (Exception)</l>
<l>        if (NumCameras != 0 and NumCalibObjs != 0)</l>
<c>            * If the interior camera parameters are not calibrated yet, perform</c>
<c>            * the camera calibration by using a temporary copy of the calibration</c>
<c>            * data model.</c>
<l>            serialize_calib_data (CalibDataID, SerializedItemHandle)</l>
<l>            deserialize_calib_data (SerializedItemHandle, TmpCalibDataID)</l>
<l>            clear_serialized_item (SerializedItemHandle)</l>
<l>            RefCalibDataID := TmpCalibDataID</l>
<l>            UseTemporaryCopy := true</l>
<l>            calibrate_cameras (TmpCalibDataID, Error)</l>
<l>        endif</l>
<l>    endtry</l>
<l>    dev_set_preferences ('suppress_handled_exceptions_dlg', SuppressHandledExceptionsDlg)</l>
<l>endif</l>
<c>* Query all robot tool and calibration object poses.</c>
<l>for Index := 0 to |PosesIdx| - 1 by 1</l>
<l>    dev_get_preferences ('suppress_handled_exceptions_dlg', SuppressHandledExceptionsDlg)</l>
<l>    dev_set_preferences ('suppress_handled_exceptions_dlg', 'true')</l>
<l>    try</l>
<c>        * For an articulated robot with a camera and a calibration object,</c>
<c>        * a calibrated poses should always be available.</c>
<l>        get_calib_data (RefCalibDataID, 'calib_obj_pose', [0,PosesIdx[Index]], 'pose', CamPoseCal)</l>
<l>    catch (Exception)</l>
<c>        * For a SCARA robot or for an articulated robots with a general</c>
<c>        * sensor and no calibration object, directly use the observed poses.</c>
<l>        get_calib_data_observ_pose (RefCalibDataID, 0, 0, PosesIdx[Index], CamPoseCal)</l>
<l>    endtry</l>
<l>    dev_set_preferences ('suppress_handled_exceptions_dlg', SuppressHandledExceptionsDlg)</l>
<c>    * Transform the calibration object poses to dual quaternions.</c>
<l>    pose_to_dual_quat (CamPoseCal, CamDualQuatCal)</l>
<l>    CamDualQuatsCal.at(Index) := CamDualQuatCal</l>
<c>    * Transform the robot tool pose to dual quaternions.</c>
<l>    get_calib_data (RefCalibDataID, 'tool', PosesIdx[Index], 'tool_in_base_pose', BasePoseTool)</l>
<l>    pose_to_dual_quat (BasePoseTool, BaseDualQuatTool)</l>
<l>    BaseDualQuatsTool.at(Index) := BaseDualQuatTool</l>
<l>endfor</l>
<l>NumCalibrationPoses := |PosesIdx|</l>
<l>if (UseTemporaryCopy)</l>
<l>    clear_calib_data (TmpCalibDataID)</l>
<l>endif</l>
<c>* </c>
<c>* In the first test, check the poses for consistency. The principle of</c>
<c>* the hand-eye calibration is that the movement of the robot from time</c>
<c>* i to time j is represented by the relative pose of the calibration</c>
<c>* object from i to j in the camera coordinate system and also by the</c>
<c>* relative pose of the robot tool from i to j in the robot base</c>
<c>* coordinate system. Because both relative poses represent the same 3D</c>
<c>* rigid transformation, but only seen from two different coordinate</c>
<c>* systems, their screw axes differ but their screw angle and their</c>
<c>* screw translation should be identical. This knowledge can be used to</c>
<c>* check the consistency of the input poses. Furthermore, remember the</c>
<c>* screw axes for all robot movements to later check whether the</c>
<c>* correct calibration model (SCARA or articulated) was selected by the</c>
<c>* user.</c>
<l>Warnings := []</l>
<l>LX2s := []</l>
<l>LY2s := []</l>
<l>LZ2s := []</l>
<l>TranslationToleranceSquared := TranslationTolerance * TranslationTolerance</l>
<l>RotationToleranceSquared := RotationTolerance * RotationTolerance</l>
<l>for Index1 := 0 to NumCalibrationPoses - 2 by 1</l>
<l>    CamDualQuatCal1 := CamDualQuatsCal.at(Index1)</l>
<l>    dual_quat_conjugate (CamDualQuatCal1, Cal1DualQuatCam)</l>
<l>    BaseDualQuatTool1 := BaseDualQuatsTool.at(Index1)</l>
<l>    dual_quat_conjugate (BaseDualQuatTool1, Tool1DualQuatBase)</l>
<l>    for Index2 := Index1 + 1 to NumCalibrationPoses - 1 by 1</l>
<c>        * For two robot poses, ...</c>
<c>        * ... compute the movement of the calibration object in the</c>
<c>        * camera coordinate system.</c>
<l>        CamDualQuatCal2 := CamDualQuatsCal.at(Index2)</l>
<l>        dual_quat_compose (Cal1DualQuatCam, CamDualQuatCal2, DualQuat1)</l>
<c>        * </c>
<c>        * ... compute the movement of the tool in the robot base</c>
<c>        * coordinate system.</c>
<l>        BaseDualQuatTool2 := BaseDualQuatsTool.at(Index2)</l>
<l>        dual_quat_compose (Tool1DualQuatBase, BaseDualQuatTool2, DualQuat2)</l>
<c>        * </c>
<c>        * Check whether the two movements are consistent. If the two</c>
<c>        * movements are consistent, the scalar parts of the corresponding</c>
<c>        * dual quaternions should be equal. For the equality check, we</c>
<c>        * have to take the accuracy of the input poses into account, which</c>
<c>        * are given by RotationTolerance and TranslationTolerance.</c>
<l>        dual_quat_to_screw (DualQuat1, 'moment', LX1, LY1, LZ1, MX1, MY1, MZ1, Rot1, Trans1)</l>
<l>        dual_quat_to_screw (DualQuat2, 'moment', LX2, LY2, LZ2, MX2, MY2, MZ2, Rot2, Trans2)</l>
<l>        while (Rot1 &gt; rad(180.0))</l>
<l>            Rot1 := Rot1 - rad(360.0)</l>
<l>        endwhile</l>
<l>        while (Rot2 &gt; rad(180.0))</l>
<l>            Rot2 := Rot2 - rad(360.0)</l>
<l>        endwhile</l>
<c>        * </c>
<l>        Rot1 := fabs(Rot1)</l>
<l>        Trans1 := fabs(Trans1)</l>
<l>        Rot2 := fabs(Rot2)</l>
<l>        Trans2 := fabs(Trans2)</l>
<l>        MeanRot := 0.5 * (Rot1 + Rot2)</l>
<l>        MeanTrans := 0.5 * (Trans1 + Trans2)</l>
<l>        SinTheta2 := sin(0.5 * MeanRot)</l>
<l>        CosTheta2 := cos(0.5 * MeanRot)</l>
<l>        SinTheta2Squared := SinTheta2 * SinTheta2</l>
<l>        CosTheta2Squared := CosTheta2 * CosTheta2</l>
<c>        * </c>
<c>        * 1. Check the scalar part of the real part of the dual quaternion,</c>
<c>        * which encodes the rotation component of the screw:</c>
<c>        *   q[0] = cos(theta/2)</c>
<c>        * Here, theta is the screw rotation angle.</c>
<l>        ErrorRot := fabs(Rot1 - Rot2)</l>
<l>        while (ErrorRot &gt; rad(180.0))</l>
<l>            ErrorRot := ErrorRot - rad(360.0)</l>
<l>        endwhile</l>
<l>        ErrorRot := fabs(ErrorRot)</l>
<c>        * Compute the standard deviation of the scalar part of the real part</c>
<c>        * by applying the law of error propagation.</c>
<l>        StdDevQ0 := 0.5 * SinTheta2 * RotationTolerance</l>
<c>        * Multiply the standard deviation by a factor to increase the certainty.</c>
<l>        ToleranceDualQuat0 := StdDevFactor * StdDevQ0</l>
<l>        ErrorDualQuat0 := fabs(fabs(DualQuat2[0]) - fabs(DualQuat1[0]))</l>
<c>        * </c>
<c>        * 2. Check the scalar part of the dual part of the dual quaternion,</c>
<c>        * which encodes translation and rotation components of the screw:</c>
<c>        *   q[4] = -d/2*sin(theta/2)</c>
<c>        * Here, d is the screw translation.</c>
<c>        * </c>
<c>        * Compute the standard deviation of the scalar part of the dual part</c>
<c>        * by applying the law of error propagation.</c>
<l>        StdDevQ4 := sqrt(0.25 * SinTheta2Squared * TranslationToleranceSquared + 0.0625 * MeanTrans * MeanTrans * CosTheta2Squared * RotationToleranceSquared)</l>
<c>        * Multiply the standard deviation by a factor to increase the certainty.</c>
<l>        ToleranceDualQuat4 := StdDevFactor * StdDevQ4</l>
<l>        ErrorDualQuat4 := fabs(fabs(DualQuat2[4]) - fabs(DualQuat1[4]))</l>
<c>        * If one of the two errors exceeds the computed thresholds, return</c>
<c>        * a warning for the current pose pair.</c>
<l>        if (ErrorDualQuat0 &gt; ToleranceDualQuat0 or ErrorDualQuat4 &gt; ToleranceDualQuat4)</l>
<l>            Message := 'Inconsistent pose pair (' + PosesIdx[Index1]$'2d' + ',' + PosesIdx[Index2]$'2d' + ')'</l>
<l>            Warnings := [Warnings,Message]</l>
<l>        endif</l>
<c>        * </c>
<c>        * Remember the screw axes (of the robot tool movements) for screws</c>
<c>        * with a significant rotation part. For movements without rotation</c>
<c>        * the direction of the screw axis is determined by the translation</c>
<c>        * part only. Hence, the direction of the screw axis cannot be used</c>
<c>        * to decide whether an articulated or a SCARA robot is used.</c>
<l>        if (Rot2 &gt; StdDevFactor * RotationTolerance)</l>
<l>            LX2s := [LX2s,LX2]</l>
<l>            LY2s := [LY2s,LY2]</l>
<l>            LZ2s := [LZ2s,LZ2]</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<c>* </c>
<c>* In the second test, we check whether enough calibration poses with a</c>
<c>* significant rotation part are available for calibration.</c>
<l>NumPairs := |LX2s|</l>
<l>NumPairsMax := NumCalibrationPoses * (NumCalibrationPoses - 1) / 2</l>
<l>if (NumPairs &lt; 2)</l>
<l>    Message := 'There are not enough rotated calibration poses available.'</l>
<l>    Warnings := [Warnings,Message]</l>
<c>    * In this case, we can skip further test.</c>
<l>    return ()</l>
<l>endif</l>
<l>LargeRotationFraction := real(NumPairs) / NumPairsMax</l>
<l>if (NumPairs &lt; 4 or LargeRotationFraction &lt; MinLargeRotationFraction)</l>
<l>    Message := 'Only few rotated robot poses available, which might result in a reduced accuracy of the calibration results.'</l>
<l>    Warnings := [Warnings,Message]</l>
<l>endif</l>
<c>* </c>
<c>* In the third test, we compute the angle between the screw axes with</c>
<c>* a significant rotation part. For SCARA robots, this angle must be 0 in</c>
<c>* all cases. For articulated robots, for a significant fraction of robot</c>
<c>* poses, this angle should exceed a certain threshold. For this test, we</c>
<c>* use the robot tool poses as they are assumed to be more accurate than the</c>
<c>* calibration object poses.</c>
<l>NumPairPairs := NumPairs * (NumPairs - 1) / 2</l>
<l>NumPairPairsMax := NumPairsMax * (NumPairsMax - 1) / 2</l>
<l>Angles := gen_tuple_const(NumPairPairs,0)</l>
<l>Idx := 0</l>
<l>for Index1 := 0 to NumPairs - 2 by 1</l>
<l>    LXA := LX2s[Index1]</l>
<l>    LYA := LY2s[Index1]</l>
<l>    LZA := LZ2s[Index1]</l>
<l>    for Index2 := Index1 + 1 to NumPairs - 1 by 1</l>
<l>        LXB := LX2s[Index2]</l>
<l>        LYB := LY2s[Index2]</l>
<l>        LZB := LZ2s[Index2]</l>
<c>        * Compute the scalar product, i.e. the cosine of the screw</c>
<c>        * axes. To obtain valid values, crop the cosine to the</c>
<c>        * interval [-1,1].</c>
<l>        ScalarProduct := max([min([LXA * LXB + LYA * LYB + LZA * LZB,1]),-1])</l>
<c>        * Compute the angle between the axes in the range [0,pi/2].</c>
<l>        Angles[Idx] := acos(fabs(ScalarProduct))</l>
<l>        Idx := Idx + 1</l>
<l>    endfor</l>
<l>endfor</l>
<c>* Large angles should significantly exceed the RotationTolerance.</c>
<l>LargeAngles := sum(Angles [&gt;] StdDevFactor * RotationTolerance)</l>
<c>* Calculate the fraction of pairs of movements, i.e., pairs of pose</c>
<c>* pairs, that have a large angle between their corresponding screw</c>
<c>* axes.</c>
<l>LargeAnglesFraction := real(LargeAngles) / NumPairPairsMax</l>
<c>* For SCARA robots, all screw axes should be parallel, i.e., no</c>
<c>* two screw axes should have a large angle.</c>
<l>if (IsHandEyeScara and LargeAngles &gt; 0)</l>
<l>    Message := 'The robot poses indicate that this might be an articulated robot, although a SCARA robot was selected in the calibration data model.'</l>
<l>    Warnings := [Warnings,Message]</l>
<l>endif</l>
<c>* For articulated robots, the screw axes should have a large</c>
<c>* angles.</c>
<l>if (IsHandEyeArticulated)</l>
<l>    if (LargeAngles == 0)</l>
<c>        * If there is no pair of movements with a large angle between</c>
<c>        * their corresponding screw axes, this might be a SCARA robot.</c>
<l>        Message := 'The robot poses indicate that this might be a SCARA robot (no tilted robot poses available), although an articulated robot was selected in the calibration data model.'</l>
<l>        Warnings := [Warnings,Message]</l>
<l>    elseif (LargeAngles &lt; 3)</l>
<c>        * If there are at most 2 movements with a large angle between</c>
<c>        * their corresponding screw axes, the calibration might be</c>
<c>        * unstable.</c>
<l>        Message := 'Not enough tilted robot poses available for an accurate calibration of an articulated robot.'</l>
<l>        Warnings := [Warnings,Message]</l>
<l>    elseif (LargeAnglesFraction &lt; MinLargeAnglesFraction)</l>
<c>        * If there is only a low fraction of pairs of movements with</c>
<c>        * a large angle between their corresponding screw axes, the</c>
<c>        * accuracy of the calibration might be low.</c>
<l>        Message := 'Only few tilted robot poses available, which might result in a reduced accuracy of the calibration results.'</l>
<l>        Warnings := [Warnings,Message]</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="check_hand_eye_calibration_input_poses">
<abstract lang="en_US">check_hand_eye_calibration_input_poses checks the hand-eye calibration input poses that are stored in the calibration data model CalibDataID for consistency.

For this check, it is necessary to know the accuracy of the input poses. Therefore, in RotationTolerance and TranslationTolerance a tolerance must be specified that approximately describes the error in the rotation and in the translation part of the input poses, respectively. The rotation tolerance must be passed in RotationTolerance in radians. The translation tolerance must be passed in  TranslationTolerance in the same unit in which the input poses were given, i.e., typically in meters. Therefore, the more accurate the input poses are, the lower the values for RotationTolerance and TranslationTolerance should be chosen. If the accuracy of the robot's tool poses is different from the accuracy of the calibration object poses, the tolerance values of the poses with the lower accuracy (i.e., the higher tolerance values) should be passed.

Typically, check_hand_eye_calibration_input_poses is called after all calibration poses have been set in the calibration data model and before the hand eye calibration is performed. The procedure checks all pairs of robot tool poses and compares them to the corresponding pair of calibration object poses. For each inconsistent pose pair, in Warnings a string is returned that indicates the inconsistent pose pair. For larger values for RotationTolerance or TranslationTolerance, i.e., for less accurate input poses, fewer warnings will be generated because the check is more tolerant, and vice versa. The procedure is also helpful, if the errors that are returned by the hand-eye calibration are larger than expected to identify potentially erroneous poses.

Note that it is not possible to check the consistency of a single pose but only of pose pairs. Nevertheless, if a certain pose occurs multiple times in different warning messages, it is likely that the pose is erroneous. Erroneous poses that result in inconsistent pose pairs should be removed from the calibration data model by using remove_calib_data_observ and remove_calib_data before performing the hand-eye calibration.

check_hand_eye_calibration_input_poses also checks whether enough calibration pose pairs are passed with a significant relative rotation angle, which is necessary for a robust hand-eye calibration.

check_hand_eye_calibration_input_poses also verifies that the correct calibration model was chosen in create_calib_data. If a model of type 'hand_eye_stationary_cam' or 'hand_eye_moving_cam' was chosen, the calibration of an articulated robot is assumed. For 'hand_eye_scara_stationary_cam' or 'hand_eye_scara_moving_cam', the calibration of a SCARA robot is assumed. Therefore, if for an articulated robot all input poses are parallel or if for a SCARA robot some robot poses are tilted, a corresponding message is returned in Warnings. Furthermore, if for articulated robots, the number of tilted input poses is below a certain value, a corresponding message in Warnings indicates that the accuracy of the result of the hand-eye calibration might be low. 

If no problems have been detected in the input poses, an empty tuple is returned in Warnings.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<example lang="en_US">check_hand_eye_calibration_input_poses (CalibDataID, 0.04, 0.002, Warnings)
if (|Warnings| != 0)
    * There are warnings that should be checked before performing
    * the hand-eye calibration
    stop ()
endif
calibrate_hand_eye (CalibDataID, Errors)</example>
<keywords lang="en_US">
<item>hand</item>
<item>eye</item>
<item>hand-eye</item>
<item>calibration</item>
<item>poses</item>
<item>error</item>
<item>errors</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_calib_data</item>
<item>set_calib_data</item>
<item>set_calib_data_cam_param</item>
<item>set_calib_data_calib_object</item>
<item>find_calib_object</item>
<item>read_calib_data</item>
</predecessor>
<see_also>
<item>remove_calib_data</item>
<item>remove_calib_data_observ</item>
</see_also>
<short lang="de_DE">Check the input poses for the hand-eye calibration for consistency</short>
<short lang="en_US">Check the input poses of the hand-eye calibration for consistency.</short>
<successor>
<item>calibrate_hand_eye</item>
</successor>
<parameters>
<parameter id="CalibDataID">
<default_type>integer</default_type>
<description lang="en_US">Handle of the calibration data model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>calib_data</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RotationTolerance">
<default_type>real</default_type>
<default_value>0.05</default_value>
<description lang="en_US">Tolerance of the rotation part of the input poses [rad].</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<value_min>0.000000</value_min>
<values>
<item>0.02</item>
<item>0.03</item>
<item>0.04</item>
<item>0.05</item>
<item>0.06</item>
<item>0.08</item>
<item>0.1</item>
</values>
</parameter>
<parameter id="TranslationTolerance">
<default_type>real</default_type>
<default_value>0.005</default_value>
<description lang="en_US">Tolerance of the translation part of the input poses [m].</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<value_min>0.000000</value_min>
<values>
<item>[0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009,0.01]</item>
</values>
</parameter>
<parameter id="Warnings">
<default_type>string</default_type>
<description lang="en_US">Tuple of strings with warnings that contain the identified problems. If no inconsistencies or other problems have been detected, an empty tuple is returned.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="collect_single_image_calibration_data">
<interface>
<ic>
<par name="ImageCaltabFileName" base_type="ctrl" dimension="0"/>
<par name="CalPlateDescr" base_type="ctrl" dimension="0"/>
<par name="CalPlateThickness" base_type="ctrl" dimension="0"/>
<par name="StartCamParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CalibObjectData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*</c>
<c>* Read an image of the calibration plate </c>
<c>* that is placed in the measurement plane of the robot.</c>
<l>read_image (ImageCaltab, ImageCaltabFileName)</l>
<l>dev_disp_calibration_data_instructions (ImageCaltab)</l>
<l>stop ()</l>
<c>*</c>
<c>* Specify the finder pattern of the calibration plate you used.</c>
<c>* The information can usually be found in the used description file.</c>
<l>FinderRow := [13,6,6,20,20]</l>
<l>FinderColumn := [15,6,24,6,24]</l>
<c>* Specify the number of marks per row.</c>
<l>MarksPerRow := 31</l>
<c>*</c>
<c>* Create output message.</c>
<l>create_message (CalibObjectData)</l>
<l>set_message_obj (ImageCaltab, CalibObjectData, 'ImageCaltab')</l>
<l>set_message_tuple (CalibObjectData, 'CalPlateDescr', CalPlateDescr)</l>
<l>set_message_tuple (CalibObjectData, 'CalPlateThickness', CalPlateThickness)</l>
<l>set_message_tuple (CalibObjectData, 'StartCamParam', StartCamParam)</l>
<l>set_message_tuple (CalibObjectData, 'FinderRow', FinderRow)</l>
<l>set_message_tuple (CalibObjectData, 'FinderColumn', FinderColumn)</l>
<l>set_message_tuple (CalibObjectData, 'MarksPerRow', MarksPerRow)</l>
<l>return ()</l>
</body>
<docu id="collect_single_image_calibration_data">
<abstract lang="en_US">This procedure helps you collect the data for the procedure calibrate_camera_and_plane_single_image. The collected data is stored in the output message CalibObjectData.

The parameter ImageCaltabFileName is the image of the observed calibration plate. The corresponding description file has to be specified in the parameter CalPlateDescr. The starting parameters of the camera have to be passed in the parameter StartCamParam. In order to compensate a potential thickness of the calibration plate, the parameter CalPlateThickness has to be set to a value greater 0.0.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Monokular</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Monocular</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Collect the data to calibrate a camera with a single image.</short>
<successor>
<item>calibrate_camera_and_plane_single_image</item>
<item>get_message_tuple</item>
</successor>
<parameters>
<parameter id="CalPlateDescr">
<default_type>string</default_type>
<description lang="en_US"> Description file of the used calibration plate.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="CalPlateThickness">
<description lang="en_US">Thickness of the used calibration plate.</description>
</parameter>
<parameter id="CalibObjectData">
<default_type>integer</default_type>
<description lang="en_US">Calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageCaltabFileName">
<default_type>string</default_type>
<description lang="en_US">Image of the observed calibration plate.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="StartCamParam">
<description lang="en_US">Starting parameters of the camera.</description>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="color_string_to_rgb">
<interface>
<ic>
<par name="Color" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RGB" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>open_window (0, 0, 1, 1, 0, 'buffer', '', WindowHandleBuffer)</l>
<l>set_part (WindowHandleBuffer, 0, 0, -1, -1)</l>
<l>gen_rectangle1 (Rectangle, 0, 0, 0, 0)</l>
<l>try</l>
<l>    set_color (WindowHandleBuffer, Color)</l>
<l>catch (Exception)</l>
<l>    Exception := 'Wrong value of control parameter Color (must be a valid color string)'</l>
<l>    throw (Exception)</l>
<l>endtry</l>
<l>disp_obj (Rectangle, WindowHandleBuffer)</l>
<l>dump_window_image (Image, WindowHandleBuffer)</l>
<l>close_window (WindowHandleBuffer)</l>
<l>get_grayval (Image, 0, 0, RGB)</l>
<l>RGB := RGB + [0,0,0]</l>
<l>return ()</l>
</body>
<docu id="color_string_to_rgb">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Parameter</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Parameters</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Color"/>
<parameter id="RGB"/>
</parameters>
</docu>
</procedure>
<procedure name="compute_top_k_error" access="local">
<interface>
<ic>
<par name="DLClassifierHandle" base_type="ctrl" dimension="0"/>
<par name="DLClassifierResultID" base_type="ctrl" dimension="0"/>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="Indices" base_type="ctrl" dimension="0"/>
<par name="K" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TopKError" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure compares the GroundtruthLabels </c>
<c>* with the K inferred classes of highest probability, </c>
<c>* stored in DLClassifierResultID,, and returns the TopKError. </c>
<c>* Indices defines which images (and thus GroundTruthLabels </c>
<c>* as well as inference results) are considered.</c>
<l>NumMatches := 0</l>
<c>*</c>
<c>* Select the chosen GroundTruthLabels.</c>
<l>GroundTruthLabelsSelected := GroundTruthLabels[Indices]</l>
<c>*</c>
<c>* Get the batch size from the classifier handle.</c>
<l>get_dl_classifier_param (DLClassifierHandle, 'batch_size', BatchSize)</l>
<c>*</c>
<c>* Loop through all selected ground truth labels.</c>
<l>for IndexLabel := 0 to |GroundTruthLabelsSelected|-1 by 1</l>
<c>    * Get ground truth label.</c>
<l>    CurrentLabel := GroundTruthLabelsSelected[IndexLabel]   </l>
<l>    ResultHandleIndex := int(floor(Indices[IndexLabel] / BatchSize))</l>
<l>    ResultIndex := Indices[IndexLabel] % BatchSize</l>
<l>    get_dl_classifier_result(DLClassifierResultID[ResultHandleIndex], ResultIndex, 'predicted_classes', PredictedClasses)</l>
<c>    * Get the K best results.</c>
<l>    PredictedClasses := PredictedClasses[0:K-1]</l>
<c>    * Count how often the ground truth label </c>
<c>    * and K predicted classes match.</c>
<l>    if (find(PredictedClasses, CurrentLabel) != -1)</l>
<l>        NumMatches := NumMatches + 1</l>
<l>    endif</l>
<l>endfor</l>
<l>TopKError := 1.0 - (real(NumMatches) / |GroundTruthLabelsSelected|)</l>
<l>return ()</l>
</body>
<docu id="compute_top_k_error">
<abstract lang="de_DE">Diese Prozedur vergleicht die in GroundtruthLabels gegebenen Labels mit den K inferierten Klassen größter Wahrscheinlichkeit, gespeichert in DLClassifierResultID, und errechnet den TopK-Fehler TopKError. Dabei gibt Indices an, welche Bilder (und somit GroundTruthLabels sowie auch Inferenz Resultate) in Betracht gezogen werden. Das Handle DLClassifierHandle wird benötigt, um die Batchgröße zu bestimmen.</abstract>
<abstract lang="en_US">This procedure compares the GroundtruthLabels with the K inferred classes of highest probability, stored in DLClassifierResultID, and returns the TopKError. Indices defines which images (and thus GroundTruthLabels as well as inference results) are considered. The DLClassifierHandle is used to retrieve the batch size.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Klassifikation</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="de_DE">Berechnen des TopK-Fehlers.</short>
<short lang="en_US">Compute the TopK error.</short>
<parameters>
<parameter id="DLClassifierHandle">
<default_type>integer</default_type>
<description lang="de_DE">Handle des Deep-Learning-Klassifikators.</description>
<description lang="en_US">Handle of the deep-learning-based classifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_classifier</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="DLClassifierResultID">
<default_type>integer</default_type>
<description lang="de_DE">Resultat-Handle, wie er von apply_dl_classifier und apply_dl_classifier_batchwise zurückgegeben wird.</description>
<description lang="en_US">Result handle as returned by apply_dl_classifier and apply_dl_classifier_batchwise.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dl_classifier_result</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="de_DE">Die Labels der Bilder, die klassifiziert wurden.</description>
<description lang="en_US">Ground truth labels of your images.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Indices">
<default_type>integer</default_type>
<description lang="de_DE">Die Indizes bestimmen, welche Labels mit den Klassifikationsergebnissen verglichen werden.</description>
<description lang="en_US">The indices determine which are labels are compared with the classification results.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K">
<default_type>integer</default_type>
<description lang="de_DE">Die Anzahl der vorhergesagten Klassen, die mit den Labels verglichen werden.</description>
<description lang="en_US">The number of predicted classes that are compared with the ground truth label.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TopKError">
<default_type>real</default_type>
<description lang="de_DE">Der berechnete TopK-Fehler.</description>
<description lang="en_US">The computed TopK error.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="convert_decoded_string_code39_to_code32">
<interface>
<ic>
<par name="DecodedDataStringCode39" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ConvertedDataStringCode32" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure converts a decoded string of a 'Code 32'</c>
<c>* barcode that was read with the bar code reader for 'Code 39'</c>
<c>* to the 'Code 32' decoding.</c>
<c>* </c>
<c>* Basically a 'Code 32' bar code corresponds to a 'Code 39' with</c>
<c>* 8 digits and a checksum digit % 10 whereas even positions are</c>
<c>* weighted twice.</c>
<c>* The 9-digit number is represented to the base 32 and written</c>
<c>* with chars (via the symbol table) analogous to a hexadecimal number.</c>
<c>* </c>
<c>* Initialize symbol table</c>
<l>Symbols := ['0','1','2','3','4','5','6','7','8','9','B','C','D','F','G','H','J','K','L','M','N','P','Q','R','S','T','U','V','W','X','Y','Z']</l>
<c>* Check the chars in the decoded 'Code 39' string.</c>
<c>* It must consist of exactly 6 chars and must not</c>
<c>* contain any invalid chars. If these conditions are</c>
<c>* fulfilled, convert the string to 'Code 32', else</c>
<c>* return an empty string.</c>
<l>if (DecodedDataStringCode39 =~ '^[' + sum(Symbols) + ']{6}$')</l>
<c>    * </c>
<c>    * Convert the value of each digit in the decoded 'Code 39' string</c>
<l>    ConvertedDataStringCode32 := 0</l>
<l>    for Digit := 0 to 5 by 1</l>
<l>        ConvertedDataStringCode32 := ConvertedDataStringCode32 + find(Symbols,DecodedDataStringCode39{Digit})</l>
<l>        if (Digit &lt; 5)</l>
<l>            ConvertedDataStringCode32 := ConvertedDataStringCode32 * 32</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Write the converted string as 9 digit string with leading zeros</c>
<l>    ConvertedDataStringCode32 := ConvertedDataStringCode32$'9.9d'</l>
<c>    * </c>
<c>    * Verify the checksum (last digit)</c>
<l>    CheckDigit := number(ConvertedDataStringCode32{8})</l>
<l>    CheckSum := 0</l>
<l>    for Digit := 0 to 7 by 1</l>
<c>        * Sum first 8 digits, but even digits have weight 2</c>
<l>        Value := (1 + Digit % 2) * number(ConvertedDataStringCode32{Digit})</l>
<c>        * But actually we only want the cross digit sum,</c>
<c>        * This 'formula' works for 0-19</c>
<l>        if (Value &gt;= 10)</l>
<l>            Value := Value - 9</l>
<l>        endif</l>
<l>        CheckSum := CheckSum + Value</l>
<l>    endfor</l>
<l>    CheckSum := CheckSum % 10</l>
<c>    * </c>
<c>    * If the checksum fits, return the converted 'Code 32' string,</c>
<c>    * else return an empty string</c>
<l>    if (CheckDigit != CheckSum)</l>
<c>        * Bad checksum</c>
<l>        ConvertedDataStringCode32 := ''</l>
<l>    else</l>
<c>        * Always printed with leading A</c>
<l>        ConvertedDataStringCode32 := 'A' + ConvertedDataStringCode32</l>
<l>    endif</l>
<l>else</l>
<c>    * Wrong number of chars or invalid chars</c>
<l>    ConvertedDataStringCode32 := ''</l>
<l>endif</l>
<l>return ()</l>
<c>* </c>
</body>
<docu id="convert_decoded_string_code39_to_code32">
<abstract lang="en_US">This procedure converts the decoded data string of a bar code of type 'Code 32' that was read with the bar code reader for 'Code 39'.

In case a bar code of type 'Code 32' is read with the bar code reader find_bar_code with code type 'Code 39' the resulting data string has to be converted to the 'Code 32' decoding. This procedure can be used to perform this conversion.

1. Step: Find and decode the 'Code 32' bar code with the HALCON bar code reader for type 'Code 39'.
2. Step: Convert the decoded data string from type 'Code 39' to the corresponding 'Code 32' decoding using the procedure convert_decoded_string_code39_to_code32.

Note that only one data string can be passed to the input parameter 'DecodedStringCode39' for conversion.</abstract>
<chapters lang="de_DE">
<item>Identifizierung</item>
<item>Barcode</item>
</chapters>
<chapters lang="en_US">
<item>Identification</item>
<item>Bar Code</item>
</chapters>
<example lang="en_US">create_bar_code_model ([], [], BarCodeHandle)
find_bar_code (Image, SymbolRegions, BarCodeHandle, 'Code 39', DecodedDataStrings)
convert_code39_to_code32 (DecodedDataStrings, ConvertedDataStringsCode32)</example>
<keywords lang="en_US">
<item>convert decoded string of bar code type 'Code 39' to 'Code 32'</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>find_bar_code</item>
</predecessor>
<short lang="en_US">Convert a decoded string of a bar code of type 'Code 39' to the type 'Code 32'.</short>
<successor>
<item>disp_message</item>
</successor>
<parameters>
<parameter id="ConvertedDataStringCode32">
<default_type>string</default_type>
<description lang="en_US">The converted data string of bar code type 'Code 32'</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DecodedDataStringCode39">
<default_type>string</default_type>
<description lang="en_US">The decoded data string of bar code type 'Code 39' to be converted</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="determine_optimum_pose_distance">
<interface>
<ic>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="ImageCoverage" base_type="ctrl" dimension="0"/>
<par name="PoseIn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PoseOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Determine the optimum distance of the object to obtain</c>
<c>* a reasonable visualization</c>
<c>* </c>
<l>NumModels := |ObjectModel3DID|</l>
<l>Rows := []</l>
<l>Cols := []</l>
<l>MinMinZ := 1e30</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'bounding_box1', BB)</l>
<c>* Calculate diameter over all objects to be visualized</c>
<l>Seq := [0:6:|BB| - 1]</l>
<l>DXMax := max(BB[Seq + 3]) - min(BB[Seq])</l>
<l>DYMax := max(BB[Seq + 4]) - min(BB[Seq + 1])</l>
<l>DZMax := max(BB[Seq + 5]) - min(BB[Seq + 2])</l>
<l>Diameter := sqrt(DXMax * DXMax + DYMax * DYMax + DZMax * DZMax)</l>
<l>if (sum(abs(BB)) == 0.0)</l>
<l>    BB := [-abs(rand(3) * 1e-20),abs(rand(3) * 1e-20)]</l>
<l>endif</l>
<c>* Allow the visualization of single points or extremely small objects</c>
<l>ZAdd := 0.0</l>
<l>if (max(Diameter) &lt; 1e-10)</l>
<l>    ZAdd := 0.01</l>
<l>endif</l>
<c>* Set extremely small diameters to 1e-10 to avoid CZ == 0.0, which would lead</c>
<c>* to projection errors</c>
<l>if (min(Diameter) &lt; 1e-10)</l>
<l>    Diameter := Diameter - sgn(sgn(Diameter - 1e-10) - 1) * 1e-10</l>
<l>endif</l>
<l>IBB := [0:6:|BB| - 1]</l>
<l>BB0 := BB[IBB]</l>
<l>BB1 := BB[IBB + 1]</l>
<l>BB2 := BB[IBB + 2]</l>
<l>BB3 := BB[IBB + 3]</l>
<l>BB4 := BB[IBB + 4]</l>
<l>BB5 := BB[IBB + 5]</l>
<l>X := [BB0,BB3,BB0,BB0,BB3,BB3,BB0,BB3]</l>
<l>Y := [BB1,BB1,BB4,BB1,BB4,BB1,BB4,BB4]</l>
<l>Z := [BB2,BB2,BB2,BB5,BB2,BB5,BB5,BB5]</l>
<l>PoseInter := replace(PoseIn,2,-min(Z) + 2 * max(Diameter))</l>
<l>pose_to_hom_mat3d (PoseInter, HomMat3D)</l>
<c>* Determine the maximum extension of the projection</c>
<l>affine_trans_point_3d (HomMat3D, X, Y, Z, QX, QY, QZ)</l>
<l>project_3d_point (QX, QY, QZ, CamParam, Rows, Cols)</l>
<l>MinMinZ := min(QZ)</l>
<l>get_cam_par_data (CamParam, 'cx', Cx)</l>
<l>get_cam_par_data (CamParam, 'cy', Cy)</l>
<l>DR := Rows - Cy</l>
<l>DC := Cols - Cx</l>
<l>DR := max(DR) - min(DR)</l>
<l>DC := max(DC) - min(DC)</l>
<l>MaxDist := sqrt(DR * DR + DC * DC)</l>
<c>* </c>
<l>if (MaxDist &lt; 1e-10)</l>
<c>    * If the object has no extension in the above projection (looking along</c>
<c>    * a line), we determine the extension of the object in a rotated view</c>
<l>    hom_mat3d_rotate_local (HomMat3D, rad(90), 'x', HomMat3DRotate)</l>
<l>    affine_trans_point_3d (HomMat3DRotate, X, Y, Z, QX, QY, QZ)</l>
<l>    project_3d_point (QX, QY, QZ, CamParam, Rows, Cols)</l>
<l>    DR := Rows - Cy</l>
<l>    DC := Cols - Cx</l>
<l>    DR := max(DR) - min(DR)</l>
<l>    DC := max(DC) - min(DC)</l>
<l>    MaxDist := max([MaxDist,sqrt(DR * DR + DC * DC)])</l>
<l>endif</l>
<c>* </c>
<l>get_cam_par_data (CamParam, 'image_width', ImageWidth)</l>
<l>get_cam_par_data (CamParam, 'image_height', ImageHeight)</l>
<l>MinImageSize := min([ImageWidth,ImageHeight])</l>
<c>* </c>
<l>Z := PoseInter[2]</l>
<l>Zs := MinMinZ</l>
<l>ZDiff := Z - Zs</l>
<l>ScaleZ := MaxDist / (0.5 * MinImageSize * ImageCoverage * 2.0)</l>
<l>ZNew := ScaleZ * Zs + ZDiff + ZAdd</l>
<l>PoseOut := replace(PoseInter,2,ZNew)</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="determine_optimum_pose_distance">
<abstract lang="en_US">determine_optimum_pose_distance determines the optimum translation in z direction to obtain a reasonable visualization of the given 3D object models, e.g., with disp_object_model_3d.

Based on the given camera parameters (CamParam), which also define the size of the image into which the 3D object models are to be projected and the requested image coverage, the necessary translation of the 3D object models in z direction, i.e., the third element of the pose, is calculated.

</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">read_object_model_3d ('pipe_joint', 'm', [], [], ObjectModel3D, Status)
CamParam := [0.1,0,6e-6,6e-6,256,256,512,512]
dev_resize_window_fit_size (0, 0, CamParam[6]-1, CamParam[7]-1, -1, -1)
get_object_models_center (ObjectModel3D, Center)
create_pose (-Center[0], -Center[1], -Center[2], 135, 0, 0, \
             'Rp+T', 'gba', 'point', PoseIn)
determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, PoseIn, \
                                 PoseEstimated)
dev_get_window (WindowHandle)
disp_object_model_3d (WindowHandle, ObjectModel3D, \
                      CamParam, PoseEstimated, [], [])</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>get_object_models_center</item>
<item>create_pose</item>
</predecessor>
<short lang="en_US">Determine the optimum distance of the object to obtain a reasonable visualization</short>
<successor>
<item>disp_object_model_3d</item>
<item>render_object_model_3d</item>
</successor>
<parameters>
<parameter id="CamParam">
<default_type>real</default_type>
<description lang="en_US">Camera parameters of the scene.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageCoverage">
<default_type>real</default_type>
<default_value>0.9</default_value>
<description lang="en_US">Desired image coverage of the 3D object models to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PoseIn">
<default_type>real</default_type>
<description lang="en_US">3D pose of the objects.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="PoseOut">
<default_type>real</default_type>
<description lang="en_US">Pose with adapted translation in z direction.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_approach_pose_touching_point_instructions" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandleGraphics" base_type="ctrl" dimension="0"/>
<par name="Index" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>*</c>
<l>dev_set_window (WindowHandle)</l>
<l>dev_clear_window ()</l>
<l>Text    := 'Calibrate touching point'</l>
<l>Text[1] := ''</l>
<l>Text[2] := 'General workflow'</l>
<l>Text[3] := '----------------'</l>
<l>Text[4] := 'Approach a fixed point in the plane with your gripper, and read the'</l>
<l>Text[5] := 'pose as ToolInBasePoseTouchingPoint.'</l>
<l>Text[6] := 'Then, approach the same point at least twice again, rotating the tool'</l>
<l>Text[7] := 'around at least two axis and reading the corresponding '</l>
<l>Text[8] := 'ToolInBasePoseTouchingPoint.'</l>
<l>Text[9] := ''</l>
<l>Text[10]    := 'Read ToolInBasePoseTouchingPoint ' + (Index) + '/3, then press F5.'</l>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>Color := gen_tuple_const(3, 'gray')</l>
<l>Color[Index-1] := '#fbba00'</l>
<l>dev_disp_text ('   1   ','window', 255, 12, 'black', ['box_color','shadow'], [Color[0],'false'])</l>
<l>dev_disp_text ('   2   ','window', 255, 112, 'black', ['box_color','shadow'], [Color[1],'false'])</l>
<l>dev_disp_text ('   3   ','window', 255, 212, 'black', ['box_color','shadow'], [Color[2],'false'])</l>
<c>*</c>
<l>dev_set_window (WindowHandleGraphics)</l>
<l>dev_clear_window ()</l>
<l>read_image (Image, '3d_machine_vision/hand_eye/instruction_images/tool_in_base_pose_touching_point')</l>
<l>dev_display (Image)</l>
<l>HighlighColumn := 255+(Index*200)</l>
<l>gen_rectangle1 (Rectangle, 320, HighlighColumn-100, 630, HighlighColumn+100)</l>
<l>dev_set_line_width (4)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_color ('#fbba00')</l>
<l>dev_display (Rectangle)</l>
<l>dev_disp_text ('Read this pose', 'image', 6350, HighlighColumn-105, 'black', ['box_color'], ['#fbba00'])</l>
<l>return ()</l>
</body>
<docu id="dev_disp_approach_pose_touching_point_instructions">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Index">
<default_type>integer</default_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleGraphics">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_calibration_data_instructions" access="local">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
</interface>
<body>
<l>dev_display (Image)</l>
<l>Text    := 'In the code, please'</l>
<l>Text[1] := '- read an image of a calibration plate in the measurement plane,'</l>
<l>Text[2] := '- specify the location of the calibration plate description file,'</l>
<l>Text[3] := '- specify the thickness of the calibration plate (in meters) and'</l>
<l>Text[4] := '- specify initial camera parameters.'</l>
<l>Text[5] := ''</l>
<l>Text[6] := ' (If you did NOT use a standard HALCON calibration plate, '</l>
<l>Text[7] := '  but used create_caltab to create your own calibration plate,'</l>
<l>Text[8] := '  you also need to adapt the parameters FinderRow, FinderColumn,'</l>
<l>Text[9] := '  and MarksPerRow accordingly.)'</l>
<c>*</c>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', [], [])</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>return ()</l>
</body>
<docu id="dev_disp_calibration_data_instructions">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Image">
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_calibration_data_instructions2" access="local">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
</interface>
<body>
<l>dev_display (Image)</l>
<l>Text    := 'If you did NOT use a standard HALCON calibration plate, '</l>
<l>Text[1] := 'but used create_caltab to create your own calibration plate,'</l>
<l>Text[2] := 'please adapt the parameters FinderRow, FinderColumn, and MarksPerRow'</l>
<l>Text[3] := 'in the code.'</l>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'black', [], [])</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>return ()</l>
</body>
<docu id="dev_disp_calibration_data_instructions2">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Image">
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_disp_introduction" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandleGraphics" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>*</c>
<l>dev_set_window (WindowHandle)</l>
<l>dev_clear_window ()</l>
<l>Text     := 'With this procedure, we calibrate the coordinates of the touching point'</l>
<l>Text[1]  := 'of a robot with respect to the robot\'s tool.'</l>
<l>Text[2]  := ''</l>
<l>Text[3]  := 'The touching point is a point that has to be fixed with respect to'</l>
<l>Text[4]  := 'the tool coordinate system, but does not have to be located on the'</l>
<l>Text[5]  := 'surface of the gripper. It can, for example, lie halfway between'</l>
<l>Text[6]  := 'two fingers of a gripper.'</l>
<l>Text[7]  := ''</l>
<l>Text[8]  := 'The touching point should be chosen such that it can approach '</l>
<l>Text[9]  := 'a point in the plane easily and accurately.'</l>
<l>Text[10] := ''</l>
<l>Text[11] := 'The coordinates of this point (RobotTouchingPointInToolCoordinates)'</l>
<l>Text[12] := 'are necessary, for example, to perform a hand-eye calibration of a robot'</l>
<l>Text[13] := 'with a stationary camera.'</l>
<l>Text[14] := ''</l>
<l>Text[15] := 'This procedure is used in the example'</l>
<l>Text[16] := 'calibrate_hand_eye_stationary_cam_approx.hdev.'</l>
<l>dev_disp_text (Text, 'window', 'top', 'left', 'white', 'box', 'false')</l>
<l>dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<c>*</c>
<l>dev_set_window (WindowHandleGraphics)</l>
<l>read_image (InstructionImage, '3d_machine_vision/hand_eye/instruction_images/robot_touching_point_in_tool_coordinates')</l>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>dev_resize_window_fit_image (InstructionImage, 0, Width+10, 600, -1)</l>
<l>dev_display (InstructionImage)</l>
<l>return ()</l>
<c></c>
</body>
<docu id="dev_disp_introduction">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display the introduction for the procedure calibrate_robot_touching_point.</short>
<parameters>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleGraphics">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_data_code_2d_print_quality_results">
<interface>
<ic>
<par name="DataCodeHandle" base_type="ctrl" dimension="0"/>
<par name="ResultHandle" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
<par name="QualityStandard" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays the print quality results for data matrix ECC 200 codes.</c>
<c>*</c>
<c>*</c>
<c>* Available modes</c>
<l>MODE_RMMG := 'reflectance_margin_module_grades'</l>
<l>MODE_GRID := 'grid'</l>
<l>MODE_BAD := 'bad_modules'</l>
<l>SupportedModes := [MODE_RMMG, MODE_GRID, MODE_BAD]</l>
<c>* Available standards</c>
<l>SupportedQualityStandards := ['isoiec15415', 'isoiec_tr_29158', 'aimdpm_1_2006']</l>
<c>* Available generic parameters</c>
<l>GEN_CENTER := 'center'</l>
<l>GEN_CIRCLE := 'circle'</l>
<l>GEN_LEGEND := 'legend'</l>
<l>GEN_MAX_GRADE := 'max_grade'</l>
<c>* Defaults</c>
<l>DisplayCenter := false</l>
<l>DisplayCircle := true</l>
<l>DisplayLegend := true</l>
<l>MaxGrade := 3 </l>
<c>*</c>
<c>* Check modes</c>
<l>if (|Mode| != 1)</l>
<l>    throw ('Please specify exactly one of following modes:'+sum(' '+SupportedModes))</l>
<l>endif</l>
<l>if (find(SupportedModes,Mode) == -1)</l>
<l>    throw  ('Unknown Mode: '+Mode)</l>
<l>endif</l>
<c>*</c>
<c>* Check QualityStandard</c>
<l>if (find(SupportedQualityStandards,QualityStandard) == -1)</l>
<l>    throw  ('Unknown QualityStandard: '+QualityStandard)</l>
<l>else</l>
<l>    QualityStandard := 'quality_'+QualityStandard</l>
<l>endif</l>
<c>*</c>
<c>* Check generic parameters</c>
<c>*</c>
<c>* Override defaults in special modes</c>
<l>if (Mode == MODE_GRID)</l>
<l>    DisplayCenter := true</l>
<l>    DisplayCircle := false</l>
<l>    DisplayLegend := false</l>
<l>    MaxGrade := 4</l>
<l>    if (|Color| == 0)</l>
<l>        Color := 'gray'</l>
<l>    endif </l>
<l>elseif (Mode == MODE_BAD)</l>
<l>    DisplayCenter := false</l>
<l>    DisplayCircle := true</l>
<l>    DisplayLegend := false</l>
<l>    MaxGrade := 0 </l>
<l>endif</l>
<c>*</c>
<l>if (|GenParamName| != |GenParamValue|)</l>
<c>    * Check if number of values matches number of parameters</c>
<l>    throw (['GenParamName and GenParamValue do not match.'])</l>
<l>else</l>
<c>    * Set generic parameters</c>
<l>    for I := 0 to |GenParamName|-1 by 1</l>
<c>        * 'center'</c>
<l>        if (GenParamName[I] == GEN_CENTER)</l>
<c>            * Check if values are valid</c>
<l>            if (GenParamValue[I] != 'true' and GenParamValue[I] != 'false')</l>
<l>                throw ('Wrong parameter value for generic parameter \'center\': '+GenParamValue[I]+' Please use \'true\' or \'false\'.')</l>
<l>            endif</l>
<c>            * Set new value</c>
<l>            DisplayCenter := GenParamValue[I] == 'true'</l>
<c>            * 'circle'</c>
<l>        elseif  (GenParamName[I] == GEN_CIRCLE)</l>
<c>            * Check if values are valid</c>
<l>            if (GenParamValue[I] != 'true' and GenParamValue[I] != 'false')</l>
<l>                throw ('Wrong parameter value for generic parameter \'circle\': '+GenParamValue[I]+' Please use \'true\' or \'false\'.')</l>
<l>            endif</l>
<c>            * Set new value</c>
<l>            DisplayCircle := GenParamValue[I] == 'true'</l>
<l>        elseif  (GenParamName[I] == GEN_LEGEND)</l>
<c>            * Check if values are valid</c>
<l>            if (GenParamValue[I] != 'true' and GenParamValue[I] != 'false')</l>
<l>                throw ('Wrong parameter value for generic parameter \'legend\': '+GenParamValue[I]+' Please use \'true\' or \'false\'.')</l>
<l>            endif</l>
<c>            * Set new value</c>
<l>            DisplayLegend := GenParamValue[I] == 'true'</l>
<l>        elseif  (GenParamName[I] == GEN_MAX_GRADE)</l>
<c>            * Check if values are valid</c>
<l>            if (GenParamValue[I] &lt; 0 or GenParamValue[I] &gt; 4)</l>
<l>                throw ('Wrong parameter value for generic parameter \'max_grade\': '+GenParamValue[I]+' Please use a value between 0 and 4.')</l>
<l>            endif</l>
<c>            * Set new value</c>
<l>            MaxGrade := int(GenParamValue[I])</l>
<l>        else</l>
<c>            * Unknown parameter</c>
<l>            throw ('Unknown generic parameter: \''+GenParamName[I])</l>
<l>        endif</l>
<l>    endfor   </l>
<l>endif</l>
<c>*</c>
<c>* Check Color</c>
<l>if (|Color| == 0)</l>
<l>    Color := ['red','orange','yellow','cyan','green']  </l>
<l>endif</l>
<c>* Build color tuple with rotating colors if too few colors are specified</c>
<l>while (|Color| &lt; MaxGrade+1)</l>
<l>    Color := [Color, Color]</l>
<l>endwhile</l>
<c>*</c>
<c>* Visualization</c>
<c>*</c>
<c>* Get modulation grades, rows and cols for all symbol modules incl.</c>
<c>* the 4 quiet zones adjacent to the symbol and the finder patterns.</c>
<l>QualityParameter := QualityStandard + '_reflectance_margin_module_grades'</l>
<l>QualityRows := QualityStandard + '_rows'</l>
<l>QualityCols := QualityStandard + '_cols'</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityParameter, ModuleGrades)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityRows, Rows)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityCols, Cols)</l>
<l>QualityLabels := QualityStandard + '_labels'</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityStandard, Grades)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, QualityLabels, Labels)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, 'module_height', ModuleHeight)</l>
<l>get_data_code_2d_results (DataCodeHandle, ResultHandle, 'module_width', ModuleWidth)</l>
<l>Aperture := Grades[find (Labels, 'Aperture')]</l>
<l>Radius := 0.5 * Aperture * min2(ModuleHeight, ModuleWidth)   </l>
<c>*</c>
<c>* Iterate over all possible modulation grades to visualize</c>
<l>for Grade := 0 to MaxGrade by 1</l>
<l>    GradeIdx := find(ModuleGrades, Grade)</l>
<l>    if (GradeIdx &lt; 0)</l>
<l>        continue</l>
<l>    endif</l>
<l>    GradeRows := Rows[GradeIdx]</l>
<l>    GradeCols := Cols[GradeIdx]</l>
<l>    GradeRadius := gen_tuple_const (|GradeRows|, Radius)</l>
<l>    dev_set_color (Color[Grade])</l>
<l>    if (DisplayCircle)</l>
<l>        gen_circle_contour_xld (Circle, GradeRows, GradeCols, GradeRadius, rad(0), rad(360), 'positive', 1)</l>
<l>        dev_display (Circle)</l>
<l>    endif</l>
<l>    if (DisplayCenter)</l>
<l>        gen_cross_contour_xld (Cross, GradeRows, GradeCols, 2*Radius, rad(0))</l>
<l>        dev_display (Cross)</l>
<l>    endif</l>
<l>endfor</l>
<l>if (DisplayLegend)</l>
<c>    * Display legend with modulation grades</c>
<l>    dev_disp_text (['Reflectance Margin','Module Grade ' + [0:MaxGrade]], 'window', 'bottom', 'left', ['white', Color], ['box_color'], ['#00000080'])</l>
<l>endif   </l>
<l>return ()</l>
</body>
<docu id="dev_display_data_code_2d_print_quality_results">
<abstract lang="en_US">This procedure can be used to display data code modules with print quality problems according to the data code standards ISO/IEC 15415 or AIM/DPM-1-2006.
The procedure calculates the reflectance margin module grades as described in ISO/IEC 15415 Chapter 7.8.4.3 (analogously for other standards), and displays the grades in different colors.
Unused modules are not displayed.

3 different modes are available that use different presets for the visualization:'reflectance_margin_module_grades' (default), 'bad_modules', 'grid'

'reflectance_margin_module_grades':
Display all modules with a grade less than 4 in different colors.
Used generic parameter settings: 'circle' = 'true', 'center' = 'false', 'legend' = 'true', 'max_grade' = 3.

'bad_modules':
Display only modules with a reflectance margin module grade of 0. These are modules that either are completely wrong (i.e., white instead of black and vice versa), or modules with a very bad modulation (i.e., with a gray value close to the calculated threshold between black and white modules).
Used generic parameter settings: 'circle' = 'true', 'center' = 'false', 'legend' = 'false', 'max_grade' = 0.

'grid':
Shows crosses at the positions where the module grades are calculated.
Used generic parameter settings: 'circle' = 'false', 'center' = 'true', 'legend' = 'false', 'max_grade' = 4.

The used standard can be specified in QualityStandard. Available values: 'isoiec15415', 'isoiec_tr_29158'.

The color palette used to display the module grades can be specified in Color. Color expects one color for each displayed grade. If less colors than grades are used, the colors are cycled through.


Available generic parameters:

'circle':
For every module, display a circle with a radius corresponding to the calculated aperture.
Possible values: 'true', 'false' 

'center':
For every module, display a cross at the position where the module grade is calculated.
Possible values: 'true', 'false'

'legend':
Display a legend that shows the used colors for each grade.
Possible values: 'true', 'false'

'max_grade':
Display only modules that have a grade less or equal to this value.
Possible values: 0,1,2,3,4
</abstract>
<chapters lang="de_DE">
<item>Identifizierung</item>
<item>Datacode</item>
</chapters>
<chapters lang="en_US">
<item>Identification</item>
<item>Data Code</item>
</chapters>
<example lang="en_US">create_data_code_2d_model ('Data Matrix ECC 200', [], [], DataCodeHandle)
set_data_code_2d_param (DataCodeHandle, 'default_parameters', 'enhanced_recognition')
read_image (Image, 'datacode/ecc200/ecc200_print_quality_02')
find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, [], [], ResultHandle, DecodedDataStrings)
dev_display(Image)
Mode := 'reflectance_margin_module_grade'
dev_display_data_code_2d_print_quality_results (DataCodeHandle, ResultHandle, Mode, 'isoiec15415', [], [], [])    </example>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Display print quality information for individual data code modules.
</short>
<parameters>
<parameter id="Color">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Color(s) of the displayed modules.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>['red','#cc0000','#990000','#660000']</item>
<item>'gray'</item>
</values>
</parameter>
<parameter id="DataCodeHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the 2D data code model.</description>
<mixed_type>false</mixed_type>
<sem_type>datacode_2d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of optional parameters to configure the output.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'center'</item>
<item>'circle'</item>
<item>'legend'</item>
<item>'max_grade'</item>
</value_list>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Values of the optional parameters.</description>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
<item>0</item>
<item>1</item>
<item>2</item>
<item>3</item>
<item>4</item>
</value_list>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<default_value>'reflectance_margin_module_grades'</default_value>
<description lang="en_US">Display mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'reflectance_margin_module_grades'</item>
<item>'bad_modules'</item>
<item>'grid'</item>
</value_list>
</parameter>
<parameter id="QualityStandard">
<default_type>string</default_type>
<default_value>'isoiec15415'</default_value>
<description lang="en_US">Quality standard used for calculation of the module grades.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'isoiec15415'</item>
<item>'isoiec_tr_29158'</item>
<item>'aimdpm_1_2006'</item>
</value_list>
</parameter>
<parameter id="ResultHandle">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Handle of the 2D data code result handle.</description>
<mixed_type>false</mixed_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_ncc_matching_results">
<interface>
<ic>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="Model" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays the results of Correlation-Based Matching.</c>
<c>* </c>
<l>NumMatches := |Row|</l>
<l>if (NumMatches &gt; 0)</l>
<l>    if (|Model| == 0)</l>
<l>        tuple_gen_const (NumMatches, 0, Model)</l>
<l>    elseif (|Model| == 1)</l>
<l>        tuple_gen_const (NumMatches, Model, Model)</l>
<l>    endif</l>
<l>    for Index := 0 to |ModelID| - 1 by 1</l>
<l>        get_ncc_model_region (ModelRegion, ModelID[Index])</l>
<l>        gen_contour_region_xld (ModelRegion, ModelContours, 'border_holes')</l>
<l>        dev_set_color (Color[Index % |Color|])</l>
<l>        for Match := 0 to NumMatches - 1 by 1</l>
<l>            if (Index == Model[Match])</l>
<l>                hom_mat2d_identity (HomMat2DIdentity)</l>
<l>                hom_mat2d_rotate (HomMat2DIdentity, Angle[Match], 0, 0, HomMat2DRotate)</l>
<l>                hom_mat2d_translate (HomMat2DRotate, Row[Match], Column[Match], HomMat2DTranslate)</l>
<l>                affine_trans_contour_xld (ModelContours, ContoursAffinTrans, HomMat2DTranslate)</l>
<l>                dev_display (ContoursAffinTrans)</l>
<l>                affine_trans_pixel (HomMat2DTranslate, 0, 0, RowTrans, ColTrans)</l>
<l>                gen_cross_contour_xld (Cross, RowTrans, ColTrans, 6, Angle[Match])</l>
<l>                dev_display (Cross)</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="dev_display_ncc_matching_results">
<abstract lang="en_US">The procedure dev_display_ncc_matching_results displays the results of correlation-based matching. 

In ModelID, the NCC models for which results should be displayed are passed. This parameter typically contains the same values that were returned by the operators find_ncc_model or find_ncc_models.

Color is a tuple of colors that will be used for the visualization. If Color contains only one element, all found instances are displayed in this color. If each found instance should be displayed in a color associated with the respective NCC model, the number of colors has to correspond to the number of NCC models in ModelID. If Color is a tuple that does not have the same number of elements as ModelID, the specified colors are used cyclically for the visualization of the matching results.


Row, Column, and Angle contain the position and rotation information of the found instances of the NCC models.

The elements of Model describe to which element of the tuple ModelID the elements of Row, Column, Angle refer to. The elements of Model are indices into the tuple ModelID, i.e., they can contain values from 0 to |ModelID|-1.  Hence, a value of 0 in an element of Model corresponds to an instance of the first model in ModelID. If only one model is given in ModelID, Model can be set to 0. Otherwise, the output of the operator find_ncc_models can be used directly.
</abstract>
<chapters>
<item>Matching</item>
<item>Shape-Based</item>
</chapters>
<chapters lang="de_DE">
<item>Matching</item>
<item>Korrelationsbasiert</item>
</chapters>
<chapters lang="en_US">
<item>Matching</item>
<item>Correlation-Based</item>
</chapters>
<example lang="en_US">read_image (Image, 'circle_plate')
* 
gen_rectangle2 (Template, 420, 786, 0, 50, 50)
reduce_domain (Image, Template, ImageTemplate)
create_ncc_model (ImageTemplate, 'auto', -rad(45), rad(90), 'auto', 'use_polarity', Model1ID)
*
gen_rectangle2 (Template, 710, 790, 0, 100, 100)
reduce_domain (Image, Template, ImageTemplate)
create_ncc_model (ImageTemplate, 'auto', -rad(45), rad(90), 'auto', 'use_polarity', Model2ID)
*
ModelIDs := [Model1ID,Model2ID]
rotate_image (ImageTemplate, ImageRotate, 10, 'constant')
find_ncc_models (ImageRotate, ModelIDs,  -rad(45), rad(90), 0.8, 2, 0.5, 'true', 0, Row, Column, Angle, Score, Model)
*
dev_display_ncc_matching_results (ModelIDs, ['green', 'blue'], Row, Column, Angle, Model)
</example>
<keywords lang="de_DE">
<item>Ergebnisse des korrelationsbasierten Matchings anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display results of correlation-based matching</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>find_ncc_model</item>
<item>find_ncc_models</item>
</predecessor>
<short>This procedure displays the results of Shape-based Matching.</short>
<short lang="de_DE">Anzeigen der Ergebnisse der korrelationsbasierten Matchings.</short>
<short lang="en_US">Display the results of Correlation-Based Matching.</short>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="en_US">Rotation angle of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'red'</default_value>
<description lang="en_US">Colors used for the visualization of the matching result.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>['red','green','blue']</item>
<item>['red','green','blue','cyan','magenta','yellow']</item>
</values>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Model">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Index of the found instances of the models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelID">
<default_type>integer</default_type>
<description lang="en_US">IDs of the NCC models for which the results should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>ncc_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_display_shape_matching_results">
<interface>
<ic>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="ScaleR" base_type="ctrl" dimension="0"/>
<par name="ScaleC" base_type="ctrl" dimension="0"/>
<par name="Model" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays the results of Shape-Based Matching.</c>
<c>* </c>
<l>NumMatches := |Row|</l>
<l>if (NumMatches &gt; 0)</l>
<l>    if (|ScaleR| == 1)</l>
<l>        tuple_gen_const (NumMatches, ScaleR, ScaleR)</l>
<l>    endif</l>
<l>    if (|ScaleC| == 1)</l>
<l>        tuple_gen_const (NumMatches, ScaleC, ScaleC)</l>
<l>    endif</l>
<l>    if (|Model| == 0)</l>
<l>        tuple_gen_const (NumMatches, 0, Model)</l>
<l>    elseif (|Model| == 1)</l>
<l>        tuple_gen_const (NumMatches, Model, Model)</l>
<l>    endif</l>
<l>    for Index := 0 to |ModelID| - 1 by 1</l>
<l>        get_shape_model_contours (ModelContours, ModelID[Index], 1)</l>
<l>        dev_set_color (Color[Index % |Color|])</l>
<l>        for Match := 0 to NumMatches - 1 by 1</l>
<l>            if (Index == Model[Match])</l>
<l>                hom_mat2d_identity (HomMat2DIdentity)</l>
<l>                hom_mat2d_scale (HomMat2DIdentity, ScaleR[Match], ScaleC[Match], 0, 0, HomMat2DScale)</l>
<l>                hom_mat2d_rotate (HomMat2DScale, Angle[Match], 0, 0, HomMat2DRotate)</l>
<l>                hom_mat2d_translate (HomMat2DRotate, Row[Match], Column[Match], HomMat2DTranslate)</l>
<l>                affine_trans_contour_xld (ModelContours, ContoursAffinTrans, HomMat2DTranslate)</l>
<l>                dev_display (ContoursAffinTrans)</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="dev_display_shape_matching_results">
<abstract lang="en_US">The procedure dev_display_shape_matching_results displays the results of shape-based matching. 

In ModelID, the shape models for which results should be displayed are passed. This parameter typically contains the same values that were passed to the operator that was used to find the instances of the shape model.

Color is a tuple of colors that will be used for the visualization. If Color contains only one element, all found instances are displayed in this color. If each found instance should be displayed in a color associated with the respective shape model, the number of colors has to correspond to the number of shape models in ModelID. If Color is a tuple that does not have the same number of elements as ModelID, the specified colors are used cyclically for the visualization of the matching results.

Row, Column, and Angle contain the position and rotation information of the found instances of the shape models.

ScaleR and ScaleC contain the scale of the found instances of the shape model. If find_shape_model(s) was used to find the instances of the shape model, ScaleR and ScaleC should be set to 1.0. If find_scaled_shape_model(s) was used to find the instances of the shape model, ScaleR contains the scale of the found instances and ScaleC should be set to 1.0. If find_aniso_shape_model(s) was used to find the instances of the shape model, ScaleR and ScaleC contain the respective anisotropic scales of the found instances.

The elements of Model describe to which element of the tuple ModelID the elements of Row, Column, Angle, ScaleR, and ScaleC refer to. The elements of Model are indices into the tuple ModelID, i.e., they can contain values from 0 to |ModelID|-1.  Hence, a value of 0 in an element of Model corresponds to an instance of the first model in ModelID. If only one model is given in ModelID, Model can be set to 0. Otherwise, the output of the operators find_shape_models, find_scaled_shape_models, or find_aniso_shape_models can be used directly.
</abstract>
<chapters>
<item>Matching</item>
<item>Shape-Based</item>
</chapters>
<chapters lang="de_DE">
<item>Matching</item>
<item>Formbasiert</item>
</chapters>
<chapters lang="en_US">
<item>Matching</item>
<item>Shape-Based</item>
</chapters>
<example lang="en_US">read_image(Image,'mreut')
gen_rectangle1(Rectangle1, 30, 20, 100, 200)
gen_rectangle1 (Rectangle2, 130, 120, 200, 200)
reduce_domain (Image, Rectangle1, ImageReduced1)
reduce_domain (Image, Rectangle2, ImageReduced2)
create_scaled_shape_model(ImageReduced1, 'auto', -0.39, 0.79,
                          'auto', 0.9, 1.1, 'auto', 'auto',
                          'use_polarity', 'auto', 'auto', ModelID1)
create_scaled_shape_model(ImageReduced2, 'auto', -0.39, 0.79,
                          'auto', 0.9, 1.1, 'auto', 'auto',
                          'use_polarity', 'auto', 'auto', ModelID2)
find_scaled_shape_models (Image, [ModelID1,ModelID2], -0.39, 0.78,
                          0.9, 1.1, 0.5, 2, 0.5, 'least_squares', 0, 0.9,
                          Row, Column, Angle, Scale, Score, Model)
dev_display_shape_matching_results ([ModelID1,ModelID2], ['red','green'],
                          Row, Column, Angle, Scale, 1.0, Model)
</example>
<keywords lang="de_DE">
<item>Ergebnisse des formbasierten Matchings anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display results of shape-based matching</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>find_shape_model</item>
<item>find_shape_models</item>
<item>find_scaled_shape_model</item>
<item>find_scaled_shape_models</item>
<item>find_aniso_shape_model</item>
<item>find_aniso_shape_models</item>
</predecessor>
<short>This procedure displays the results of Shape-based Matching.</short>
<short lang="de_DE">Anzeigen der Ergebnisse des formbasierten Matchings.</short>
<short lang="en_US">Display the results of Shape-Based Matching.</short>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="en_US">Rotation angle of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'red'</default_value>
<description lang="en_US">Colors used for the visualization of the matching result.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>['red','green','blue']</item>
<item>['red','green','blue','cyan','magenta','yellow']</item>
</values>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Model">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Index of the found instances of the models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelID">
<default_type>integer</default_type>
<description lang="en_US">IDs of the shape models for which the results should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>shape_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the found instances of the models.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ScaleC">
<default_type>real</default_type>
<default_value>1.0</default_value>
<description lang="en_US">Scale of the found instances of the models inthe column direction.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ScaleR">
<default_type>real</default_type>
<default_value>1.0</default_value>
<description lang="en_US">Scale of the found instances of the models inthe row direction.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_open_window_fit_image">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="WidthLimit" base_type="ctrl" dimension="0"/>
<par name="HeightLimit" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure opens a new graphics window and adjusts the size</c>
<c>* such that it fits into the limits specified by WidthLimit</c>
<c>* and HeightLimit, but also maintains the correct image aspect ratio.</c>
<c>* </c>
<c>* If it is impossible to match the minimum and maximum extent requirements</c>
<c>* at the same time (f.e. if the image is very long but narrow),</c>
<c>* the maximum value gets a higher priority,</c>
<c>* </c>
<c>* Parse input tuple WidthLimit</c>
<l>if (|WidthLimit| == 0 or WidthLimit &lt; 0)</l>
<l>    MinWidth := 500</l>
<l>    MaxWidth := 800</l>
<l>elseif (|WidthLimit| == 1)</l>
<l>    MinWidth := 0</l>
<l>    MaxWidth := WidthLimit</l>
<l>else</l>
<l>    MinWidth := WidthLimit[0]</l>
<l>    MaxWidth := WidthLimit[1]</l>
<l>endif</l>
<c>* Parse input tuple HeightLimit</c>
<l>if (|HeightLimit| == 0 or HeightLimit &lt; 0)</l>
<l>    MinHeight := 400</l>
<l>    MaxHeight := 600</l>
<l>elseif (|HeightLimit| == 1)</l>
<l>    MinHeight := 0</l>
<l>    MaxHeight := HeightLimit</l>
<l>else</l>
<l>    MinHeight := HeightLimit[0]</l>
<l>    MaxHeight := HeightLimit[1]</l>
<l>endif</l>
<c>* </c>
<c>* Test, if window size has to be changed.</c>
<l>ResizeFactor := 1</l>
<l>get_image_size (Image, ImageWidth, ImageHeight)</l>
<c>* First, expand window to the minimum extents (if necessary).</c>
<l>if (MinWidth &gt; ImageWidth or MinHeight &gt; ImageHeight)</l>
<l>    ResizeFactor := max([real(MinWidth) / ImageWidth,real(MinHeight) / ImageHeight])</l>
<l>endif</l>
<l>TempWidth := ImageWidth * ResizeFactor</l>
<l>TempHeight := ImageHeight * ResizeFactor</l>
<c>* Then, shrink window to maximum extents (if necessary).</c>
<l>if (MaxWidth &lt; TempWidth or MaxHeight &lt; TempHeight)</l>
<l>    ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])</l>
<l>endif</l>
<l>WindowWidth := ImageWidth * ResizeFactor</l>
<l>WindowHeight := ImageHeight * ResizeFactor</l>
<c>* Resize window</c>
<l>dev_open_window (Row, Column, WindowWidth, WindowHeight, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, ImageHeight - 1, ImageWidth - 1)</l>
<l>return ()</l>
</body>
<docu id="dev_open_window_fit_image">
<abstract lang="en_US">This procedure  opens a new graphics window with a given minimum and maximum extent such that it preserves the aspect ratio of the given image.

The position of the new graphics window is given by the parameters Row and Column, which define the position of the upper left corner of the graphics window.

The size of the new graphics window is determined such that the limits given in WidthLimit and HeightLimit are fulfilled and that the aspect ratio of the given image is preserved. To restrict only the maximum size of the new graphics window, only one value must be passed in WidthLimit and HeightLimit, respectively. To restrict both the minimum and the maximum size, WidthLimit and HeightLimit must contain a tuple with two elements, each. The first element defines the minimum size and the second element defines the maximum size of the new graphics window.

If it is not possible to set the window size such that all limits (minimum and maximum width and height as well as the aspect ratio of the given image) are fulfilled, the limit for the minimum window size is neglected.

If WidthLimit is empty or negative, the following default value is used: [500,800].
If HeightLimit is empty or negative, the following default value is used: [400,600].</abstract>
<alternatives>
<item>dev_open_window_fit_size</item>
<item>dev_open_window</item>
</alternatives>
<chapters>
<item>Develop</item>
</chapters>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">read_image (Image, 'mreut')
*
* Open a new graphics window with the default size limits.
dev_open_window_fit_image (Image, 0, 0, -1, -1, WindowHandle1)
*
* Open a new graphics window at the position (50,50) with a
* minimum size of 300 x 200 and a maximum size of 600 x 400.
dev_open_window_fit_image (Image, 50, 50, [300,600], [200,400],
                           WindowHandle2)</example>
<keywords lang="de_DE">
<item>Grafikfenster öffnen</item>
<item>Größe eines Grafikfensters setzen</item>
</keywords>
<keywords lang="en_US">
<item>open graphics window</item>
<item>set size of graphics window</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_resize_window_fit_image</item>
<item>dev_resize_window_fit_size</item>
</see_also>
<short>Opens a graphics window with a given maximum and minimum extent such that it preserves the aspect ratio of the given image</short>
<short lang="de_DE">Open a new graphics window that preserves the aspect ratio of the given image.</short>
<short lang="en_US">Open a new graphics window that preserves the aspect ratio of the given image.</short>
<successor>
<item>dev_display</item>
</successor>
<parameters>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Column coordinate of the upper left corner of the new window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="HeightLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window height.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="Image">
<description lang="en_US">Image to the size of which the new window is adapted.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Row coordinate of the upper left corner of the new window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="WidthLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window width.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[300,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the new graphics window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_open_window_fit_size">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="WidthLimit" base_type="ctrl" dimension="0"/>
<par name="HeightLimit" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure open a new graphic window</c>
<c>* such that it fits into the limits specified by WidthLimit</c>
<c>* and HeightLimit, but also maintains the correct aspect ratio</c>
<c>* given by Width and Height.</c>
<c>* </c>
<c>* If it is impossible to match the minimum and maximum extent requirements</c>
<c>* at the same time (f.e. if the image is very long but narrow),</c>
<c>* the maximum value gets a higher priority.</c>
<c>* </c>
<c>* Parse input tuple WidthLimit</c>
<l>if (|WidthLimit| == 0 or WidthLimit &lt; 0)</l>
<l>    MinWidth := 500</l>
<l>    MaxWidth := 800</l>
<l>elseif (|WidthLimit| == 1)</l>
<l>    MinWidth := 0</l>
<l>    MaxWidth := WidthLimit</l>
<l>else</l>
<l>    MinWidth := WidthLimit[0]</l>
<l>    MaxWidth := WidthLimit[1]</l>
<l>endif</l>
<c>* Parse input tuple HeightLimit</c>
<l>if (|HeightLimit| == 0 or HeightLimit &lt; 0)</l>
<l>    MinHeight := 400</l>
<l>    MaxHeight := 600</l>
<l>elseif (|HeightLimit| == 1)</l>
<l>    MinHeight := 0</l>
<l>    MaxHeight := HeightLimit</l>
<l>else</l>
<l>    MinHeight := HeightLimit[0]</l>
<l>    MaxHeight := HeightLimit[1]</l>
<l>endif</l>
<c>* </c>
<c>* Test, if window size has to be changed.</c>
<l>ResizeFactor := 1</l>
<c>* First, expand window to the minimum extents (if necessary).</c>
<l>if (MinWidth &gt; Width or MinHeight &gt; Height)</l>
<l>    ResizeFactor := max([real(MinWidth) / Width,real(MinHeight) / Height])</l>
<l>endif</l>
<l>TempWidth := Width * ResizeFactor</l>
<l>TempHeight := Height * ResizeFactor</l>
<c>* Then, shrink window to maximum extents (if necessary).</c>
<l>if (MaxWidth &lt; TempWidth or MaxHeight &lt; TempHeight)</l>
<l>    ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])</l>
<l>endif</l>
<l>WindowWidth := Width * ResizeFactor</l>
<l>WindowHeight := Height * ResizeFactor</l>
<c>* Resize window</c>
<l>dev_open_window (Row, Column, WindowWidth, WindowHeight, 'black', WindowHandle)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>return ()</l>
</body>
<docu id="dev_open_window_fit_size">
<abstract lang="en_US">The procedure dev_open_window_fit_size opens a new graphics window with a given minimum and maximum extent such that it preserves the aspect ratio of the given image size.

The position of the new graphics window is given by the parameters Row and Column, which define the position of the upper left corner of the graphics window.

The size of the new graphics window is determined such that the limits given in WidthLimit and HeightLimit are fulfilled and that the aspect ratio of the image size that is given in Width and Height is preserved. To restrict only the maximum size of the new graphics window, only one value must be passed in WidthLimit and HeightLimit, respectively. To restrict both the minimum and the maximum size, WidthLimit and HeightLimit must contain a tuple with two elements, each. The first element defines the minimum size and the second element defines the maximum size of the new graphics window.

If it is not possible to set the window size such that all limits (minimum and maximum width and height as well as the aspect ratio of the given image size) are fulfilled, the limit for the minimum window size is neglected.

If WidthLimit is set to -1, the following default value is used: [500,800].
If HeightLimit is set to -1, the following default value is used: [400,600].</abstract>
<alternatives>
<item>dev_open_window_fit_image</item>
<item>dev_open_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">*
* Open a new graphics window with the default size limits.
dev_open_window_fit_size (0, 0, 640, 480, -1, -1, WindowHandle1)
*
* Open a new graphics window at the position (50,50) with a
* minimum size of 300 x 200 and a maximum size of 600 x 400.
* The window is intended to display a large image with a width
* of 2000 pixel and a height of 15000 pixel while preserving the
* aspect ratio. Note that in this case the minimum width is
* neglected.
dev_open_window_fit_size (50, 50, 2000, 15000, [300,600], [400,800],
                          WindowHandle2)</example>
<keywords lang="de_DE">
<item>Grafikfenster öffnen</item>
<item>Größe eines Grafikfensters setzen</item>
</keywords>
<keywords lang="en_US">
<item>open graphics window</item>
<item>set size of graphics window</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_resize_window_fit_size</item>
<item>dev_resize_window_fit_image</item>
</see_also>
<short lang="de_DE">Open a new graphics window that preserves the aspect ratio of the given image size.</short>
<short lang="en_US">Open a new graphics window that preserves the aspect ratio of the given image size.</short>
<successor>
<item>dev_display</item>
</successor>
<parameters>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Column coordinate of the upper left corner of the new window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="Height">
<default_type>integer</default_type>
<description lang="en_US">The height of the image to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>480</item>
<item>600</item>
<item>768</item>
<item>960</item>
<item>1050</item>
<item>1200</item>
<item>1536</item>
<item>2100</item>
<item>2400</item>
<item>4800</item>
</values>
</parameter>
<parameter id="HeightLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window height.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Row coordinate of the upper left corner of the new window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="Width">
<default_type>integer</default_type>
<description lang="en_US">The width of the image to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>640</item>
<item>800</item>
<item>1024</item>
<item>1280</item>
<item>1400</item>
<item>1600</item>
<item>2048</item>
<item>2800</item>
<item>3200</item>
<item>6400</item>
</values>
</parameter>
<parameter id="WidthLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window width.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the new graphics window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_resize_window_fit_image">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="WidthLimit" base_type="ctrl" dimension="0"/>
<par name="HeightLimit" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure adjusts the size of the current window</c>
<c>* such that it fits into the limits specified by WidthLimit</c>
<c>* and HeightLimit, but also maintains the correct image aspect ratio.</c>
<c>* </c>
<c>* If it is impossible to match the minimum and maximum extent requirements</c>
<c>* at the same time (f.e. if the image is very long but narrow),</c>
<c>* the maximum value gets a higher priority,</c>
<c>* </c>
<c>* Parse input tuple WidthLimit</c>
<l>if (|WidthLimit| == 0 or WidthLimit &lt; 0)</l>
<l>    MinWidth := 500</l>
<l>    MaxWidth := 800</l>
<l>elseif (|WidthLimit| == 1)</l>
<l>    MinWidth := 0</l>
<l>    MaxWidth := WidthLimit</l>
<l>else</l>
<l>    MinWidth := WidthLimit[0]</l>
<l>    MaxWidth := WidthLimit[1]</l>
<l>endif</l>
<c>* Parse input tuple HeightLimit</c>
<l>if (|HeightLimit| == 0 or HeightLimit &lt; 0)</l>
<l>    MinHeight := 400</l>
<l>    MaxHeight := 600</l>
<l>elseif (|HeightLimit| == 1)</l>
<l>    MinHeight := 0</l>
<l>    MaxHeight := HeightLimit</l>
<l>else</l>
<l>    MinHeight := HeightLimit[0]</l>
<l>    MaxHeight := HeightLimit[1]</l>
<l>endif</l>
<c>* </c>
<c>* Test, if window size has to be changed.</c>
<l>ResizeFactor := 1</l>
<l>get_image_pointer1 (Image, Pointer, Type, ImageWidth, ImageHeight)</l>
<c>* First, expand window to the minimum extents (if necessary).</c>
<l>if (MinWidth &gt; ImageWidth or MinHeight &gt; ImageHeight)</l>
<l>    ResizeFactor := max([real(MinWidth) / ImageWidth,real(MinHeight) / ImageHeight])</l>
<l>endif</l>
<l>TempWidth := ImageWidth * ResizeFactor</l>
<l>TempHeight := ImageHeight * ResizeFactor</l>
<c>* Then, shrink window to maximum extents (if necessary).</c>
<l>if (MaxWidth &lt; TempWidth or MaxHeight &lt; TempHeight)</l>
<l>    ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])</l>
<l>endif</l>
<l>WindowWidth := ImageWidth * ResizeFactor</l>
<l>WindowHeight := ImageHeight * ResizeFactor</l>
<c>* Resize window</c>
<l>dev_set_window_extents (Row, Column, WindowWidth, WindowHeight)</l>
<l>dev_set_part (0, 0, ImageHeight - 1, ImageWidth - 1)</l>
<l>return ()</l>
</body>
<docu id="dev_resize_window_fit_image">
<abstract lang="en_US">This procedure resizes the current graphics window with a given minimum and maximum extent such that it preserves the aspect ratio of the given image.

The position of the new graphics window is given by the parameters Row and Column, which define the position of the upper left corner of the graphics window.

The size of the new graphics window is determined such that the limits given in WidthLimit and HeightLimit are fulfilled and that the aspect ratio of the given image is preserved. To restrict only the maximum size of the new graphics window, only one value must be passed in WidthLimit and HeightLimit, respectively. To restrict both the minimum and the maximum size, WidthLimit and HeightLimit must contain a tuple with two elements, each. The first element defines the minimum size and the second element defines the maximum size of the new graphics window.

If it is not possible to set the window size such that all limits (minimum and maximum width and height as well as the aspect ratio of the given image) are fulfilled, the limit for the minimum window size is neglected.

If WidthLimit is empty or negative, the following default value is used: [500,800].
If HeightLimit is empty or negative, the following default value is used: [400,600].</abstract>
<alternatives>
<item>dev_resize_window_fit_size</item>
<item>dev_set_window_extents</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 200, 200, 'black', WindowHandle)
*
read_image (Image, 'mreut')
*
dev_resize_window_fit_image (Image, 0, 0, -1, -1)
</example>
<keywords lang="de_DE">
<item>Größe eines Grafikfensters setzen</item>
</keywords>
<keywords lang="en_US">
<item>set size of graphics window</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
</predecessor>
<see_also>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
</see_also>
<short lang="de_DE">Changes the size of a graphics window with a given maximum and minimum extent such that it preserves the aspect ratio of the given image</short>
<short lang="en_US">Changes the size of a graphics window with a given maximum and minimum extent such that it preserves the aspect ratio of the given image</short>
<successor>
<item>dev_display</item>
</successor>
<parameters>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Column coordinate of the upper left corner of the window.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="HeightLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window height.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="Image">
<description lang="en_US">Image to the size of which the window is adapted.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
<item>vector_field</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Row coordinate of the upper left corner of the new window.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="WidthLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window width.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[300,600]</item>
<item>[500,800]</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_resize_window_fit_size">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="WidthLimit" base_type="ctrl" dimension="0"/>
<par name="HeightLimit" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure adjusts the size of the current window</c>
<c>* such that it fits into the limits specified by WidthLimit</c>
<c>* and HeightLimit, but also maintains the correct aspect ratio</c>
<c>* given by Width and Height.</c>
<c>* </c>
<c>* If it is impossible to match the minimum and maximum extent requirements</c>
<c>* at the same time (f.e. if the image is very long but narrow),</c>
<c>* the maximum value gets a higher priority.</c>
<c>* </c>
<c>* Parse input tuple WidthLimit</c>
<l>if (|WidthLimit| == 0 or WidthLimit &lt; 0)</l>
<l>    MinWidth := 500</l>
<l>    MaxWidth := 800</l>
<l>elseif (|WidthLimit| == 1)</l>
<l>    MinWidth := 0</l>
<l>    MaxWidth := WidthLimit</l>
<l>else</l>
<l>    MinWidth := WidthLimit[0]</l>
<l>    MaxWidth := WidthLimit[1]</l>
<l>endif</l>
<c>* Parse input tuple HeightLimit</c>
<l>if (|HeightLimit| == 0 or HeightLimit &lt; 0)</l>
<l>    MinHeight := 400</l>
<l>    MaxHeight := 600</l>
<l>elseif (|HeightLimit| == 1)</l>
<l>    MinHeight := 0</l>
<l>    MaxHeight := HeightLimit</l>
<l>else</l>
<l>    MinHeight := HeightLimit[0]</l>
<l>    MaxHeight := HeightLimit[1]</l>
<l>endif</l>
<c>* </c>
<c>* Test, if window size has to be changed.</c>
<l>ResizeFactor := 1</l>
<c>* First, expand window to the minimum extents (if necessary).</c>
<l>if (MinWidth &gt; Width or MinHeight &gt; Height)</l>
<l>    ResizeFactor := max([real(MinWidth) / Width,real(MinHeight) / Height])</l>
<l>endif</l>
<l>TempWidth := Width * ResizeFactor</l>
<l>TempHeight := Height * ResizeFactor</l>
<c>* Then, shrink window to maximum extents (if necessary).</c>
<l>if (MaxWidth &lt; TempWidth or MaxHeight &lt; TempHeight)</l>
<l>    ResizeFactor := ResizeFactor * min([real(MaxWidth) / TempWidth,real(MaxHeight) / TempHeight])</l>
<l>endif</l>
<l>WindowWidth := Width * ResizeFactor</l>
<l>WindowHeight := Height * ResizeFactor</l>
<c>* Resize window</c>
<l>dev_set_window_extents (Row, Column, WindowWidth, WindowHeight)</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<l>return ()</l>
</body>
<docu id="dev_resize_window_fit_size">
<abstract lang="en_US">This procedure resizes the current graphics window with a given minimum and maximum extent such that it preserves the aspect ratio of the given image size.

The position of the graphics window is given by the parameters Row and Column, which define the position of the upper left corner of the graphics window.

The size of the new graphics window is determined such that the limits given in WidthLimit and HeightLimit are fulfilled and that the aspect ratio of the image size that is given in Width and Height is preserved. To restrict only the maximum size of the new graphics window, only one value must be passed in WidthLimit and HeightLimit, respectively. To restrict both the minimum and the maximum size, WidthLimit and HeightLimit must contain a tuple with two elements, each. The first element defines the minimum size and the second element defines the maximum size of the new graphics window.

If it is not possible to set the window size such that all limits (minimum and maximum width and height as well as the aspect ratio of the given image size) are fulfilled, the limit for the minimum window size is neglected.

If WidthLimit is empty or negative, the following default value is used: [500,800].
If HeightLimit is empty or negative, the following default value is used: [400,600].</abstract>
<alternatives>
<item>dev_resize_window_fit_image</item>
<item>dev_set_window_extents</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
*
gen_image_const (Image, 'byte', 2000, 128)
*
dev_resize_window_fit_size (0, 0, 2000, 128, -1, -1)</example>
<keywords lang="de_DE">
<item>Größe eines Grafikfensters setzen</item>
</keywords>
<keywords lang="en_US">
<item>set size of graphics window</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
</predecessor>
<see_also>
<item>dev_open_window_fit_size</item>
<item>dev_open_window_fit_image</item>
<item>dev_set_window_extents</item>
</see_also>
<short lang="de_DE">Resizes a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height</short>
<short lang="en_US">Resizes a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height</short>
<successor>
<item>dev_display</item>
</successor>
<parameters>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Column coordinate of the upper left corner of the window.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="Height">
<default_type>integer</default_type>
<description lang="en_US">The height of the image to be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>480</item>
<item>600</item>
<item>768</item>
<item>960</item>
<item>1050</item>
<item>1200</item>
<item>1536</item>
<item>2100</item>
<item>2400</item>
<item>4800</item>
</values>
</parameter>
<parameter id="HeightLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window height.</description>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>0</default_value>
<description lang="en_US">Row coordinate of the upper left corner of the window.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>0</item>
<item>10</item>
<item>50</item>
<item>100</item>
<item>150</item>
<item>200</item>
<item>500</item>
</values>
</parameter>
<parameter id="Width">
<default_type>integer</default_type>
<description lang="en_US">The width of the image to be displayed.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>640</item>
<item>800</item>
<item>1024</item>
<item>1280</item>
<item>1400</item>
<item>1600</item>
<item>2048</item>
<item>2800</item>
<item>3200</item>
<item>6400</item>
</values>
</parameter>
<parameter id="WidthLimit">
<default_type>integer</default_type>
<default_value>-1</default_value>
<description lang="en_US">Limit for the window width.</description>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>300</item>
<item>400</item>
<item>500</item>
<item>600</item>
<item>800</item>
<item>1000</item>
<item>[400,600]</item>
<item>[500,800]</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="dev_update_off">
<interface/>
<body>
<c>* This procedure sets different update settings to 'off'.</c>
<c>* This is useful to get the best performance and reduce overhead.</c>
<c>* </c>
<l>dev_update_pc ('off')</l>
<l>dev_update_var ('off')</l>
<l>dev_update_window ('off')</l>
<l>return ()</l>
</body>
<docu id="dev_update_off">
<abstract lang="en_US">This procedure sets dev_update_pc, dev_update_var and dev_update_window to 'off'.</abstract>
<alternatives>
<item>dev_update_pc</item>
<item>dev_update_var</item>
<item>dev_update_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_update_off ()
* do something
dev_update_on ()</example>
<keywords lang="de_DE">
<item>Aktualisierungsmodus setzen</item>
</keywords>
<keywords lang="en_US">
<item>set update mode</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_update_on</item>
</see_also>
<short lang="de_DE">Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.</short>
<short lang="en_US">Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.</short>
<parameters/>
</docu>
</procedure>
<procedure name="dev_update_on">
<interface/>
<body>
<c>* This procedure sets different update settings to 'on'.</c>
<c>* </c>
<l>dev_update_pc ('on')</l>
<l>dev_update_var ('on')</l>
<l>dev_update_window ('on')</l>
<l>return ()</l>
</body>
<docu id="dev_update_on">
<abstract lang="en_US">This procedure sets dev_update_pc, dev_update_var and dev_update_window to 'on'.</abstract>
<alternatives>
<item>dev_update_pc</item>
<item>dev_update_var</item>
<item>dev_update_window</item>
</alternatives>
<chapters lang="de_DE">
<item>Develop</item>
</chapters>
<chapters lang="en_US">
<item>Develop</item>
</chapters>
<example lang="en_US">dev_update_off ()
* do something
dev_update_on ()</example>
<keywords lang="de_DE">
<item>Aktualisierungsmodus setzen</item>
</keywords>
<keywords lang="en_US">
<item>set update mode</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>dev_update_off</item>
</see_also>
<short lang="de_DE">Switch dev_update_pc, dev_update_var and dev_update_window to 'on'.</short>
<short lang="en_US">Switch dev_update_pc, dev_update_var and dev_update_window to 'on'.</short>
<parameters/>
</docu>
</procedure>
<procedure name="disp_3d_coord_system">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Pose" base_type="ctrl" dimension="0"/>
<par name="CoordAxesLength" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays a 3D coordinate system.</c>
<c>* It needs the procedure gen_arrow_contour_xld.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window where the coordinate system shall be displayed</c>
<c>* CamParam: The camera paramters</c>
<c>* Pose: The pose to be displayed</c>
<c>* CoordAxesLength: The length of the coordinate axes in world coordinates</c>
<c>* </c>
<c>* Check, if Pose is a correct pose tuple.</c>
<l>if (|Pose| != 7)</l>
<l>    return ()</l>
<l>endif</l>
<l>get_cam_par_data (CamParam, 'camera_type', CameraType)</l>
<l>IsTelecentric := strstr(CameraType,'telecentric') != -1</l>
<l>if (Pose[2] == 0.0 and not IsTelecentric)</l>
<c>    * For projective cameras:</c>
<c>    * Poses with Z position zero cannot be projected</c>
<c>    * (that would lead to a division by zero error).</c>
<l>    return ()</l>
<l>endif</l>
<c>* Convert to pose to a transformation matrix</c>
<l>pose_to_hom_mat3d (Pose, TransWorld2Cam)</l>
<c>* Project the world origin into the image</c>
<l>affine_trans_point_3d (TransWorld2Cam, 0, 0, 0, OrigCamX, OrigCamY, OrigCamZ)</l>
<l>project_3d_point (OrigCamX, OrigCamY, OrigCamZ, CamParam, Row0, Column0)</l>
<c>* Project the coordinate axes into the image</c>
<l>affine_trans_point_3d (TransWorld2Cam, CoordAxesLength, 0, 0, X, Y, Z)</l>
<l>project_3d_point (X, Y, Z, CamParam, RowAxX, ColumnAxX)</l>
<l>affine_trans_point_3d (TransWorld2Cam, 0, CoordAxesLength, 0, X, Y, Z)</l>
<l>project_3d_point (X, Y, Z, CamParam, RowAxY, ColumnAxY)</l>
<l>affine_trans_point_3d (TransWorld2Cam, 0, 0, CoordAxesLength, X, Y, Z)</l>
<l>project_3d_point (X, Y, Z, CamParam, RowAxZ, ColumnAxZ)</l>
<c>* </c>
<c>* Generate an XLD contour for each axis</c>
<l>distance_pp ([Row0,Row0,Row0], [Column0,Column0,Column0], [RowAxX,RowAxY,RowAxZ], [ColumnAxX,ColumnAxY,ColumnAxZ], Distance)</l>
<l>HeadLength := int(max([max(Distance) / 12.0,5.0]))</l>
<l>gen_arrow_contour_xld (Arrows, [Row0,Row0,Row0], [Column0,Column0,Column0], [RowAxX,RowAxY,RowAxZ], [ColumnAxX,ColumnAxY,ColumnAxZ], HeadLength, HeadLength)</l>
<c>* </c>
<c>* Display coordinate system</c>
<l>disp_xld (Arrows, WindowHandle)</l>
<c>* </c>
<l>get_rgb (WindowHandle, Red, Green, Blue)</l>
<l>set_rgb (WindowHandle, Red[0], Green[0], Blue[0])</l>
<l>set_tposition (WindowHandle, RowAxX + 3, ColumnAxX + 3)</l>
<l>write_string (WindowHandle, 'X')</l>
<l>set_rgb (WindowHandle, Red[1 % |Red|], Green[1 % |Green|], Blue[1 % |Blue|])</l>
<l>set_tposition (WindowHandle, RowAxY + 3, ColumnAxY + 3)</l>
<l>write_string (WindowHandle, 'Y')</l>
<l>set_rgb (WindowHandle, Red[2 % |Red|], Green[2 % |Green|], Blue[2 % |Blue|])</l>
<l>set_tposition (WindowHandle, RowAxZ + 3, ColumnAxZ + 3)</l>
<l>write_string (WindowHandle, 'Z')</l>
<l>set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>return ()</l>
</body>
<docu id="disp_3d_coord_system">
<abstract lang="en_US">This procedure displays a 3D coordinate system at the given Pose using the camera parameters CamParam in the window WindowHandle. The length of the displayed axes can be specified in world coordinates with the parameter CoordAxesLength. The axes are displayed in the first three currently set colors, which can be checked with get_rgb.
If only a single color is set, this color is used for all three axes.</abstract>
<attention lang="en_US">This procedure needs the procedure gen_arrow_contour_xld.</attention>
<chapters>
<item>Matching-3D</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 640, 480, 'black', WindowHandle)
Pose:=[0,0,2.0,-30,-15,60,0]
gen_cam_par_area_scan_division (0.012, 0, 5e-6, 5e-6, 320, 240, 640, 480, CamParam)
disp_3d_coord_system (WindowHandle, CamParam, Pose, 0.1)</example>
<keywords lang="de_DE">
<item>3D-Koordinatensystem anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display 3D coordinate system</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_set_colored</item>
<item>set_rgb</item>
<item>vector_to_pose</item>
<item>camera_calibration</item>
<item>find_calib_descriptor_model</item>
<item>find_planar_calib_deformable_model</item>
<item>dev_display</item>
<item>find_marks_and_pose</item>
<item>find_shape_model_3d</item>
<item>get_circle_pose</item>
<item>get_rectangle_pose</item>
</predecessor>
<see_also>
<item>create_pose</item>
</see_also>
<short>Display the axes of a 3d coordinate system</short>
<short lang="de_DE">Display the axes of a 3d coordinate system</short>
<short lang="en_US">Display the axes of a 3d coordinate system</short>
<successor>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="CamParam">
<default_type>real</default_type>
<default_value>['area_scan_division',0.012,0.0,5e-6,5e-6,320,240,640,480]</default_value>
<description lang="en_US">Interior camera parameters</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="CoordAxesLength">
<default_type>integer</default_type>
<default_value>0.05</default_value>
<description lang="en_US">The length of the coordinate axes in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.01</item>
<item>0.02</item>
<item>0.05</item>
<item>0.1</item>
<item>0.2</item>
<item>0.5</item>
</values>
</parameter>
<parameter id="Pose">
<default_type>real</default_type>
<default_value>[0.0,0.0,1.0,0.0,0.0,0.0,0]</default_value>
<description lang="en_US">The pose to be displayed</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window where the coordinate system shall be displayed</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_continue_button">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays a 'Continue' text button</c>
<c>* in the lower right corner of the screen.</c>
<c>* It uses the procedure disp_message.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window, where the text shall be displayed</c>
<c>* </c>
<c>* Use the continue message set in the global variable gTerminationButtonLabel.</c>
<c>* If this variable is not defined, set a standard text instead.</c>
<l>global tuple gTerminationButtonLabel</l>
<l>try</l>
<l>    ContinueMessage := gTerminationButtonLabel</l>
<l>catch (Exception)</l>
<l>    ContinueMessage := 'Continue'</l>
<l>endtry</l>
<c>* Display the continue button</c>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>get_string_extents (WindowHandle, ' ' + ContinueMessage + ' ', Ascent, Descent, TextWidth, TextHeight)</l>
<l>disp_text_button (WindowHandle, ContinueMessage, 'window', Height - TextHeight - 22, Width - TextWidth - 12, 'black', '#f28f26')</l>
<l>return ()</l>
</body>
<docu id="disp_continue_button">
<abstract lang="en_US">Displays a continue button at the lower right corner.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Displays a continue button.</short>
<parameters>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window handle in which the button should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_continue_message">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Box" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays 'Press Run (F5) to continue' in the</c>
<c>* lower right corner of the screen.</c>
<c>* It uses the procedure disp_message.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window, where the text shall be displayed</c>
<c>* Color: defines the text color.</c>
<c>*    If set to '' or 'auto', the currently set color is used.</c>
<c>* Box: If set to 'true', the text is displayed in a box.</c>
<c>* </c>
<c>* Convert the parameter Box to generic parameters.</c>
<l>GenParamName := []</l>
<l>GenParamValue := []</l>
<l>if (|Box| &gt; 0)</l>
<l>    if (Box[0] == 'false')</l>
<c>        * Display no box</c>
<l>        GenParamName := [GenParamName,'box']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[0] != 'true')</l>
<c>        * Set a color other than the default.</c>
<l>        GenParamName := [GenParamName,'box_color']</l>
<l>        GenParamValue := [GenParamValue,Box[0]]</l>
<l>    endif</l>
<l>endif</l>
<l>if (|Box| &gt; 1)</l>
<l>    if (Box[1] == 'false')</l>
<c>        * Display no shadow.</c>
<l>        GenParamName := [GenParamName,'shadow']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[1] != 'true')</l>
<c>        * Set a shadow color other than the default.</c>
<l>        GenParamName := [GenParamName,'shadow_color']</l>
<l>        GenParamValue := [GenParamValue,Box[1]]</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>if (Color == '')</l>
<c>    * disp_text does not accept an empty string for Color.</c>
<l>    Color := []</l>
<l>endif</l>
<c>* </c>
<c>* Display the message.</c>
<l>ContinueMessage := 'Press Run (F5) to continue'</l>
<l>disp_text (WindowHandle, ContinueMessage, 'window', 'bottom', 'right', Color, GenParamName, GenParamValue)</l>
<l>return ()</l>
</body>
<docu id="disp_continue_message">
<abstract lang="en_US">This procedure displays 'Click 'Run' to continue' in a given Color in the lower right corner of the screen.
If the parameter Box is set to 'true', the text is written within a white box, which is useful on irregular background.</abstract>
<alternatives>
<item>disp_message</item>
<item>write_string</item>
</alternatives>
<attention lang="en_US">This procedure uses the procedure disp_message.
</attention>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
for Index := 1 to 5 by 1
    disp_message (WindowHandle, 'Step '+Index, 'window', 30*Index, -1, 'black', 'true')
    disp_continue_message (WindowHandle, 'black', 'true')
    stop ()
endfor
</example>
<keywords lang="de_DE">
<item>Fortsetzungs-Nachricht anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display continue message</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>disp_message</item>
<item>set_display_font</item>
<item>write_string</item>
<item>dev_display</item>
<item>disp_obj</item>
<item>disp_image</item>
</predecessor>
<see_also>
<item>disp_message</item>
<item>write_string</item>
</see_also>
<short>This procedure displays 'Press 'Run' to continue' in the lower right corner of the screen.</short>
<short lang="de_DE">This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen.</short>
<short lang="en_US">This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen.</short>
<successor>
<item>stop</item>
</successor>
<parameters>
<parameter id="Box">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', the text is written within a white box.</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'black'</default_value>
<description lang="en_US">Defines the text color. If set to '' or 'auto', the currently set color is used.
</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'black'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The handle of the window, where the text shall be displayed.
</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_end_of_program_message">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Box" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays 'End of program' in the</c>
<c>* lower right corner of the screen.</c>
<c>* It uses the procedure disp_message.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The window, where the text shall be displayed</c>
<c>* Color: defines the text color.</c>
<c>*    If set to '' or 'auto', the currently set color is used.</c>
<c>* Box: If set to 'true', the text is displayed in a box.</c>
<c>* </c>
<c>* Convert the parameter Box to generic parameters.</c>
<l>GenParamName := []</l>
<l>GenParamValue := []</l>
<l>if (|Box| &gt; 0)</l>
<l>    if (Box[0] == 'false')</l>
<c>        * Display no box</c>
<l>        GenParamName := [GenParamName,'box']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[0] != 'true')</l>
<c>        * Set a color other than the default.</c>
<l>        GenParamName := [GenParamName,'box_color']</l>
<l>        GenParamValue := [GenParamValue,Box[0]]</l>
<l>    endif</l>
<l>endif</l>
<l>if (|Box| &gt; 1)</l>
<l>    if (Box[1] == 'false')</l>
<c>        * Display no shadow.</c>
<l>        GenParamName := [GenParamName,'shadow']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[1] != 'true')</l>
<c>        * Set a shadow color other than the default.</c>
<l>        GenParamName := [GenParamName,'shadow_color']</l>
<l>        GenParamValue := [GenParamValue,Box[1]]</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<l>if (Color == '')</l>
<c>    * disp_text does not accept an empty string for Color.</c>
<l>    Color := []</l>
<l>endif</l>
<c>* </c>
<c>* Display the message.</c>
<l>EndMessage := '      End of program      '</l>
<l>disp_text (WindowHandle, EndMessage, 'window', 'bottom', 'right', Color, GenParamName, GenParamValue)</l>
<l>return ()</l>
</body>
<docu id="disp_end_of_program_message">
<abstract lang="en_US">This procedure displays 'End of program' in a given Color in the lower right corner of the screen.
If the parameter Box is set to 'true', the text is written within a white box, which is useful on irregular background.</abstract>
<alternatives>
<item>disp_continue_message</item>
<item>disp_message</item>
<item>write_string</item>
</alternatives>
<attention lang="en_US">This procedure uses the procedure disp_message.
</attention>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
for Index := 1 to 5 by 1
    disp_message (WindowHandle, 'Step '+Index, 'window', 30*Index, -1, 'black', 'true')
    disp_continue_message (WindowHandle, 'black', 'true')
    stop ()
endfor
disp_end_of_program_message (WindowHandle, 'black', 'true')</example>
<keywords lang="en_US">
<item>display end of program message</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>disp_continue_message</item>
<item>disp_message</item>
<item>set_display_font</item>
<item>write_string</item>
<item>dev_display</item>
<item>disp_obj</item>
<item>disp_image</item>
</predecessor>
<see_also>
<item>disp_message</item>
<item>write_string</item>
</see_also>
<short>This procedure displays 'Press 'Run' to continue' in the lower right corner of the screen.</short>
<short lang="de_DE">This procedure displays 'End of program' in the lower right corner of the screen.</short>
<short lang="en_US">This procedure displays 'End of program' in the lower right corner of the screen.</short>
<successor>
<item>stop</item>
</successor>
<parameters>
<parameter id="Box">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', the text is written within a white box.</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'black'</default_value>
<description lang="en_US">Defines the text color. If set to '' or 'auto', the currently set color is used.
</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'black'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The handle of the window, where the text shall be displayed.
</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_message">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="String" base_type="ctrl" dimension="0"/>
<par name="CoordSystem" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="Box" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays text in a graphics window.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The WindowHandle of the graphics window, where</c>
<c>*    the message should be displayed</c>
<c>* String: A tuple of strings containing the text message to be displayed</c>
<c>* CoordSystem: If set to 'window', the text position is given</c>
<c>*    with respect to the window coordinate system.</c>
<c>*    If set to 'image', image coordinates are used.</c>
<c>*    (This may be useful in zoomed images.)</c>
<c>* Row: The row coordinate of the desired text position</c>
<c>*    A tuple of values is allowed to display text at different</c>
<c>*    positions.</c>
<c>* Column: The column coordinate of the desired text position</c>
<c>*    A tuple of values is allowed to display text at different</c>
<c>*    positions.</c>
<c>* Color: defines the color of the text as string.</c>
<c>*    If set to [], '' or 'auto' the currently set color is used.</c>
<c>*    If a tuple of strings is passed, the colors are used cyclically...</c>
<c>*    - if |Row| == |Column| == 1: for each new textline</c>
<c>*    = else for each text position.</c>
<c>* Box: If Box[0] is set to 'true', the text is written within an orange box.</c>
<c>*      If set to' false', no box is displayed.</c>
<c>*      If set to a color string (e.g. 'white', '#FF00CC', etc.),</c>
<c>*        the text is written in a box of that color.</c>
<c>*      An optional second value for Box (Box[1]) controls if a shadow is displayed:</c>
<c>*        'true' -&gt; display a shadow in a default color</c>
<c>*        'false' -&gt; display no shadow</c>
<c>*        otherwise -&gt; use given string as color string for the shadow color</c>
<c>* </c>
<c>* It is possible to display multiple text strings in a single call.</c>
<c>* In this case, some restrictions apply:</c>
<c>* - Multiple text positions can be defined by specifying a tuple</c>
<c>*   with multiple Row and/or Column coordinates, i.e.:</c>
<c>*   - |Row| == n, |Column| == n</c>
<c>*   - |Row| == n, |Column| == 1</c>
<c>*   - |Row| == 1, |Column| == n</c>
<c>* - If |Row| == |Column| == 1,</c>
<c>*   each element of String is display in a new textline.</c>
<c>* - If multiple positions or specified, the number of Strings</c>
<c>*   must match the number of positions, i.e.:</c>
<c>*   - Either |String| == n (each string is displayed at the</c>
<c>*                           corresponding position),</c>
<c>*   - or     |String| == 1 (The string is displayed n times).</c>
<c>* </c>
<c>* </c>
<c>* Convert the parameters for disp_text.</c>
<l>if (Row == [] or Column == [])</l>
<l>    return ()</l>
<l>endif</l>
<l>if (Row == -1)</l>
<l>    Row := 12</l>
<l>endif</l>
<l>if (Column == -1)</l>
<l>    Column := 12</l>
<l>endif</l>
<c>* </c>
<c>* Convert the parameter Box to generic parameters.</c>
<l>GenParamName := []</l>
<l>GenParamValue := []</l>
<l>if (|Box| &gt; 0)</l>
<l>    if (Box[0] == 'false')</l>
<c>        * Display no box</c>
<l>        GenParamName := [GenParamName,'box']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[0] != 'true')</l>
<c>        * Set a color other than the default.</c>
<l>        GenParamName := [GenParamName,'box_color']</l>
<l>        GenParamValue := [GenParamValue,Box[0]]</l>
<l>    endif</l>
<l>endif</l>
<l>if (|Box| &gt; 1)</l>
<l>    if (Box[1] == 'false')</l>
<c>        * Display no shadow.</c>
<l>        GenParamName := [GenParamName,'shadow']</l>
<l>        GenParamValue := [GenParamValue,'false']</l>
<l>    elseif (Box[1] != 'true')</l>
<c>        * Set a shadow color other than the default.</c>
<l>        GenParamName := [GenParamName,'shadow_color']</l>
<l>        GenParamValue := [GenParamValue,Box[1]]</l>
<l>    endif</l>
<l>endif</l>
<c>* Restore default CoordSystem behavior.</c>
<l>if (CoordSystem != 'window')</l>
<l>    CoordSystem := 'image'</l>
<l>endif</l>
<c>* </c>
<l>if (Color == '')</l>
<c>    * disp_text does not accept an empty string for Color.</c>
<l>    Color := []</l>
<l>endif</l>
<c>* </c>
<l>disp_text (WindowHandle, String, CoordSystem, Row, Column, Color, GenParamName, GenParamValue)</l>
<l>return ()</l>
</body>
<docu id="disp_message">
<abstract lang="en_US">This procedure displays text in a graphics window WindowHandle at the position (Row,Column).

If only a single position is defined, one text line is displayed for each element of String. Also, '\n' will be interpreted as a newline character, i.e. a line break is performed.

If multiple positions are defined, only a single string or one string for each position is allowed in String. In this case, line breaks have to be forced with '\n'.

The position of the text may be specified in window coordinates (CoordSystem = 'window') or in image coordinates (CoordSystem = 'image'), which is useful when using zoomed images.

In addition to supplying (Row, Column) coordinates, it is also possible to pass predefined values to Row and Column to display the text at a fixed position in the window (only if CoordSystem = 'window').

The parameter Color also accepts tuples of values. In that case, the specified colors are used cyclically for every new text position or for every new textline if a single position is used.

Box:
If set to 'true', the text is written within an orange box.
If set to' false', no box is displayed.
If set to a color string (e.g. 'white', '#FF00CC', etc.), the text is written in a box of that color.
An optional second value for Box controls if a shadow is displayed. Possible values are 'true', 'false', or a valid color string.




</abstract>
<alternatives>
<item>disp_text</item>
<item>write_string</item>
<item>disp_continue_message</item>
</alternatives>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
disp_message (WindowHandle, ['Hello','world!'], 'window', 12, 12, ['black','blue'], 'true')
disp_message (WindowHandle, ['Hello','world!'], 'window', 12, 120, 'white', ['blue','false'])
Angle := [0,90,180,270]
Row := 200 - sin(rad(Angle))*100
Column := 250 + cos(rad(Angle))*100
Color := ['green','red','red','red']
disp_message (WindowHandle, Angle+' deg', 'window', Row, Column, Color, 'false')
gen_cross_contour_xld (Cross, 200, 250, 200, 0)
</example>
<keywords lang="de_DE">
<item>Meldung anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display message</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
<item>set_display_font</item>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
<item>dev_display</item>
<item>disp_obj</item>
<item>disp_image</item>
</predecessor>
<see_also>
<item>write_string</item>
<item>disp_continue_message</item>
</see_also>
<short>This procedure writes a text message.</short>
<short lang="de_DE">This procedure writes a text message.</short>
<short lang="en_US">This procedure writes a text message.</short>
<successor>
<item>disp_continue_message</item>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="Box">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', the text is written within an orange box.
If set to' false', no box is displayed.
If set to a color string (e.g. 'white', '#FF00CC', etc.), the text is written in a box of that color. Optionally, a second value controls the appearance of a box shadow.</description>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
<item>'white'</item>
<item>'red'</item>
<item>'forest green'</item>
<item>'black'</item>
<item>'blue'</item>
</value_list>
</parameter>
<parameter id="Color">
<default_type>string</default_type>
<default_value>'black'</default_value>
<description lang="en_US">Defines the color of the text as string. If set to [], or '' the currently set color is used. If a tuple of strings is passed, the colors are used cyclically for each new position or textline.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>''</item>
<item>'black'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>12</default_value>
<description lang="en_US">The horizontal text alignment or the column coordinate of the desired text position. -1 is mapped to 12.</description>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>10</item>
<item>12</item>
<item>20</item>
<item>30</item>
<item>'center'</item>
<item>'left'</item>
<item>'right'</item>
</values>
</parameter>
<parameter id="CoordSystem">
<default_type>string</default_type>
<default_value>'window'</default_value>
<description lang="en_US">If set to 'window', the text position is given with respect to the window coordinate system. If set to 'image', image coordinates are used (This may be useful in zoomed images).</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'window'</item>
<item>'image'</item>
</value_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>12</default_value>
<description lang="en_US">The vertical text alignment or the row coordinate of the desired text position. -1 is mapped to 12.</description>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>10</item>
<item>12</item>
<item>20</item>
<item>30</item>
<item>'bottom'</item>
<item>'center'</item>
<item>'top'</item>
</values>
</parameter>
<parameter id="String">
<default_type>string</default_type>
<description lang="en_US">A tuple of strings containing the text message to be displayed. Each value of the tuple will be displayed in a single line.
</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the graphics window, where the message should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_object_model_3d_safe">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Pose" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>dev_get_preferences ('suppress_handled_exceptions_dlg', SuppressExceptDlg)</l>
<l>dev_set_preferences ('suppress_handled_exceptions_dlg', 'true')</l>
<l>try</l>
<l>    disp_object_model_3d (WindowHandle, ObjectModel3D, CamParam, Pose, GenParamName, GenParamValue)</l>
<l>catch (Exception)</l>
<c>    * Read and check the parameter PoseIn for each object</c>
<l>    get_object_models_center (ObjectModel3D, Center)</l>
<l>    CPLength := |CamParam|</l>
<l>    get_window_extents (WindowHandle, RowNotUsed, ColumnNotUsed, Width, Height)</l>
<l>    if (CPLength == 0)</l>
<l>        gen_cam_par_area_scan_division (0.06, 0, 8.5e-6, 8.5e-6, Width / 2, Height / 2, Width, Height, CamParam)</l>
<l>    else</l>
<l>        get_cam_par_data (CamParam, ['sx','sy','cx','cy','image_width','image_height'], CamParamValue)</l>
<l>        CamWidth := real(CamParamValue[4])</l>
<l>        CamHeight := real(CamParamValue[5])</l>
<l>        Scale := min([Width / CamWidth,Height / CamHeight])</l>
<l>        set_cam_par_data (CamParam, 'sx', CamParamValue[0] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'sy', CamParamValue[1] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cx', CamParamValue[2] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cy', CamParamValue[3] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_width', int(CamParamValue[4] * Scale), CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_height', int(CamParamValue[5] * Scale), CamParam)</l>
<l>    endif</l>
<l>    NumModels := |ObjectModel3D|</l>
<l>    if (|Pose| == 0)</l>
<c>        * If no pose was specified by the caller, automatically calculate</c>
<c>        * a pose that is appropriate for the visualization.</c>
<c>        * Set the initial model reference pose. The orientation is parallel</c>
<c>        * to the object coordinate system, the position is at the center</c>
<c>        * of gravity of all models.</c>
<l>        create_pose (-Center[0], -Center[1], -Center[2], 0, 0, 0, 'Rp+T', 'gba', 'point', Pose)</l>
<l>        determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, Pose, PoseEstimated)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseEstimated[Sequence % 7]</l>
<l>    elseif (|Pose| == 7)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := Pose[Sequence % 7]</l>
<l>    else</l>
<l>        if (|Pose| != |ObjectModel3D| * 7)</l>
<c>            * Error: Wrong number of values of input control parameter 'PoseIn'</c>
<l>            stop ()</l>
<l>        else</l>
<l>            Poses := Pose</l>
<l>        endif</l>
<l>    endif</l>
<l>    tuple_find (GenParamName, 'disp_background', Indices)</l>
<l>    if (Indices &gt; 0)</l>
<l>        if (GenParamValue[Indices] == 'true')</l>
<c>            * display background do not clear background</c>
<l>        else</l>
<l>            dev_set_window (WindowHandle)</l>
<l>            dev_clear_window ()</l>
<l>        endif</l>
<l>    else</l>
<c>        * No indication of  'disp_background' clear window</c>
<l>        dev_set_window (WindowHandle)</l>
<l>        dev_clear_window ()</l>
<l>    endif</l>
<l>    disp_object_model_no_opengl (ModelContours, ObjectModel3D, GenParamName, GenParamValue, WindowHandle, CamParam, Poses)</l>
<l>endtry</l>
<l>dev_set_preferences ('suppress_handled_exceptions_dlg', SuppressExceptDlg)</l>
<l>return ()</l>
</body>
<docu id="disp_object_model_3d_safe">
<abstract lang="en_US">This procedure calls disp_object_model_3d and a fallback solution if there is no OpenGL Available.

See disp_object_model_3d for documentation.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">This procedure calls disp_object_model_3d and a fallback solution if there is no OpenGL Available.</short>
<parameters>
<parameter id="CamParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'alpha'</item>
<item>'attribute'</item>
<item>'color'</item>
<item>'colored'</item>
<item>'depth_persistence'</item>
<item>'disp_background'</item>
<item>'disp_lines'</item>
<item>'disp_pose'</item>
<item>'light_position'</item>
<item>'line_color'</item>
<item>'object_index_persistence'</item>
<item>'point_size'</item>
<item>'quality'</item>
<item>'intensity'</item>
<item>'intensity_red'</item>
<item>'intensity_green'</item>
<item>'intensity_blue'</item>
<item>'lut'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'true'</item>
<item>'false'</item>
<item>'coord_x'</item>
<item>'coord_y'</item>
<item>'coord_z'</item>
<item>'normal_x'</item>
<item>'normal_y'</item>
<item>'normal_z'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'auto'</item>
<item>'faces'</item>
<item>'primitive'</item>
<item>'points'</item>
<item>'lines'</item>
</values>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Pose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<multivalue>optional</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">See disp_object_model_3d for documentation.</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_object_model_no_opengl">
<interface>
<oo>
<par name="ModelContours" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="PosesOut" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure allows to use project_object_model_3d to simulate a disp_object_model_3d</c>
<c>* call for small objects. Large objects are sampled down to display.</c>
<l>Idx := find(GenParamName,'point_size')</l>
<l>if (|Idx| and Idx != -1)</l>
<l>    CustomParamName := 'point_size'</l>
<l>    CustomParamValue := GenParamValue[Idx]</l>
<l>    if (CustomParamValue == 1)</l>
<l>        CustomParamValue := 0</l>
<l>    endif</l>
<l>else</l>
<l>    CustomParamName := []</l>
<l>    CustomParamValue := []</l>
<l>endif</l>
<l>get_font (WindowHandleBuffer, Font)</l>
<l>tuple_find (GenParamName, 'disp_background', IndicesDispBackGround)</l>
<l>if (IndicesDispBackGround != -1)</l>
<l>    tuple_find (GenParamName[IndicesDispBackGround], 'false', Indices)</l>
<l>    if (Indices != -1)</l>
<l>        clear_window (WindowHandleBuffer)</l>
<l>    endif</l>
<l>endif</l>
<l>set_display_font (WindowHandleBuffer, 11, 'mono', 'false', 'false')</l>
<l>get_cam_par_data (CamParam, 'image_width', ImageWidth)</l>
<l>disp_message (WindowHandleBuffer, 'OpenGL missing!', 'image', 5, ImageWidth - 130, 'red', 'false')</l>
<l>set_font (WindowHandleBuffer, Font)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_polygons', HasPolygons)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_triangles', HasTri)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_points', HasPoints)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_lines', HasLines)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'num_points', NumPoints)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'has_primitive_data', IsPrimitive)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'center', Center)</l>
<l>get_object_model_3d_params (ObjectModel3DID, 'diameter', Diameter)</l>
<l>get_system ('opengl_hidden_surface_removal_enable', OpenGlHiddenSurface)</l>
<l>set_system ('opengl_hidden_surface_removal_enable', 'false')</l>
<c>* Sort the objects by inverse z</c>
<l>CenterX := Center[[0:3:|Center| - 1]]</l>
<l>CenterY := Center[[0:3:|Center| - 1] + 1]</l>
<l>CenterZ := Center[[0:3:|Center| - 1] + 2]</l>
<l>PosObjectsZ := []</l>
<l>if (|PosesOut| &gt; 7)</l>
<l>    for I := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>        Pose := PosesOut[I * 7:I * 7 + 6]</l>
<l>        pose_to_hom_mat3d (Pose, HomMat3DObj)</l>
<l>        affine_trans_point_3d (HomMat3DObj, CenterX[I], CenterY[I], CenterZ[I], PosObjCenterX, PosObjCenterY, PosObjCenterZ)</l>
<l>        PosObjectsZ := [PosObjectsZ,PosObjCenterZ]</l>
<l>    endfor</l>
<l>else</l>
<l>    Pose := PosesOut[0:6]</l>
<l>    pose_to_hom_mat3d (Pose, HomMat3DObj)</l>
<l>    affine_trans_point_3d (HomMat3DObj, CenterX, CenterY, CenterZ, PosObjectsX, PosObjectsY, PosObjectsZ)</l>
<l>endif</l>
<l>Idx := inverse(sort_index(PosObjectsZ))</l>
<l>Color := 'white'</l>
<l>set_color (WindowHandleBuffer, Color)</l>
<l>if (|GenParamName| &gt; 0)</l>
<l>    tuple_find (GenParamName, 'colored', Indices1)</l>
<l>    tuple_find (GenParamName, 'color', Indices2)</l>
<l>    if (Indices1[0] != -1)</l>
<l>        if (GenParamValue[Indices1[0]] == 3)</l>
<l>            Color := ['red','green','blue']</l>
<l>        elseif (GenParamValue[Indices1[0]] == 6)</l>
<l>            Color := ['red','green','blue','cyan','magenta','yellow']</l>
<l>        elseif (GenParamValue[Indices1[0]] == 12)</l>
<l>            Color := ['red','green','blue','cyan','magenta','yellow','coral','slate blue','spring green','orange red','pink','gold']</l>
<l>        endif</l>
<l>    elseif (Indices2[0] != -1)</l>
<l>        Color := GenParamValue[Indices2[0]]</l>
<l>    endif</l>
<l>endif</l>
<l>for J := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>    I := Idx[J]</l>
<l>    if (HasPolygons[I] == 'true' or HasTri[I] == 'true' or HasPoints[I] == 'true' or HasLines[I] == 'true')</l>
<l>        if (|GenParamName| &gt; 0)</l>
<l>            tuple_find (GenParamName, 'color_' + I, Indices3)</l>
<l>            if (Indices3[0] != -1)</l>
<l>                set_color (WindowHandleBuffer, GenParamValue[Indices3[0]])</l>
<l>            else</l>
<l>                set_color (WindowHandleBuffer, Color[I % |Color|])</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (|PosesOut| &gt;= I * 7 + 6)</l>
<l>            Pose := PosesOut[I * 7:I * 7 + 6]</l>
<l>        else</l>
<l>            Pose := PosesOut[0:6]</l>
<l>        endif</l>
<l>        if (NumPoints[I] &lt; 10000)</l>
<l>            project_object_model_3d (ModelContours, ObjectModel3DID[I], CamParam, Pose, CustomParamName, CustomParamValue)</l>
<l>            disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>        else</l>
<l>            pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>            sample_object_model_3d (ObjectModel3DID[I], 'fast', 0.01 * Diameter[I], [], [], SampledObjectModel3D)</l>
<l>            project_object_model_3d (ModelContours, SampledObjectModel3D, CamParam, Pose, 'point_size', 1)</l>
<l>            get_object_model_3d_params (SampledObjectModel3D, 'point_coord_x', X)</l>
<l>            get_object_model_3d_params (SampledObjectModel3D, 'point_coord_y', Y)</l>
<l>            get_object_model_3d_params (SampledObjectModel3D, 'point_coord_z', Z)</l>
<l>            pose_to_hom_mat3d (Pose, HomMat3D1)</l>
<l>            affine_trans_point_3d (HomMat3D1, X, Y, Z, Qx, Qy, Qz)</l>
<l>            project_3d_point (Qx, Qy, Qz, CamParam, Row, Column)</l>
<l>            disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>            clear_object_model_3d (SampledObjectModel3D)</l>
<l>        endif</l>
<l>    else</l>
<l>        if (|GenParamName| &gt; 0)</l>
<l>            tuple_find (GenParamName, 'color_' + I, Indices3)</l>
<l>            if (Indices3[0] != -1)</l>
<l>                set_color (WindowHandleBuffer, GenParamValue[Indices3[0]])</l>
<l>            else</l>
<l>                set_color (WindowHandleBuffer, Color[I % |Color|])</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (|PosesOut| &gt;= I * 7 + 6)</l>
<l>            Pose := PosesOut[I * 7:I * 7 + 6]</l>
<l>        else</l>
<l>            Pose := PosesOut[0:6]</l>
<l>        endif</l>
<l>        if (IsPrimitive[I] == 'true')</l>
<l>            try</l>
<l>                convex_hull_object_model_3d (ObjectModel3DID[I], ObjectModel3DConvexHull)</l>
<l>                if (NumPoints[I] &lt; 10000)</l>
<l>                    project_object_model_3d (ModelContours, ObjectModel3DConvexHull, CamParam, Pose, CustomParamName, CustomParamValue)</l>
<l>                    disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>                else</l>
<l>                    pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>                    sample_object_model_3d (ObjectModel3DConvexHull, 'fast', 0.01 * Diameter[I], [], [], SampledObjectModel3D)</l>
<l>                    project_object_model_3d (ModelContours, SampledObjectModel3D, CamParam, Pose, 'point_size', 1)</l>
<l>                    disp_obj (ModelContours, WindowHandleBuffer)</l>
<l>                    clear_object_model_3d (SampledObjectModel3D)</l>
<l>                endif</l>
<l>                clear_object_model_3d (ObjectModel3DConvexHull)</l>
<l>            catch (Exception)</l>
<l>            endtry</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>set_system ('opengl_hidden_surface_removal_enable', OpenGlHiddenSurface)</l>
<l>return ()</l>
</body>
<docu id="disp_object_model_no_opengl">
<abstract lang="en_US">Can replace disp_object_model_3d if there is no OpenGL available.
Projects a Modelcontour and displays this instead of the OpenGL view.

If you have no correct pose or no camera parameters use the disp_object_model_3d_safe instead. For the supported generic parameters  are all which are supported by project_object_model_3d. Additionally, it supports the parameter color_i with i in [0,1,2,...].



</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Can replace disp_object_model_3d if there is no OpenGL available.</short>
<parameters>
<parameter id="CamParam">
<sem_type>calib_data</sem_type>
</parameter>
<parameter id="GenParamName">
<description lang="en_US">Supports similar parameters as disp_object_model_3d.</description>
<sem_type>any</sem_type>
</parameter>
<parameter id="GenParamValue">
<description lang="en_US">Supports similar parameters as disp_object_model_3d.</description>
<sem_type>any</sem_type>
</parameter>
<parameter id="ModelContours">
<description lang="en_US">Contour of the last object model,</description>
<multivalue>false</multivalue>
<sem_type>xld_cont</sem_type>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<description lang="en_US">The 3D object model to display</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PosesOut">
<sem_type>pose</sem_type>
</parameter>
<parameter id="WindowHandleBuffer">
<default_type>integer</default_type>
<description lang="en_US">Window Handle</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_text_button">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="String" base_type="ctrl" dimension="0"/>
<par name="CoordSystem" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="TextColor" base_type="ctrl" dimension="0"/>
<par name="ButtonColor" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure displays text in a graphics window.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The WindowHandle of the graphics window, where</c>
<c>*    the message should be displayed</c>
<c>* String: A tuple of strings containing the text message to be displayed</c>
<c>* CoordSystem: If set to 'window', the text position is given</c>
<c>*    with respect to the window coordinate system.</c>
<c>*    If set to 'image', image coordinates are used.</c>
<c>*    (This may be useful in zoomed images.)</c>
<c>* Row: The row coordinate of the desired text position</c>
<c>*    If set to -1, a default value of 12 is used.</c>
<c>* Column: The column coordinate of the desired text position</c>
<c>*    If set to -1, a default value of 12 is used.</c>
<c>* Color: defines the color of the text as string.</c>
<c>*    If set to [], '' or 'auto' the currently set color is used.</c>
<c>*    If a tuple of strings is passed, the colors are used cyclically</c>
<c>*    for each new textline.</c>
<c>* ButtonColor: Must be set to a color string (e.g. 'white', '#FF00CC', etc.).</c>
<c>*              The text is written in a box of that color.</c>
<c>* </c>
<c>* Prepare window.</c>
<l>get_rgb (WindowHandle, Red, Green, Blue)</l>
<l>get_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>get_window_extents (WindowHandle, RowWin, ColumnWin, WidthWin, HeightWin)</l>
<l>set_part (WindowHandle, 0, 0, HeightWin - 1, WidthWin - 1)</l>
<c>* </c>
<c>* Default settings.</c>
<l>if (Row == -1)</l>
<l>    Row := 12</l>
<l>endif</l>
<l>if (Column == -1)</l>
<l>    Column := 12</l>
<l>endif</l>
<l>if (TextColor == [])</l>
<l>    TextColor := ''</l>
<l>endif</l>
<c>* </c>
<l>try</l>
<l>    color_string_to_rgb (ButtonColor, RGB)</l>
<l>catch (Exception)</l>
<l>    Exception := 'Wrong value of control parameter ButtonColor (must be a valid color string)'</l>
<l>    throw (Exception)</l>
<l>endtry</l>
<l>Fac := 0.4</l>
<l>RGBL := RGB + int((255.0 - RGB) * Fac + 0.5)</l>
<l>RGBD := RGB - int(RGB * Fac + 0.5)</l>
<l>ButtonColorBorderL := '#' + sum('' + RGBL$'02x')</l>
<l>ButtonColorBorderD := '#' + sum('' + RGBD$'02x')</l>
<c>* </c>
<l>String := split('' + String + '','\n')</l>
<c>* </c>
<c>* Estimate extentions of text depending on font size.</c>
<l>get_font_extents (WindowHandle, MaxAscent, MaxDescent, MaxWidth, MaxHeight)</l>
<l>if (CoordSystem == 'window')</l>
<l>    R1 := Row</l>
<l>    C1 := Column</l>
<l>else</l>
<c>    * Transform image to window coordinates.</c>
<l>    FactorRow := 1. * HeightWin / (Row2Part - Row1Part + 1)</l>
<l>    FactorColumn := 1. * WidthWin / (Column2Part - Column1Part + 1)</l>
<l>    R1 := (Row - Row1Part + 0.5) * FactorRow</l>
<l>    C1 := (Column - Column1Part + 0.5) * FactorColumn</l>
<l>endif</l>
<c>* </c>
<c>* Display text box depending on text size.</c>
<c>* </c>
<c>* Calculate box extents.</c>
<l>String := ' ' + String + ' '</l>
<l>Width := []</l>
<l>for Index := 0 to |String| - 1 by 1</l>
<l>    get_string_extents (WindowHandle, String[Index], Ascent, Descent, W, H)</l>
<l>    Width := [Width,W]</l>
<l>endfor</l>
<l>FrameHeight := MaxHeight * |String|</l>
<l>FrameWidth := max([0,Width])</l>
<l>R2 := R1 + FrameHeight</l>
<l>C2 := C1 + FrameWidth</l>
<c>* Display rectangles.</c>
<l>get_system ('clip_region', ClipRegion)</l>
<l>set_system ('clip_region', 'false')</l>
<l>get_draw (WindowHandle, DrawMode)</l>
<l>set_draw (WindowHandle, 'fill')</l>
<l>BorderWidth := 2</l>
<l>gen_region_polygon_filled (UpperLeft, [R1 - BorderWidth,R1 - BorderWidth,R1,R2,R2 + BorderWidth], [C1 - BorderWidth,C2 + BorderWidth,C2,C1,C1 - BorderWidth])</l>
<l>gen_region_polygon_filled (LowerRight, [R2 + BorderWidth,R1 - BorderWidth,R1,R2,R2 + BorderWidth], [C2 + BorderWidth,C2 + BorderWidth,C2,C1,C1 - BorderWidth])</l>
<l>gen_rectangle1 (Rectangle, R1, C1, R2, C2)</l>
<l>set_color (WindowHandle, ButtonColorBorderL)</l>
<l>disp_obj (UpperLeft, WindowHandle)</l>
<l>set_color (WindowHandle, ButtonColorBorderD)</l>
<l>disp_obj (LowerRight, WindowHandle)</l>
<l>set_color (WindowHandle, ButtonColor)</l>
<l>disp_obj (Rectangle, WindowHandle)</l>
<l>set_draw (WindowHandle, DrawMode)</l>
<l>set_system ('clip_region', ClipRegion)</l>
<c>* Write text.</c>
<l>for Index := 0 to |String| - 1 by 1</l>
<l>    CurrentColor := TextColor[Index % |TextColor|]</l>
<l>    if (CurrentColor != '' and CurrentColor != 'auto')</l>
<l>        set_color (WindowHandle, CurrentColor)</l>
<l>    else</l>
<l>        set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>    endif</l>
<l>    Row := R1 + MaxHeight * Index</l>
<l>    disp_text (WindowHandle, String[Index], 'window', Row, C1, CurrentColor, 'box', 'false')</l>
<l>endfor</l>
<c>* Reset changed window settings.</c>
<l>set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>set_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)</l>
<l>return ()</l>
</body>
<docu id="disp_text_button">
<abstract lang="en_US">This procedure displays text in a graphics window WindowHandle at the position (Row,Column).
If String is a tuple, one text line is displayed for each entry. Also, '\n' will be interpreted as a newline character, i.e. a line break is performed. Empty strings (or empty parts before or after a newline) are ignored. To write empty lines, use a whitespace character.

The position of the text may be specified in window coordinates (CoordSystem = 'window') or in image coordinates (CoordSystem = 'image'), which is useful when using zoomed images.

The parameter Color also accepts tuples of values. In that case, the specified colors are used cyclically for every new textline.

If the parameter Box is set to 'true', the text is written within a white box, which is useful on irregular background.

</abstract>
<alternatives>
<item>write_string</item>
<item>disp_continue_message</item>
</alternatives>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
set_display_font (WindowHandle, 16, 'mono', 'true', 'false')
disp_message (WindowHandle, ['Hello','world!'], 'window', -1, -1, ['black','blue'], 'true')
</example>
<keywords lang="de_DE">
<item>Meldung anzeigen</item>
</keywords>
<keywords lang="en_US">
<item>display message</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
<item>set_display_font</item>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
<item>dev_display</item>
<item>disp_obj</item>
<item>disp_image</item>
</predecessor>
<see_also>
<item>write_string</item>
<item>disp_continue_message</item>
</see_also>
<short>This procedure writes a text message.</short>
<short lang="de_DE">This procedure writes a text message.</short>
<short lang="en_US">This procedure writes a text message.</short>
<successor>
<item>disp_continue_message</item>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="ButtonColor">
<default_type>string</default_type>
<default_value>'gray'</default_value>
<description lang="en_US">If set to 'true', the text is written within a white box.</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'gray'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="Column">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The column coordinate of the desired text position. If set to -1, a default value of 12 is used.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[10,12,20,30,40,50,60,70,80,90,100,200,300,400,500,1000]</item>
</values>
</parameter>
<parameter id="CoordSystem">
<default_type>string</default_type>
<default_value>'window'</default_value>
<description lang="en_US">If set to 'window', the text position is given with respect to the window coordinate system. If set to 'image', image coordinates are used (This may be useful in zoomed images).</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'window'</item>
<item>'image'</item>
</value_list>
</parameter>
<parameter id="Row">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The row coordinate of the desired text position. If set to -1, a default value of 12 is used.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[10,12,20,30,40,50,60,70,80,90,100,200,300,400,500,1000]</item>
</values>
</parameter>
<parameter id="String">
<default_type>string</default_type>
<default_value>'Text'</default_value>
<description lang="en_US">A tuple of strings containing the text message to be displayed. Each value of the tuple will be displayed in a single line.
</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="TextColor">
<default_type>string</default_type>
<default_value>'black'</default_value>
<description lang="en_US">Defines the color of the text as string. If set to [], or '' the currently set color is used. If a tuple of strings is passed, the colors are used cyclically for each new textline.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'white'</item>
<item>'black'</item>
<item>'blue'</item>
<item>'yellow'</item>
<item>'red'</item>
<item>'green'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'forest green'</item>
<item>'lime green'</item>
<item>'coral'</item>
<item>'slate blue'</item>
</values>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the graphics window, where the message should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="disp_title_and_information" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>global tuple gInfoDecor</l>
<l>global tuple gInfoPos</l>
<l>global tuple gTitlePos</l>
<l>global tuple gTitleDecor</l>
<c>* </c>
<l>get_window_extents (WindowHandle, WinRow, WinColumn, WinWidth, WinHeight)</l>
<l>Title := split('' + Title + '','\n')</l>
<l>NumTitleLines := |Title|</l>
<l>if (NumTitleLines &gt; 0)</l>
<l>    Row := 12</l>
<l>    if (gTitlePos == 'UpperLeft')</l>
<l>        Column := 12</l>
<l>    elseif (gTitlePos == 'UpperCenter')</l>
<l>        max_line_width (WindowHandle, Title, TextWidth)</l>
<l>        Column := WinWidth / 2 - TextWidth / 2</l>
<l>    elseif (gTitlePos == 'UpperRight')</l>
<l>        if (gTitleDecor[1] == 'true')</l>
<l>            max_line_width (WindowHandle, Title + '  ', TextWidth)</l>
<l>        else</l>
<l>            max_line_width (WindowHandle, Title, TextWidth)</l>
<l>        endif</l>
<l>        Column := WinWidth - TextWidth - 10</l>
<l>    else</l>
<c>        * Unknown position!</c>
<l>        stop ()</l>
<l>    endif</l>
<l>    disp_message (WindowHandle, Title, 'window', Row, Column, gTitleDecor[0], gTitleDecor[1])</l>
<l>endif</l>
<l>Information := split('' + Information + '','\n')</l>
<l>NumInfoLines := |Information|</l>
<l>if (NumInfoLines &gt; 0)</l>
<l>    if (gInfoPos == 'UpperLeft')</l>
<l>        Row := 12</l>
<l>        Column := 12</l>
<l>    elseif (gInfoPos == 'UpperRight')</l>
<l>        if (gInfoDecor[1] == 'true')</l>
<l>            max_line_width (WindowHandle, Information + '  ', TextWidth)</l>
<l>        else</l>
<l>            max_line_width (WindowHandle, Information, TextWidth)</l>
<l>        endif</l>
<l>        Row := 12</l>
<l>        Column := WinWidth - TextWidth - 12</l>
<l>    elseif (gInfoPos == 'LowerLeft')</l>
<l>        get_string_extents (WindowHandle, Information, Ascent, Descent, Width, Height)</l>
<l>        Row := WinHeight - (max2(0,NumInfoLines - 1) * (Ascent + Descent) + Height) - 12</l>
<l>        Column := 12</l>
<l>    else</l>
<c>        * Unknown position!</c>
<l>        stop ()</l>
<l>    endif</l>
<l>    disp_message (WindowHandle, Information, 'window', Row, Column, gInfoDecor[0], gInfoDecor[1])</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="disp_title_and_information">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Information"/>
<parameter id="Title"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="dump_image_output">
<interface>
<io>
<par name="BackgroundImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="Scene3D" base_type="ctrl" dimension="0"/>
<par name="AlphaOrig" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="ColorImage" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
<par name="Labels" base_type="ctrl" dimension="0"/>
<par name="VisualizeTrackball" base_type="ctrl" dimension="0"/>
<par name="DisplayContinueButton" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterRow" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterCol" base_type="ctrl" dimension="0"/>
<par name="TrackballRadiusPixel" base_type="ctrl" dimension="0"/>
<par name="SelectedObject" base_type="ctrl" dimension="0"/>
<par name="VisualizeRotationCenter" base_type="ctrl" dimension="0"/>
<par name="RotationCenter" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>global tuple gAlphaDeselected</l>
<l>global tuple gTerminationButtonLabel</l>
<l>global tuple gDispObjOffset</l>
<l>global tuple gLabelsDecor</l>
<l>global tuple gUsesOpenGL</l>
<c>* </c>
<c>* Display background image</c>
<l>clear_window (WindowHandleBuffer)</l>
<l>if (ColorImage)</l>
<l>    disp_color (BackgroundImage, WindowHandleBuffer)</l>
<l>else</l>
<l>    disp_image (BackgroundImage, WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<c>* Display objects</c>
<l>if (sum(SelectedObject) == |SelectedObject|)</l>
<l>    if (gUsesOpenGL == 'true')</l>
<l>        try</l>
<l>            display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>        catch (Exception)</l>
<l>            if (Exception[0] == 5185 or Exception[0] == 5188 or Exception[0] == 5187)</l>
<l>                gUsesOpenGL := 'false'</l>
<l>            else</l>
<l>                throw (Exception)</l>
<l>            endif</l>
<l>        endtry</l>
<l>    endif</l>
<l>    if (gUsesOpenGL == 'false')</l>
<c>        * * NO OpenGL, use fallback</c>
<l>        disp_object_model_no_opengl (ModelContours, ObjectModel3DID, GenParamName, GenParamValue, WindowHandleBuffer, CamParam, Poses)</l>
<l>    endif</l>
<l>else</l>
<l>    for Index := 0 to |AlphaOrig| - 1 by 1</l>
<l>        if (SelectedObject[Index] == 1)</l>
<l>            set_scene_3d_instance_param (Scene3D, Index, 'alpha', AlphaOrig[Index])</l>
<l>        else</l>
<l>            set_scene_3d_instance_param (Scene3D, Index, 'alpha', gAlphaDeselected)</l>
<l>        endif</l>
<l>    endfor</l>
<l>    try</l>
<l>        if (gUsesOpenGL == 'false')</l>
<l>            throw ([])</l>
<l>        endif</l>
<l>        display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>    catch (Exception1)</l>
<c>        * * NO OpenGL, use fallback</c>
<l>        DeselectedIdx := find(SelectedObject,0)</l>
<l>        if (DeselectedIdx != -1)</l>
<l>            DeselectedName := 'color_' + DeselectedIdx</l>
<l>            DeselectedValue := gen_tuple_const(|DeselectedName|,'gray')</l>
<l>        endif</l>
<l>        disp_object_model_no_opengl (ModelContours, ObjectModel3DID, [GenParamName,DeselectedName], [GenParamValue,DeselectedValue], WindowHandleBuffer, CamParam, Poses)</l>
<l>    endtry</l>
<l>    for Index := 0 to |AlphaOrig| - 1 by 1</l>
<l>        set_scene_3d_instance_param (Scene3D, Index, 'alpha', AlphaOrig[Index])</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Display labels</c>
<l>if (Labels != 0)</l>
<l>    set_color (WindowHandleBuffer, gLabelsDecor[0])</l>
<l>    for Index := 0 to |ObjectModel3DID| - 1 by 1</l>
<c>        * Project the center point of the current model</c>
<l>        Pose := Poses[Index * 7:Index * 7 + 6]</l>
<l>        pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>        get_object_model_3d_params (ObjectModel3DID[Index], 'center', Center)</l>
<l>        affine_trans_point_3d (HomMat3D, Center[0], Center[1], Center[2], CenterCamX, CenterCamY, CenterCamZ)</l>
<l>        project_3d_point (CenterCamX, CenterCamY, CenterCamZ, CamParam, CenterRow, CenterCol)</l>
<l>        Label := Labels[Index]</l>
<l>        if (Label != '')</l>
<l>            get_string_extents (WindowHandleBuffer, Label, Ascent, Descent, TextWidth, TextHeight)</l>
<l>            disp_message (WindowHandleBuffer, Label, 'window', CenterRow - TextHeight / 2 + gDispObjOffset[0], CenterCol - TextWidth / 2 + gDispObjOffset[1], [], gLabelsDecor[1])</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c>* </c>
<c>* Visualize the trackball if desired</c>
<l>if (VisualizeTrackball)</l>
<l>    set_line_width (WindowHandleBuffer, 1)</l>
<l>    gen_ellipse_contour_xld (TrackballContour, TrackballCenterRow, TrackballCenterCol, 0, TrackballRadiusPixel, TrackballRadiusPixel, 0, 6.28318, 'positive', 1.5)</l>
<l>    set_color (WindowHandleBuffer, 'dim gray')</l>
<l>    disp_xld (TrackballContour, WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<c>* Visualize the rotation center if desired</c>
<l>if (VisualizeRotationCenter != 0 and |RotationCenter| == 3)</l>
<l>    if (RotationCenter[2] &lt; 1e-10)</l>
<l>        RotationCenter[2] := 1e-10</l>
<l>    endif</l>
<l>    project_3d_point (RotationCenter[0], RotationCenter[1], RotationCenter[2], CamParam, RotCenterRow, RotCenterCol)</l>
<l>    Orientation := rad(90)</l>
<l>    if (VisualizeRotationCenter == 1)</l>
<l>        Orientation := rad(45)</l>
<l>    endif</l>
<l>    gen_cross_contour_xld (CrossRotCenter, RotCenterRow, RotCenterCol, TrackballRadiusPixel / 25.0, Orientation)</l>
<l>    set_line_width (WindowHandleBuffer, 3)</l>
<l>    query_color (WindowHandleBuffer, Colors)</l>
<l>    set_color (WindowHandleBuffer, 'light gray')</l>
<l>    disp_xld (CrossRotCenter, WindowHandleBuffer)</l>
<l>    set_line_width (WindowHandleBuffer, 1)</l>
<l>    set_color (WindowHandleBuffer, 'dim gray')</l>
<l>    disp_xld (CrossRotCenter, WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<c>* Display title</c>
<l>disp_title_and_information (WindowHandleBuffer, Title, Information)</l>
<c>* </c>
<c>* Display the 'Exit' button</c>
<l>if (DisplayContinueButton == 'true')</l>
<l>    disp_continue_button (WindowHandleBuffer)</l>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="dump_image_output">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Renders 3D object models in a buffer window.</short>
<parameters>
<parameter id="AlphaOrig"/>
<parameter id="BackgroundImage">
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="CamParam"/>
<parameter id="ColorImage">
<sem_type>string</sem_type>
</parameter>
<parameter id="DisplayContinueButton"/>
<parameter id="GenParamName">
<sem_type>string</sem_type>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Information">
<sem_type>string</sem_type>
</parameter>
<parameter id="Labels">
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Poses">
<sem_type>pose</sem_type>
</parameter>
<parameter id="RotationCenter"/>
<parameter id="Scene3D"/>
<parameter id="SelectedObject">
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
</parameter>
<parameter id="Title">
<sem_type>string</sem_type>
</parameter>
<parameter id="TrackballCenterCol">
<sem_type>real</sem_type>
</parameter>
<parameter id="TrackballCenterRow">
<sem_type>real</sem_type>
</parameter>
<parameter id="TrackballRadiusPixel">
<sem_type>real</sem_type>
</parameter>
<parameter id="VisualizeRotationCenter"/>
<parameter id="VisualizeTrackball">
<sem_type>real</sem_type>
</parameter>
<parameter id="WindowHandleBuffer">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="estimate_bounding_box_3d_reconstruction">
<interface>
<ic>
<par name="StereoModelID" base_type="ctrl" dimension="0"/>
<par name="ObjectHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="BoundingBox" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* The goal of this procedure is to estimate bounding box parameters</c>
<c>* for 3D reconstruction. This is done by intersecting the</c>
<c>* cones of sight of the cameras with a plane defined by the pose</c>
<c>* of the reference calibration plate.</c>
<c>* </c>
<l>if (ObjectHeight == 0)</l>
<l>    throw ('Object height must not be zero.')</l>
<l>endif</l>
<c>* Check whether the coordinate system has been moved by setting a pose</c>
<c>* with the parameter 'coord_transf_pose' in set_camera_setup_param.</c>
<c>* If this is not the case, the origin is still in one of the cameras.</c>
<c>* However, this procedures needs the origin to be in a calibration plate.</c>
<l>get_stereo_model_param (StereoModelID, 'camera_setup_model', CameraSetupModelID)</l>
<l>get_camera_setup_param (CameraSetupModelID, 'general', 'reference_camera', ReferenceCamera)</l>
<l>if (ReferenceCamera != -1)</l>
<l>    throw ('Please set the \'coord_transf_pose\' to the pose of an calibration plate that lies horizontally in the image using the get_calib_data and set_camera_setup_param.')</l>
<l>endif</l>
<c>* Check whether the image pairs have been set.</c>
<l>get_stereo_model_image_pairs (StereoModelID, From, To)</l>
<l>if (|From| == 0 or |To| == 0)</l>
<l>    throw ('Please define the image pairs first with \'get_stereo_model_image_pairs.\'')</l>
<l>endif</l>
<c>* </c>
<c>* First, we generate 3D object models that represent the cones of sight of the cameras,</c>
<c>* like in the procedure gen_camera_setup_object_model_3d.</c>
<l>get_camera_setup_param (CameraSetupModelID, 'general', 'num_cameras', NumCameras)</l>
<l>ObjectModel3DCone := []</l>
<l>DistanceCameras := []</l>
<l>for CameraIndex := 0 to NumCameras - 1 by 1</l>
<l>    get_camera_setup_param (CameraSetupModelID, CameraIndex, 'pose', CamPose)</l>
<l>    DistanceCamera := sqrt((CamPose[0] * CamPose[0]) + (CamPose[1] * CamPose[1]) + (CamPose[2] * CamPose[2]))</l>
<l>    DistanceCameras := [DistanceCameras,DistanceCamera]</l>
<l>    ConeLength := DistanceCamera * 2.0</l>
<c>    * Distinguish cases with/without projection center.</c>
<l>    get_camera_setup_param (CameraSetupModelID, CameraIndex, 'type', Type)</l>
<l>    if (Type =~ 'telecentric')</l>
<l>        gen_cone_telecentric_object_model_3d (CameraSetupModelID, CameraIndex, ConeLength, ObjectModel3D)</l>
<l>    else</l>
<l>        gen_cone_perspective_object_model_3d (CameraSetupModelID, CameraIndex, ConeLength, ObjectModel3D)</l>
<l>    endif</l>
<l>    ObjectModel3DCone := [ObjectModel3DCone,ObjectModel3D]</l>
<l>endfor</l>
<c>* </c>
<c>* Then, we intersect these cones of sight with a plane that lies horizontally</c>
<c>* in the origin of the stereo setup. We do this simultaneously for the</c>
<c>* previously defined image pairs.</c>
<l>gen_empty_obj (PlaneConeIntersections)</l>
<l>for Index1 := 0 to |From| - 1 by 1</l>
<l>    intersect_plane_object_model_3d (ObjectModel3DCone[From[Index1]], [0,0,0,0,0,0,0], ObjectModel3DIntersectionFrom)</l>
<l>    intersect_plane_object_model_3d (ObjectModel3DCone[To[Index1]], [0,0,0,0,0,0,0], ObjectModel3DIntersectionTo)</l>
<c>    * </c>
<c>    * Get the coordinates of the 3D object models that represent the intersection.</c>
<l>    get_object_model_3d_params (ObjectModel3DIntersectionFrom, 'point_coord_x', XFrom)</l>
<l>    get_object_model_3d_params (ObjectModel3DIntersectionFrom, 'point_coord_y', YFrom)</l>
<l>    get_object_model_3d_params (ObjectModel3DIntersectionTo, 'point_coord_x', XTo)</l>
<l>    get_object_model_3d_params (ObjectModel3DIntersectionTo, 'point_coord_y', YTo)</l>
<c>    * </c>
<c>    * The, we want to intersect the intersections of the image pair. We do this in 2D using XLDs.</c>
<c>    * Generate the XLD of the 'From' intersection.</c>
<l>    gen_contour_polygon_xld (ContourFrom, XFrom, YFrom)</l>
<c>    * Generate the XLD of the 'To' intersection.</c>
<l>    gen_contour_polygon_xld (ContourTo, XTo, YTo)</l>
<c>    * </c>
<c>    * The order of the coordinates from get_object_model_3d_params might not be ideal.</c>
<c>    * Thus, we compute the smallest rectangle around the created XLD.</c>
<l>    smallest_rectangle2_xld (ContourFrom, Row, Column, Phi, Length1, Length2)</l>
<l>    gen_rectangle2_contour_xld (RectangleFrom, Row, Column, Phi, Length1, Length2)</l>
<l>    smallest_rectangle2_xld (ContourTo, Row, Column, Phi, Length1, Length2)</l>
<l>    gen_rectangle2_contour_xld (RectangleTo, Row, Column, Phi, Length1, Length2)</l>
<c>    * </c>
<c>    * Intersect and concatenate the intersections</c>
<l>    intersection_closed_contours_xld (RectangleFrom, RectangleTo, ContoursIntersection)</l>
<l>    concat_obj (PlaneConeIntersections, ContoursIntersection, PlaneConeIntersections)</l>
<l>    clear_object_model_3d (ObjectModel3DIntersectionFrom)</l>
<l>    clear_object_model_3d (ObjectModel3DIntersectionTo)</l>
<l>endfor</l>
<c>* </c>
<c>* Union all intersections of all image pairs.</c>
<l>gen_empty_obj (PlaneConeIntersectionUnion)</l>
<l>count_obj (PlaneConeIntersections, Number)</l>
<l>for Index2 := 1 to Number by 1</l>
<l>    select_obj (PlaneConeIntersections, ObjectSelected, Index2)</l>
<l>    union2_closed_contours_xld (ObjectSelected, PlaneConeIntersectionUnion, PlaneConeIntersectionUnion)</l>
<l>endfor</l>
<c>* </c>
<c>* Get the coordinates of the resulting XLD, which represents the area</c>
<c>* in 2D where the reconstruction is possible.</c>
<l>get_contour_xld (PlaneConeIntersectionUnion, RowContour, ColumnContour)</l>
<c>* </c>
<c>* Based on this contour, we can easily access the parameters of the bounding box.</c>
<l>if (ObjectHeight &gt; 0)</l>
<l>    BoundingBox := [min(RowContour),min(ColumnContour),-ObjectHeight,max(RowContour),max(ColumnContour),0]</l>
<l>else</l>
<l>    BoundingBox := [min(RowContour),min(ColumnContour),0,max(RowContour),max(ColumnContour),-ObjectHeight]</l>
<l>endif</l>
<c>* </c>
<c>* Clean up.</c>
<l>clear_camera_setup_model (CameraSetupModelID)</l>
<l>clear_object_model_3d (ObjectModel3DCone)</l>
<l>return ()</l>
</body>
<docu id="estimate_bounding_box_3d_reconstruction">
<abstract lang="en_US">estimate_bounding_box_3d_reconstruction estimates a suitable bounding box for the stereo setup given in StereoModelID. The height of the bounding box is specified in ObjectHeight. 
The bounding box is returned as a tuple in the form [X1, Y1, Z1, X2, Y2, Z2], where [X1,Y1,Z1] and [X2,Y2,Z2] are the coordinates of the upper left and lower right corner.

The parameters of the bounding box are calculated based on the intersection of the cones of sight of the cameras with the world plane.The world plane should be the plane where the recontructed objects are placed. Typically, it is defined by the pose of a calibration plate. For this procedure to work, it is necessary to set a suitable plane as reference coordinate system within the camera setup model with the parameter 'coord_transf_pose' of set_camera_setup_param.
For example, if you want to use the image of the first calibration plate for the reference coordinate system, use 

ReferencePoseIndex := 1
get_calib_data (CalibDataID, 'calib_obj_pose', [0,ReferencePoseIndex], 'pose', ReferencePose)
set_camera_setup_param (CameraSetupModelID, 'general', 'coord_transf_pose', ReferencePose)

Additionally, before calling this procedure, you need the set the image pairs of the stereo reconstruction using get_stereo_model_image_pairs.</abstract>
<chapters lang="de_DE">
<item>3D-Rekonstruktion</item>
<item>Mehrbild-Stereo</item>
</chapters>
<chapters lang="en_US">
<item>3D Reconstruction</item>
<item>Multi-View Stereo</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
* Prepare camera setup and stereo model.
read_camera_setup_model ('cam_setup_model.csm', CameraSetupModelID)
create_stereo_model (CameraSetupModelID, 'surface_fusion', [], [], StereoModelID)
set_stereo_model_image_pairs (StereoModelID, [1, 2], [0, 0])
* Estimate and set bounding box automatically.
estimate_bounding_box_3d_reconstruction (StereoModelID, 0.06, BoundingBox)
set_stereo_model_param (StereoModelID, 'bounding_box', BoundingBox)
* Create and visualize object models that represent the setup.
gen_camera_setup_object_model_3d (CameraSetupModelID, 'auto', 'auto', ObjectModel3DCamera, ObjectModel3DCone)
gen_bounding_box_object_model_3d (StereoModelID, ObjectModel3DBoundingBox)
visualize_object_model_3d (WindowHandle, [ObjectModel3DBoundingBox, ObjectModel3DCamera, ObjectModel3DCone], [], [], ['color_0', 'alpha'], ['red', 0.5], [], [],[] , Pose)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>calibrate_cameras</item>
<item>get_calib_data</item>
<item>set_camera_setup_param</item>
<item>set_stereo_model_image_pairs</item>
<item>create_stereo_model</item>
<item>read_object_model_3d</item>
<item>gen_object_model_3d_from_points</item>
</predecessor>
<short lang="en_US">Estimate a bounding box for 3D reconstruction based on a stereo setup.</short>
<successor>
<item>set_stereo_model_param</item>
<item>reconstruct_surface_stereo</item>
<item>clear_object_model_3d</item>
<item>disp_object_model_3d</item>
</successor>
<parameters>
<parameter id="BoundingBox">
<default_type>real</default_type>
<description lang="en_US">The bounding box parameters.</description>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectHeight">
<default_type>real</default_type>
<default_value>0.05</default_value>
<description lang="en_US">Height of the object that will be reconstructed, in meters.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.01</item>
<item>0.02</item>
<item>0.05</item>
<item>0.1</item>
</values>
</parameter>
<parameter id="StereoModelID">
<default_type>integer</default_type>
<description lang="en_US">Handle to the stereo model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>stereo_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="evaluate_dl_classifier">
<interface>
<ic>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="DLClassifierHandle" base_type="ctrl" dimension="0"/>
<par name="DLClassifierResultID" base_type="ctrl" dimension="0"/>
<par name="EvaluationMeasureType" base_type="ctrl" dimension="0"/>
<par name="ClassesToEvaluate" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EvaluationMeasure" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure can be used to compute various evaluation measures </c>
<c>* to check the performance of your trained </c>
<c>* deep-learning-based classifier DLClassifierHandle.</c>
<c>* For this, the GroundTruthLabels must be given. Additionally, </c>
<c>* the results of the classification must be given in DLClassifierResultID,</c>
<c>* as returned by apply_dl_classifier and apply_dl_classifier_batchwise.</c>
<c>* With EvaluationMeasureType, you can choose which evaluation measure </c>
<c>* to return. With ClassesToEvaluate, you can choose whether to return</c>
<c>* the result for a single class, a result for every class, or </c>
<c>* for all classes combined. The result is returned in EvaluationMeasure.</c>
<c>*</c>
<c>* Check input.</c>
<c>* Check whether ClassesToEvaluate is a class or 'global'.</c>
<l>get_dl_classifier_param (DLClassifierHandle, 'classes', Classes)</l>
<c>*</c>
<c>* Convert the class indices to class labels if necessary</c>
<l>if (find(is_int_elem(GroundTruthLabels), 0) == -1)</l>
<l>    if (min(GroundTruthLabels) &lt; 0 or max(GroundTruthLabels) &gt; |Classes|-1)</l>
<l>        throw ('The Indices of the GroundTruthLabels exceed the range of classes. \nPlease check your data split.')</l>
<l>    endif</l>
<l>    GroundTruthLabels := Classes[GroundTruthLabels]</l>
<l>endif</l>
<l>if (uniq(sort(GroundTruthLabels)) != sort(Classes))</l>
<l>    throw ('Not all classes are represented in the GroundTruthLabels. \nPlease check your data split.')</l>
<l>endif</l>
<l>TestClassesToEvaluate:= ['global', Classes]</l>
<l>if (difference(ClassesToEvaluate, TestClassesToEvaluate) != [])</l>
<l>    throw ('ClassesToEvaluate invalid.')</l>
<l>endif</l>
<c>*</c>
<c>* Count the measure types and modes of ClassesToEvaluate.</c>
<l>NumEvalMeasureTypes := |EvaluationMeasureType|</l>
<l>NumEvalClasses := |ClassesToEvaluate|</l>
<c>*</c>
<c>* If the numbers are not equal, extend the shorter one.</c>
<l>if (NumEvalMeasureTypes &gt; NumEvalClasses)</l>
<l>    if (NumEvalMeasureTypes &gt; 1 and NumEvalClasses &gt; 1)</l>
<l>        throw ('Invalid number of elements in EvaluationMeasureType/ClassesToEvaluate.')</l>
<l>    else</l>
<l>        ClassesToEvaluate:= gen_tuple_const(NumEvalMeasureTypes, ClassesToEvaluate)</l>
<l>    endif</l>
<l>endif</l>
<l>if (NumEvalMeasureTypes &lt; NumEvalClasses)</l>
<l>    if (NumEvalMeasureTypes &gt; 1 and NumEvalClasses &gt; 1)</l>
<l>        throw ('Invalid number of elements in EvaluationMeasureType/ClassesToEvaluate.')</l>
<l>    else</l>
<l>        EvaluationMeasureType := gen_tuple_const(NumEvalClasses, EvaluationMeasureType) </l>
<l>    endif</l>
<l>endif</l>
<c>*</c>
<c>* Check whether we need to compute a confusion matrix.</c>
<c>* We want to do this only once to save run time.</c>
<l>ComputePrecision := EvaluationMeasureType =~ 'precision'</l>
<l>ComputeRecall := EvaluationMeasureType =~ 'recall'</l>
<l>ComputeFScore := EvaluationMeasureType =~ 'f_score'</l>
<l>ComputeConfusionMatrix := ComputePrecision + ComputeRecall + ComputeFScore </l>
<l>if (ComputeConfusionMatrix &gt; 0)</l>
<c>    * Get the top-1 predicted classes from the result handle(s).</c>
<l>    PredictedClasses := []</l>
<l>    for Index := 0 to |DLClassifierResultID|-1 by 1</l>
<l>        get_dl_classifier_result (DLClassifierResultID[Index], 'all', 'predicted_classes', PredictedClass)</l>
<l>        PredictedClasses := [PredictedClasses, PredictedClass]</l>
<l>    endfor</l>
<c>    * Compute the confusion matrix.</c>
<l>    gen_confusion_matrix(GroundTruthLabels, PredictedClasses, 'display_matrix', 'none', [], ConfusionMatrix)</l>
<l>endif</l>
<c>*</c>
<c>* Loop through all given measure types.</c>
<l>EvaluationMeasure := []</l>
<l>for EvalMeasureTypeIndex := 0 to max([NumEvalMeasureTypes, NumEvalClasses])-1 by 1</l>
<c>    * Select the current combination.</c>
<l>    CurrentEvalMeasure := EvaluationMeasureType[EvalMeasureTypeIndex]</l>
<l>    CurrentEvalClass := ClassesToEvaluate[EvalMeasureTypeIndex]</l>
<c>    * Set the output accordingly.</c>
<c>    * Check whether to compute the top-k error.</c>
<l>    RegExpTopKError := 'top([0-9]+)_error'</l>
<l>    ComputeTopKError := CurrentEvalMeasure =~ RegExpTopKError</l>
<c>    * Check whether to compute the precision, recall, F-score.</c>
<l>    ComputePrecision := CurrentEvalMeasure =~ 'precision'</l>
<l>    ComputeRecall := CurrentEvalMeasure =~ 'recall'</l>
<l>    ComputeFScore := CurrentEvalMeasure =~ 'f_score'</l>
<c>    *</c>
<l>    if (ComputeTopKError)</l>
<c>        * Get the K from the input string 'topK_error'.</c>
<l>        K := number(regexp_match (CurrentEvalMeasure, RegExpTopKError))</l>
<c>        * Select all labels or only the labels with the respective class.</c>
<l>        if (CurrentEvalClass == 'global')</l>
<l>            Indices := [0:|GroundTruthLabels|-1]</l>
<l>        else </l>
<l>            Indices := find(GroundTruthLabels, CurrentEvalClass)</l>
<l>        endif </l>
<l>        compute_top_k_error (DLClassifierHandle, DLClassifierResultID, GroundTruthLabels, Indices, K, TopKError)</l>
<l>        EvaluationMeasure[EvalMeasureTypeIndex] := TopKError</l>
<l>    elseif (ComputePrecision or ComputeRecall or ComputeFScore)</l>
<l>        if (CurrentEvalClass == 'global')</l>
<c>            * Compute the mean of the measures for all classes.</c>
<l>            NumClasses := |Classes|</l>
<l>            IndexClass := [0:NumClasses-1]</l>
<l>        else</l>
<c>            * Compute the measures for a certain class.</c>
<l>            NumClasses := 1</l>
<l>            IndexClass := find(Classes, CurrentEvalClass)</l>
<l>        endif</l>
<l>        if (ComputePrecision or ComputeFScore)</l>
<l>            ClassPrecisions := []</l>
<l>            sum_matrix (ConfusionMatrix, 'rows', MatrixRowSumID)</l>
<l>            for Index := 0 to NumClasses-1 by 1</l>
<c>                * Compute the precision for every selected class.</c>
<l>                get_value_matrix (ConfusionMatrix, IndexClass[Index], IndexClass[Index], TruePositive)</l>
<l>                get_value_matrix (MatrixRowSumID, IndexClass[Index], 0, SumPredictedClass)</l>
<l>                if (SumPredictedClass == 0) </l>
<l>                    ClassPrecision := 0</l>
<l>                else</l>
<l>                    ClassPrecision := TruePositive/SumPredictedClass</l>
<l>                endif</l>
<l>                ClassPrecisions := [ClassPrecisions, ClassPrecision]</l>
<l>            endfor</l>
<l>            Precision := mean(ClassPrecisions)</l>
<l>            clear_matrix (MatrixRowSumID) </l>
<l>            if (ComputePrecision)</l>
<l>                EvaluationMeasure[EvalMeasureTypeIndex] := Precision</l>
<l>            endif </l>
<l>        endif</l>
<l>        if (ComputeRecall or ComputeFScore)</l>
<l>            ClassRecalls := []</l>
<l>            sum_matrix (ConfusionMatrix, 'columns', MatrixColumnSumID)</l>
<l>            for Index := 0 to NumClasses-1 by 1</l>
<c>                * Compute the recall for every class.</c>
<l>                get_value_matrix (ConfusionMatrix, IndexClass[Index], IndexClass[Index], TruePositive)</l>
<l>                get_value_matrix (MatrixColumnSumID, 0, IndexClass[Index], SumLabel)</l>
<l>                ClassRecall := TruePositive/SumLabel</l>
<l>                ClassRecalls := [ClassRecalls, ClassRecall]</l>
<l>            endfor</l>
<l>            Recall := mean(ClassRecalls)</l>
<l>            clear_matrix (MatrixColumnSumID)</l>
<l>            if (ComputeRecall)</l>
<l>                EvaluationMeasure[EvalMeasureTypeIndex] := Recall</l>
<l>            endif</l>
<l>        endif</l>
<l>        if (ComputeFScore)</l>
<c>            * Compute the F-score for a certain class or globally </c>
<c>            * for the averaged precision and recall.</c>
<c>            * Precision and recall were already computed above.</c>
<l>            if (Precision + Recall == 0)</l>
<l>                FScore := 0.0</l>
<l>            else</l>
<l>                FScore := (2 * Precision * Recall) / (Precision + Recall)</l>
<l>            endif</l>
<l>            EvaluationMeasure[EvalMeasureTypeIndex] := FScore</l>
<l>        endif</l>
<l>    else</l>
<l>        throw ('Invalid option for EvaluationMeasureType: \'' + CurrentEvalMeasure + '\'')</l>
<l>    endif  </l>
<l>endfor</l>
<l>if (ComputeConfusionMatrix)</l>
<l>    clear_matrix (ConfusionMatrix)</l>
<l>endif</l>
<l>return ()</l>
<c></c>
</body>
<docu id="evaluate_dl_classifier">
<abstract lang="de_DE">Diese Prozedur kann genutzt werden, um Bewertungsmaße zur Leistung des trainierten Deep-Learning-Klassifikators DLClassifierHandle zu erhalten. Dazu werden die mit GroundTruthLabels gegebenen Labels mit den Klassifikationsergebnissen, die in DLClassifierResultID (Ergebnis von apply_dl_classifier and apply_dl_classifier_batchwise) gespeichert sind, für den gegeben Datensatz verglichen. Mit EvaluationMeasureType wird festgelegt, welche Bewertungsmaße ausgerechnet werden sollen. Mit ClassesToEvaluate kann bestimmt werden, ob die Bewertungsmaße global über alle Klassen ausgerechnet werden oder nur für einzelne Klassen. Das Ergebnis wird in EvaluationMeasure ausgegeben.

Die folgenden Bewertungsmaße werden aktuell von EvaluationMeasureType unterstützt (eine Erklärung der Bewertungsmaße befindet sich in der Kapitelreferenz von Deep Learning / Klassifikation):
   'topK_error', wobei K eine Zahl zwischen 1 und der Anzahl Klassen ist.
   'precision' (Genauigkeit)
   'recall' (Trefferquote)
   'f_score' (F1 Maß bestimmt aus den Werten für 'precision' und 'recall')

Die folgenden Modi werden aktuell von ClassesToEvaluateunterstützt:
   'global': Die Bewertungsmaße werden global über alle Klassen bestimmt. Der Top-K-Fehler wird für den gesamten Datensatz bestimmt. Die anderen Bewertungsmaße werden über alle Klassen gemittelt.
   '\class_name\': Die Bewertungsmaße werden für die gegebene Klasse bestimmt.

</abstract>
<abstract lang="en_US">This procedure can be used to compute evaluation measures of the performance of your trained deep-learning-based classifier DLClassifierHandle on a given data set. For this, the GroundTruthLabels and the classification results DLClassifierResultID, as returned by apply_dl_classifier and apply_dl_classifier_batchwise, are required for every image in the data set. With EvaluationMeasureType, you can choose which evaluation measure shall be returned. With ClassesToEvaluate, you can choose whether the measure shall be applied globally (over all classes) or just to single classes. The result is returned in EvaluationMeasure.

These measures are supported by EvaluationMeasureType (for an explanation, please see the chapter reference of Deep Learning / Classification):
   'topK_error', where K is a number between 1 and the number of classes.
   'precision'
   'recall'
   'f_score' (the F1 score calculated from the corresponding 'precision' and 'recall' measures)

The following modes are supported for ClassesToEvaluate:
   'global': The evaluation measures are calculated  globally over all classes. The top-K-error is computed over the full data set. The other evaluation measures are averaged over all classes.
   '\class_name\': You can enter a single class name, to get the evaluation measure computed for this class.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Klassifikation</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="de_DE">Evaluieren der Leistung eines Deep Learning-basierten Klassifikators.</short>
<short lang="en_US">Evaluate the performance of a deep-learning-based classifier.</short>
<parameters>
<parameter id="ClassesToEvaluate">
<default_type>string</default_type>
<default_value>'global'</default_value>
<description lang="de_DE">Auswahl, ob das Bewertungsmaß für alle oder einzelne Klassen errechnet wird.</description>
<description lang="en_US">Select whether evaluation measures for all classes or a single class should be returned.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="DLClassifierHandle">
<default_type>integer</default_type>
<description lang="de_DE">Handle des Deep Learning-basierten Klassifikators.</description>
<description lang="en_US">Handle of the deep-learning-based classifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_classifier</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>0</value_max>
</parameter>
<parameter id="DLClassifierResultID">
<default_type>integer</default_type>
<description lang="de_DE">Resultat-Handle, wie er von apply_dl_classifier und apply_dl_classifier_batchwise zurückgegeben wird.</description>
<description lang="en_US">Result handle as returned by apply_dl_classifier and apply_dl_classifier_batchwise.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>dl_classifier_result</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="EvaluationMeasure">
<default_type>string</default_type>
<description lang="de_DE">Das resultierende Bewertungsmaß.</description>
<description lang="en_US">The resulting evaluation measure.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="EvaluationMeasureType">
<default_type>string</default_type>
<default_value>'top1_error'</default_value>
<description lang="de_DE">Bewertungsmaß, das errechnet werden soll.</description>
<description lang="en_US">The evaluation measure that should be returned.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'top1_error'</item>
<item>'top3_error'</item>
<item>'f_score'</item>
<item>'precision'</item>
<item>'recall'</item>
</values>
</parameter>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="de_DE">Die vom Benutzer vergebenen Labels der Bilder.</description>
<description lang="en_US">Ground truth labels of the images.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_arrow_contour_xld">
<interface>
<oo>
<par name="Arrow" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="Column1" base_type="ctrl" dimension="0"/>
<par name="Row2" base_type="ctrl" dimension="0"/>
<par name="Column2" base_type="ctrl" dimension="0"/>
<par name="HeadLength" base_type="ctrl" dimension="0"/>
<par name="HeadWidth" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure generates arrow shaped XLD contours,</c>
<c>* pointing from (Row1, Column1) to (Row2, Column2).</c>
<c>* If starting and end point are identical, a contour consisting</c>
<c>* of a single point is returned.</c>
<c>* </c>
<c>* input parameteres:</c>
<c>* Row1, Column1: Coordinates of the arrows' starting points</c>
<c>* Row2, Column2: Coordinates of the arrows' end points</c>
<c>* HeadLength, HeadWidth: Size of the arrow heads in pixels</c>
<c>* </c>
<c>* output parameter:</c>
<c>* Arrow: The resulting XLD contour</c>
<c>* </c>
<c>* The input tuples Row1, Column1, Row2, and Column2 have to be of</c>
<c>* the same length.</c>
<c>* HeadLength and HeadWidth either have to be of the same length as</c>
<c>* Row1, Column1, Row2, and Column2 or have to be a single element.</c>
<c>* If one of the above restrictions is violated, an error will occur.</c>
<c>* </c>
<c>* </c>
<c>* Init</c>
<l>gen_empty_obj (Arrow)</l>
<c>* </c>
<c>* Calculate the arrow length</c>
<l>distance_pp (Row1, Column1, Row2, Column2, Length)</l>
<c>* </c>
<c>* Mark arrows with identical start and end point</c>
<c>* (set Length to -1 to avoid division-by-zero exception)</c>
<l>ZeroLengthIndices := find(Length,0)</l>
<l>if (ZeroLengthIndices != -1)</l>
<l>    Length[ZeroLengthIndices] := -1</l>
<l>endif</l>
<c>* </c>
<c>* Calculate auxiliary variables.</c>
<l>DR := 1.0 * (Row2 - Row1) / Length</l>
<l>DC := 1.0 * (Column2 - Column1) / Length</l>
<l>HalfHeadWidth := HeadWidth / 2.0</l>
<c>* </c>
<c>* Calculate end points of the arrow head.</c>
<l>RowP1 := Row1 + (Length - HeadLength) * DR + HalfHeadWidth * DC</l>
<l>ColP1 := Column1 + (Length - HeadLength) * DC - HalfHeadWidth * DR</l>
<l>RowP2 := Row1 + (Length - HeadLength) * DR - HalfHeadWidth * DC</l>
<l>ColP2 := Column1 + (Length - HeadLength) * DC + HalfHeadWidth * DR</l>
<c>* </c>
<c>* Finally create output XLD contour for each input point pair</c>
<l>for Index := 0 to |Length| - 1 by 1</l>
<l>    if (Length[Index] == -1)</l>
<c>        * Create_ single points for arrows with identical start and end point</c>
<l>        gen_contour_polygon_xld (TempArrow, Row1[Index], Column1[Index])</l>
<l>    else</l>
<c>        * Create arrow contour</c>
<l>        gen_contour_polygon_xld (TempArrow, [Row1[Index],Row2[Index],RowP1[Index],Row2[Index],RowP2[Index],Row2[Index]], [Column1[Index],Column2[Index],ColP1[Index],Column2[Index],ColP2[Index],Column2[Index]])</l>
<l>    endif</l>
<l>    concat_obj (Arrow, TempArrow, Arrow)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_arrow_contour_xld">
<abstract lang="en_US">This procedure creates arrow shaped XLD contours, which point from the coordinates (Row1, Column1) to the coordinates (Row2, Coordinates2). The shape of the arrow head can be specified with the parameters HeadLength and HeadWidth (in pixels).

If starting and end point are identical, a contour consisting of a single point is returned.

The input tuples Row1, Column1, Row2, and Column2 have to be of the same length. HeadLength and HeadWidth either have to be of the same length as Row1, Column1, Row2, and Column2 or have to be a single element. If one of the above restrictions is violated, an error will occur.
</abstract>
<alternatives>
<item>disp_arrow</item>
<item>gen_contour_polygon_xld</item>
</alternatives>
<chapters lang="de_DE">
<item>XLD</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>XLD</item>
<item>Creation</item>
</chapters>
<example lang="en_US">StartPointRows:=[100,100]
StartPointColumns:=[100,100]
EndPointRows:=[200,50]
EndPointColumns:=[200,150]
dev_set_colored (3)
gen_arrow_contour_xld (Arrow, StartPointRows, StartPointColumns, EndPointRows, EndPointColumns, [10,20], [20,10])
</example>
<keywords lang="de_DE">
<item>XLD-Konturen erzeugen</item>
<item>XLD-Kontur eines Pfeils erzeugen</item>
</keywords>
<keywords lang="en_US">
<item>create XLD contours</item>
<item>create XLD contour of arrow</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>gen_contour_nurbs_xld</item>
</see_also>
<short lang="de_DE">Creates an arrow shaped XLD contour.</short>
<short lang="en_US">Creates an arrow shaped XLD contour.</short>
<successor>
<item>dev_display</item>
<item>disp_obj</item>
</successor>
<parameters>
<parameter id="Arrow">
<description lang="en_US">The generated xld</description>
<multivalue>optional</multivalue>
<sem_type>xld_cont</sem_type>
</parameter>
<parameter id="Column1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The column coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The column coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HeadLength">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The length of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="HeadWidth">
<default_type>integer</default_type>
<default_value>5</default_value>
<description lang="en_US">The width of the arrow head in pixels</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[2,3,5,10,20]</item>
</values>
</parameter>
<parameter id="Row1">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The row coordinate of the starting point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Row2">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The row coordinate of the end point</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_arrow_object_model_3d">
<interface>
<ic>
<par name="ArrowThickness" base_type="ctrl" dimension="0"/>
<par name="ArrowStart" base_type="ctrl" dimension="0"/>
<par name="ArrowEnd" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DArrow" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*</c>
<c>* This procedure draws an arrow that starts at the point ArrowStart and ends at ArrowEnd.</c>
<c>*</c>
<c>* Get parameters.</c>
<l>DirectionVector := ArrowEnd[0:2] - ArrowStart[0:2]</l>
<l>ArrowLength := sqrt(DirectionVector[0] * DirectionVector[0] + DirectionVector[1] * DirectionVector[1] + DirectionVector[2] * DirectionVector[2])</l>
<l>ConeRadius := 2.0 * ArrowThickness</l>
<l>ConeLength := min([2.0 * ConeRadius, ArrowLength*0.9])</l>
<l>CylinderLength := ArrowLength - ConeLength</l>
<c>*</c>
<c>* Create cone.</c>
<l>pi := rad(180)</l>
<l>X := 0</l>
<l>Y := 0</l>
<l>Z := CylinderLength+ ConeLength</l>
<l>for Index := 0 to 2 * pi by 0.1</l>
<l>    X := [X,ConeRadius * cos(Index)]</l>
<l>    Y := [Y,ConeRadius * sin(Index)]</l>
<l>    Z := [Z,CylinderLength]</l>
<l>endfor</l>
<l>gen_object_model_3d_from_points (X, Y, Z, OM3DConeTmp)</l>
<l>convex_hull_object_model_3d (OM3DConeTmp, OM3DCone)</l>
<l>clear_object_model_3d (OM3DConeTmp)</l>
<c>*</c>
<c>* Create cylinder.</c>
<l>X := []</l>
<l>Y := []</l>
<l>for Index := 0 to 2 * pi by 0.1</l>
<l>    X := [X, ArrowThickness * cos(Index)]</l>
<l>    Y := [Y, ArrowThickness * sin(Index)]</l>
<l>endfor</l>
<l>tuple_gen_const (|Y|, 0, ZZero)</l>
<l>tuple_gen_const (|Y|, CylinderLength, ZTop)</l>
<l>gen_object_model_3d_from_points ([X,X], [Y,Y], [ZZero, ZTop], OM3DCylinderTmp)</l>
<l>convex_hull_object_model_3d (OM3DCylinderTmp, OM3DCylinder)</l>
<l>clear_object_model_3d (OM3DCylinderTmp)</l>
<c>*</c>
<c>* Union cone and cylinder Create arrow.</c>
<l>union_object_model_3d ([OM3DCone, OM3DCylinder], 'points_surface', OM3DArrowTmp)</l>
<l>clear_object_model_3d (OM3DCone)</l>
<l>clear_object_model_3d (OM3DCylinder)</l>
<l>Scale := CylinderLength/ArrowLength</l>
<l>OriginX := [0,0,0]</l>
<l>OriginY := [0,0,0]</l>
<l>OriginZ := [0,CylinderLength,ArrowLength]</l>
<l>TargetX := [ArrowStart[0], ArrowStart[0] + Scale*DirectionVector[0], ArrowEnd[0]]</l>
<l>TargetY := [ArrowStart[1], ArrowStart[1] + Scale*DirectionVector[1], ArrowEnd[1]]</l>
<l>TargetZ := [ArrowStart[2], ArrowStart[2] + Scale*DirectionVector[2], ArrowEnd[2]]</l>
<l>vector_to_hom_mat3d ('rigid', OriginX, OriginY, OriginZ, TargetX, TargetY, TargetZ, HomMat3D)</l>
<l>affine_trans_object_model_3d (OM3DArrowTmp, HomMat3D, OM3DArrow)</l>
<l>clear_object_model_3d (OM3DArrowTmp)</l>
<l>return ()</l>
</body>
<docu id="gen_arrow_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="ArrowEnd">
<default_type>real</default_type>
<default_value>[0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0]</default_value>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowStart">
<default_type>real</default_type>
<default_value>[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0]</default_value>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowThickness">
<default_type>real</default_type>
<default_value>0.005</default_value>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DArrow">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_bounding_box_object_model_3d">
<interface>
<ic>
<par name="StereoModelID" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3DBoundingBox" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Consistency check:</c>
<l>get_stereo_model_param (StereoModelID, 'bounding_box', BoundingBox)</l>
<l>if ((BoundingBox[3] &lt; BoundingBox[0]) or (BoundingBox[4] &lt; BoundingBox[1]) or (BoundingBox[5] &lt; BoundingBox[2]))</l>
<l>    throw ('Invalid bounding box or bounding box not set yet.')</l>
<l>endif</l>
<c>* </c>
<c>* Get the eight corner points from the min/max representation.</c>
<l>Points := {[]}</l>
<l>Points.at(0) := [BoundingBox[0],BoundingBox[1],BoundingBox[2]]</l>
<l>Points.at(1) := [BoundingBox[3],BoundingBox[1],BoundingBox[2]]</l>
<l>Points.at(2) := [BoundingBox[3],BoundingBox[4],BoundingBox[2]]</l>
<l>Points.at(3) := [BoundingBox[0],BoundingBox[4],BoundingBox[2]]</l>
<l>Points.at(4) := [BoundingBox[0],BoundingBox[1],BoundingBox[5]]</l>
<l>Points.at(5) := [BoundingBox[3],BoundingBox[1],BoundingBox[5]]</l>
<l>Points.at(6) := [BoundingBox[3],BoundingBox[4],BoundingBox[5]]</l>
<l>Points.at(7) := [BoundingBox[0],BoundingBox[4],BoundingBox[5]]</l>
<c>* </c>
<c>* Sort the corner points by coordinate direction.</c>
<l>PX := []</l>
<l>PY := []</l>
<l>PZ := []</l>
<l>for Index := 0 to 7 by 1</l>
<l>    PX := [PX,Points.at(Index)[0]]</l>
<l>    PY := [PY,Points.at(Index)[1]]</l>
<l>    PZ := [PZ,Points.at(Index)[2]]</l>
<l>endfor</l>
<l>gen_object_model_3d_from_points (PX, PY, PZ, ObjectModel3DBoundingBox)</l>
<c>* </c>
<c>* Set the sides of the cuboid.</c>
<l>Faces := []</l>
<l>Faces := [Faces,4,0,1,5,4]</l>
<l>Faces := [Faces,4,1,2,6,5]</l>
<l>Faces := [Faces,4,2,3,7,6]</l>
<l>Faces := [Faces,4,3,0,4,7]</l>
<l>Faces := [Faces,4,0,1,2,3]</l>
<l>Faces := [Faces,4,4,5,6,7]</l>
<l>set_object_model_3d_attrib_mod (ObjectModel3DBoundingBox, 'polygons', [], Faces)</l>
<l>return ()</l>
</body>
<docu id="gen_bounding_box_object_model_3d">
<abstract lang="en_US">The procedure gen_bounding_box_object_model_3d generates a 3D object model which visualizes the bounding box of a stereo model. The extent of the bounding box is also returned. 

The procedure can be used, e.g., to visualize the setup of the stereo model with its bounding box and cameras which is particularly helpful while adjusting the bounding box. The procedure gen_camera_setup_object_model_3d creates the according 3D object models for cameras and their cones of sight.

Note that if a 3D object model is no longer needed or should be overwritten, the memory has to be freed first by calling the operator clear_object_model_3d.
</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
* Prepare camera setup and stereo model.
read_camera_setup_model ('cam_setup_model.csm', CameraSetupModelID)
create_stereo_model (CameraSetupModelID, 'surface_fusion', [], [], StereoModelID)
set_stereo_model_image_pairs (StereoModelID, [1, 2], [0, 0])
* Estimate and set bounding box automatically.
estimate_bounding_box_3d_reconstruction (StereoModelID, 0.06, BoundingBox)
set_stereo_model_param (StereoModelID, 'bounding_box', BoundingBox)
* Create and visualize object models that represent the setup.
gen_camera_setup_object_model_3d (CameraSetupModelID, 'auto', 'auto', ObjectModel3DCamera, ObjectModel3DCone)
gen_bounding_box_object_model_3d (StereoModelID, ObjectModel3DBoundingBox)
visualize_object_model_3d (WindowHandle, [ObjectModel3DBoundingBox, ObjectModel3DCamera, ObjectModel3DCone], [], [], ['color_0', 'alpha'], ['red', 0.5], [], [],[] , Pose)</example>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_stereo_model</item>
<item>set_stereo_model_param</item>
</predecessor>
<see_also>
<item>reconstruct_surface_stereo</item>
</see_also>
<short lang="en_US">Generate a 3D object model which visualizes the bounding box of a stereo model.</short>
<successor>
<item>visualize_object_model_3d</item>
<item>dev_inspect_ctrl</item>
</successor>
<parameters>
<parameter id="ObjectModel3DBoundingBox">
<default_type>integer</default_type>
<description lang="en_US">Handle of the 3D object model.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="StereoModelID">
<default_type>integer</default_type>
<description lang="en_US">Handle of the stereo model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>stereo_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>0</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_division">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with distortions modeled by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_division',Focus,Kappa,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_division">
<abstract lang="en_US">gen_cam_par_area_scan_division generates the camera parameter tuple CameraParam for an area scan camera with distortions modeled by the division model.  For this, the camera parameters must be passed in Focus, Kappa, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_polynomial">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with distortions modeled by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_polynomial',Focus,K1,K2,K3,P1,P2,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_polynomial generates the camera parameter tuple CameraParam for an area scan camera with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Focus, K1, K2, K3, P1, P2, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_telecentric_division">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with a telecentric lens and with distortions modeled by the</c>
<c>* division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_telecentric_division',Magnification,Kappa,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_telecentric_division">
<abstract lang="en_US">gen_cam_par_area_scan_telecentric_division generates the camera parameter tuple CameraParam for an area scan camera with a telecentric lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Magnification, Kappa, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a telecentric lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_telecentric_polynomial">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera</c>
<c>* with a telecentric lens and with distortions modeled by the</c>
<c>* polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_telecentric_polynomial',Magnification,K1,K2,K3,P1,P2,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_telecentric_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_telecentric_polynomial generates the camera parameter tuple CameraParam for an area scan camera with a telecentric lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Magnification, K1, K2, K3, P1, P2, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a telecentric lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_bilateral_telecentric_division">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* a bilateral telecentric tilt lens and with distortions modeled</c>
<c>* by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_bilateral_telecentric_division',Magnification,Kappa,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_bilateral_telecentric_division">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_bilateral_telecentric_division generates the camera parameter tuple CameraParam for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Magnification, Kappa, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="de_DE">Output camera parameter tuple.</description>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* a bilateral telecentric tilt lens and with distortions modeled</c>
<c>* by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_bilateral_telecentric_polynomial',Magnification,K1,K2,K3,P1,P2,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial generates the camera parameter tuple CameraParam for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Magnification, K1, K2, K3, P1, P2, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a bilateral telecentric tilt lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_division">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="ImagePlaneDist" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* a tilt lens and with distortions modeled by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_division',Focus,Kappa,ImagePlaneDist,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_division">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_division generates the camera parameter tuple CameraParam for an area scan camera with a tilt lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Focus, Kappa, ImagePlaneDist, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a tilt lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImagePlaneDist">
<default_type>real</default_type>
<default_value>0.02</default_value>
<description lang="en_US">Image plane distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_image_side_telecentric_division">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* an image-side telecentric tilt lens and with distortions modeled</c>
<c>* by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_image_side_telecentric_division',Focus,Kappa,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_image_side_telecentric_division">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_image_side_telecentric_division generates the camera parameter tuple CameraParam for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Focus, Kappa, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* an image-side telecentric tilt lens and with distortions modeled</c>
<c>* by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_image_side_telecentric_polynomial',Focus,K1,K2,K3,P1,P2,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial generates the camera parameter tuple CameraParam for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Focus, K1, K2, K3, P1, P2, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with an image-side telecentric tilt lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_object_side_telecentric_division">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="ImagePlaneDist" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* an object-side telecentric tilt lens and with distortions modeled</c>
<c>* by the division model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_object_side_telecentric_division',Magnification,Kappa,ImagePlaneDist,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_object_side_telecentric_division">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_object_side_telecentric_division generates the camera parameter tuple CameraParam for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the division model. For this, the camera parameters must be passed in Magnification, Kappa, ImagePlaneDist, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the division model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="de_DE">Output camera parameter tuple.</description>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImagePlaneDist">
<default_type>real</default_type>
<default_value>0.02</default_value>
<description lang="en_US">Image plane distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial">
<interface>
<ic>
<par name="Magnification" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="ImagePlaneDist" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* an object-side telecentric tilt lens and with distortions modeled</c>
<c>* by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_object_side_telecentric_polynomial',Magnification,K1,K2,K3,P1,P2,ImagePlaneDist,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial generates the camera parameter tuple CameraParam for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Magnification, K1, K2, K3, P1, P2, ImagePlaneDist, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with an object-side telecentric tilt lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImagePlaneDist">
<default_type>real</default_type>
<default_value>0.02</default_value>
<description lang="en_US">Image plane distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Magnification">
<default_type>real</default_type>
<default_value>0.2</default_value>
<description lang="en_US">Magnification of the lens.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>0.1</item>
<item>0.2</item>
<item>0.3</item>
<item>0.4</item>
<item>0.5</item>
<item>1.0</item>
<item>2.0</item>
</values>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical size of a pixel in world coordinates.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_area_scan_tilt_polynomial">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="K1" base_type="ctrl" dimension="0"/>
<par name="K2" base_type="ctrl" dimension="0"/>
<par name="K3" base_type="ctrl" dimension="0"/>
<par name="P1" base_type="ctrl" dimension="0"/>
<par name="P2" base_type="ctrl" dimension="0"/>
<par name="ImagePlaneDist" base_type="ctrl" dimension="0"/>
<par name="Tilt" base_type="ctrl" dimension="0"/>
<par name="Rot" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for an area scan camera with</c>
<c>* a tilt lens and with distortions modeled by the polynomial model.</c>
<c>* </c>
<l>CameraParam := ['area_scan_tilt_polynomial',Focus,K1,K2,K3,P1,P2,ImagePlaneDist,Tilt,Rot,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_area_scan_tilt_polynomial">
<abstract lang="en_US">gen_cam_par_area_scan_tilt_polynomial generates the camera parameter tuple CameraParam for an area scan camera with a tilt lens and with distortions modeled by the polynomial model. For this, the camera parameters must be passed in Focus, K1, K2, K3, P1, P2, ImagePlaneDist, Tilt, Rot, Sx, Sy, Cx, Cy, ImageWidth, and ImageHeight. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for an area scan camera with a tilt lens and with distortions modeled by the polynomial model.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>640</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>512</default_value>
<description lang="en_US">Row coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>1024</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImagePlaneDist">
<default_type>real</default_type>
<default_value>0.02</default_value>
<description lang="en_US">Image plane distance.</description>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>1280</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="K1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="K3">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P1">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="P2">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model decentering lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Rot">
<default_type>real</default_type>
<default_value>90.0</default_value>
<description lang="en_US">Rotation angle (in degrees), i.e., the direction, in which the optical axis is tilted.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Horizontal distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>5.2e-6</default_value>
<description lang="en_US">Vertical distance between two neighboring cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Tilt">
<default_type>real</default_type>
<default_value>10.0</default_value>
<description lang="en_US">Tilt angle (in degrees).</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cam_par_line_scan">
<interface>
<ic>
<par name="Focus" base_type="ctrl" dimension="0"/>
<par name="Kappa" base_type="ctrl" dimension="0"/>
<par name="Sx" base_type="ctrl" dimension="0"/>
<par name="Sy" base_type="ctrl" dimension="0"/>
<par name="Cx" base_type="ctrl" dimension="0"/>
<par name="Cy" base_type="ctrl" dimension="0"/>
<par name="ImageWidth" base_type="ctrl" dimension="0"/>
<par name="ImageHeight" base_type="ctrl" dimension="0"/>
<par name="Vx" base_type="ctrl" dimension="0"/>
<par name="Vy" base_type="ctrl" dimension="0"/>
<par name="Vz" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Generate a camera parameter tuple for a line scan camera.</c>
<c>* </c>
<l>CameraParam := ['line_scan',Focus,Kappa,Sx,Sy,Cx,Cy,ImageWidth,ImageHeight,Vx,Vy,Vz]</l>
<l>return ()</l>
</body>
<docu id="gen_cam_par_line_scan">
<abstract lang="en_US">gen_cam_par_line_scan generates the camera parameter tuple CameraParam for a line scan camera. For this, the camera parameters must be passed in Focus, Kappa, Sx, Sy, Cx, Cy, ImageWidth, ImageHeight, Vx, Vy, Vz. For a detailed explanation of the parameters, see the documentation of calibrate_cameras.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_image_side_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
</see_also>
<short lang="en_US">Generate a camera parameter tuple for a line scan camera.</short>
<successor>
<item>set_calib_data_cam_param</item>
</successor>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Cx">
<default_type>real</default_type>
<default_value>1024</default_value>
<description lang="en_US">Column coordinate of the principal point in the image.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Cy">
<default_type>real</default_type>
<default_value>0</default_value>
<description lang="en_US">Distance of the principal point from the sensor line in scanlines.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Focus">
<default_type>real</default_type>
<default_value>0.008</default_value>
<description lang="en_US">Principal distance.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImageHeight">
<default_type>integer</default_type>
<default_value>3840</default_value>
<description lang="en_US">Image height.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ImageWidth">
<default_type>integer</default_type>
<default_value>2048</default_value>
<description lang="en_US">Image width.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Kappa">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Distortion coefficient to model the radial lens distortions.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sx">
<default_type>real</default_type>
<default_value>1e-5</default_value>
<description lang="en_US">Horizontal size of the cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Sy">
<default_type>real</default_type>
<default_value>1e-5</default_value>
<description lang="en_US">Vertical size of the cells on the sensor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vx">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">X component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vy">
<default_type>real</default_type>
<default_value>5e-5</default_value>
<description lang="en_US">Y component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Vz">
<default_type>real</default_type>
<default_value>0.0</default_value>
<description lang="en_US">Z component of the motion vector.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_camera_and_tool_moving_cam_object_model_3d">
<interface>
<ic>
<par name="ToolInCamPose" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
<par name="ConeLength" base_type="ctrl" dimension="0"/>
<par name="OM3DToolOrig" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
<par name="OM3DTool" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure helps visualize the camera and its cone, as well</c>
<c>* as the robot's tool in their current positions.</c>
<c>*</c>
<c>* Visualize Tool.</c>
<l>rigid_trans_object_model_3d (OM3DToolOrig, ToolInBasePose, OM3DTool)</l>
<c>* </c>
<c>* Visualize Camera.</c>
<l>create_pose (0, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', IdentityPose)</l>
<l>create_camera_setup_model (1, CameraSetupModelID)</l>
<l>set_camera_setup_cam_param (CameraSetupModelID, 0, [], CamParam, IdentityPose)</l>
<l>gen_camera_setup_object_model_3d (CameraSetupModelID, CameraSize, ConeLength, OM3DCameraOrigin, OM3DConeOrig)</l>
<l>clear_camera_setup_model (CameraSetupModelID)</l>
<l>OM3DCameraOrigin := [OM3DCameraOrigin, OM3DConeOrig]</l>
<c>*</c>
<l>pose_invert (ToolInCamPose, CamInToolPose)</l>
<l>pose_compose (ToolInBasePose, CamInToolPose, CamInBasePose)</l>
<l>rigid_trans_object_model_3d (OM3DCameraOrigin, CamInBasePose, OM3DCamera)</l>
<l>clear_object_model_3d (OM3DCameraOrigin)</l>
<l>return ()</l>
</body>
<docu id="gen_camera_and_tool_moving_cam_object_model_3d">
<abstract lang="en_US">This procedure generates 3D object models for the camera and its cone, as well as the robot's tool in their current positions.

The input parameter ToolInCamPose is directly obtained through hand-eye calibration. ToolInBasePose is the current position of the robot's tool. CameraSize determines the size of the camera. ConeLength specifies the length of the camera's cone. OM3DToolOrig is the 3D object model of the robot's tool in its initial position. CamParam contains the camera parameters, obtained through calibration.

The output parameters OM3DCamera and OM3DTool are respectively the 3D object models of the camera and the robot's tool in their current positions.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate 3D object models for the camera and the robot's tool.</short>
<parameters>
<parameter id="CamParam">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="en_US">Camera parameters.</description>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="CameraSize">
<default_type>real</default_type>
<description lang="en_US">Visualization factor.</description>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ConeLength">
<default_type>integer</default_type>
<description lang="en_US">Length of the camera's cone.</description>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<description lang="en_US">3D object model of the camera and its cone.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DTool">
<default_type>integer</default_type>
<description lang="en_US">3D object model of the robot's tool in its current position.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DToolOrig">
<default_type>integer</default_type>
<description lang="en_US">Initial 3D object model of the robot's tool.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Pose of the tool in the base coordinate system.</description>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInCamPose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Pose of the tool in the camera coordinate system.</description>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_camera_object_model_3d" access="local">
<interface>
<ic>
<par name="CameraSetupModel" base_type="ctrl" dimension="0"/>
<par name="CamIndex" base_type="ctrl" dimension="0"/>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DCam" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Generate a cylinder (lens) and move it behind the origin in direction z.</c>
<l>create_pose (0.0, 0.0, 0.0, 0, 0, 0, 'Rp+T', 'gba', 'point', LensePose)</l>
<l>CylinderLength := CameraSize / 4.0</l>
<l>gen_cylinder_object_model_3d (LensePose, CameraSize / 2.0, -CylinderLength / 2.0, 0.0, ObjectModel3DLense)</l>
<c>* </c>
<c>* Generate a box (sensor housing) and tilt it, if necessary.</c>
<l>gen_box_object_model_3d (LensePose, 1.0 * CameraSize, 1.0 * CameraSize, 1.0 * CameraSize, ObjectModel3DInit)</l>
<l>get_camera_setup_param (CameraSetupModel, CamIndex, 'params', CamParams)</l>
<l>get_camera_setup_param (CameraSetupModel, CamIndex, 'type', Type)</l>
<c>* </c>
<c>* Distinguish cases with/without tilt.</c>
<l>if (Type =~ 'tilt')</l>
<l>    get_cam_par_data (CamParams, 'tilt', Tilt)</l>
<l>    get_cam_par_data (CamParams, 'rot', Rot)</l>
<l>else</l>
<l>    Tilt := 0</l>
<l>    Rot := 0</l>
<l>endif</l>
<l>hom_mat3d_identity (HomMat3DIdentity)</l>
<l>hom_mat3d_rotate (HomMat3DIdentity, rad(Tilt), [cos(rad(Rot)),sin(rad(Rot)),0], 0, 0, 0, HomMat3DRotate)</l>
<l>hom_mat3d_to_pose (HomMat3DRotate, SensorToLenseRotation)</l>
<l>rigid_trans_object_model_3d (ObjectModel3DInit, SensorToLenseRotation, ObjectModel3DInitTilted)</l>
<c>* </c>
<c>* Move the sensor to a convenient position behind the lens.</c>
<l>get_object_model_3d_params (ObjectModel3DInitTilted, 'bounding_box1', BoundingBox)</l>
<l>affine_trans_point_3d (HomMat3DRotate, 0.0, 0.0, 0.5 * CameraSize, PX, PY, QZ)</l>
<l>create_pose (-PX, -PY, -BoundingBox[5] - CylinderLength / 2.0, 0, 0, 0, 'Rp+T', 'gba', 'point', PoseBack)</l>
<l>rigid_trans_object_model_3d (ObjectModel3DInitTilted, PoseBack, ObjectModel3DInitTiltedBack)</l>
<c>* </c>
<c>* Move to the position of the camera in world coordinates.</c>
<l>get_camera_setup_param (CameraSetupModel, CamIndex, 'pose', CamPose)</l>
<l>rigid_trans_object_model_3d (ObjectModel3DInitTiltedBack, CamPose, OM3DSensor)</l>
<l>rigid_trans_object_model_3d (ObjectModel3DLense, CamPose, OM3DLense)</l>
<l>OM3DCam := [OM3DSensor,OM3DLense]</l>
<c>* </c>
<c>* Clean up.</c>
<l>clear_object_model_3d (ObjectModel3DInit)</l>
<l>clear_object_model_3d (ObjectModel3DInitTilted)</l>
<l>clear_object_model_3d (ObjectModel3DInitTiltedBack)</l>
<l>clear_object_model_3d (ObjectModel3DLense)</l>
<l>return ()</l>
</body>
<docu id="gen_camera_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a symbolic 3D object model of a camera.</short>
<parameters>
<parameter id="CamIndex">
<default_type>integer</default_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_min>0</value_min>
</parameter>
<parameter id="CameraSetupModel">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CameraSize">
<default_type>integer</default_type>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DCam">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_camera_setup_object_model_3d">
<interface>
<ic>
<par name="CameraSetupModelID" base_type="ctrl" dimension="0"/>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
<par name="ConeLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3DCamera" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DCone" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_camera_setup_param (CameraSetupModelID, 'general', 'num_cameras', NumCameras)</l>
<c>* </c>
<c>* Consistency check:</c>
<l>if (NumCameras &lt; 1)</l>
<l>    throw ('No camera set.')</l>
<l>endif</l>
<l>if (is_number(CameraSize))</l>
<l>    if (CameraSize &lt;= 0.0)</l>
<l>        throw ('Invalid value for CameraSize. CameraSize must be positive or \'auto\'.')</l>
<l>    endif</l>
<l>elseif (CameraSize != 'auto')</l>
<l>    throw ('Invalid value for CameraSize. CameraSize must be positive or \'auto\'.')</l>
<l>endif</l>
<l>if (is_number(ConeLength))</l>
<l>    if (ConeLength &lt;= 0.0)</l>
<l>        throw ('Invalid value for ConeLength. ConeLength must be positive or \'auto\'.')</l>
<l>    endif</l>
<l>elseif (ConeLength != 'auto')</l>
<l>    throw ('Invalid value for ConeLength. ConeLength must be positive or \'auto\'.')</l>
<l>endif</l>
<c>*</c>
<l>AutoConeLength := (ConeLength == 'auto')</l>
<c>* </c>
<l>ObjectModel3DCamera := []</l>
<l>ObjectModel3DCone := []</l>
<l>AllCameras := [0:NumCameras-1]</l>
<l>for CurrentCamera := 0 to NumCameras - 1 by 1</l>
<l>    ConcatZ := []</l>
<l>    if (AutoConeLength)</l>
<l>        if (NumCameras &lt; 2)</l>
<l>            throw ('You need at least two cameras for ConeLength == auto.')</l>
<l>        endif</l>
<c>        * Intersect the line of sight of each camera with all other cameras.</c>
<l>        OtherCameras := remove(AllCameras,(find(AllCameras,CurrentCamera)))</l>
<l>        for Index := 0 to |OtherCameras|-1 by 1</l>
<l>            get_camera_setup_param (CameraSetupModelID, CurrentCamera, 'params', CamParam0)</l>
<l>            get_camera_setup_param (CameraSetupModelID, CurrentCamera, 'pose', Pose0)</l>
<l>            get_camera_setup_param (CameraSetupModelID, OtherCameras[Index], 'params', CamParam1)</l>
<l>            get_camera_setup_param (CameraSetupModelID, OtherCameras[Index], 'pose', Pose1)</l>
<c>            * Intersect the lines of sight of the camera pair.</c>
<l>            pose_invert (Pose1, PoseInvert)</l>
<l>            pose_compose (PoseInvert, Pose0, RelPose)            </l>
<l>            get_cam_par_data (CamParam0, 'cx', CX0)</l>
<l>            get_cam_par_data (CamParam0, 'cy', CY0)</l>
<l>            get_cam_par_data (CamParam1, 'cx', CX1)</l>
<l>            get_cam_par_data (CamParam1, 'cy', CY1)</l>
<l>            try</l>
<l>                intersect_lines_of_sight (CamParam0, CamParam1, RelPose, CY0, CX0, CY1, CX1, X, Y, Z, Dist)</l>
<l>            catch (Exception)</l>
<l>                throw ('Estimating a value for ConeLength automatically was not possible. Please use a number instead.')</l>
<l>            endtry</l>
<l>            ConcatZ := [ConcatZ, Z]</l>
<l>        endfor</l>
<c>        * Use the Z value of the determined coordinates as basis for the ConeLength.</c>
<l>        ConeLength := max(ConcatZ) * 1.05</l>
<l>    endif</l>
<c>    *</c>
<c>    * Create cone of sight 3D object models.</c>
<c>    * Distinguish cases with/without projection center.</c>
<l>    get_camera_setup_param (CameraSetupModelID, CurrentCamera, 'type', CameraType)</l>
<l>    if (CameraType =~ 'telecentric')</l>
<l>        gen_cone_telecentric_object_model_3d (CameraSetupModelID, CurrentCamera, ConeLength, ObjectModel3DConeTmp)</l>
<l>    else</l>
<l>        gen_cone_perspective_object_model_3d (CameraSetupModelID, CurrentCamera, ConeLength, ObjectModel3DConeTmp)</l>
<l>    endif</l>
<l>    ObjectModel3DCone := [ObjectModel3DCone,ObjectModel3DConeTmp]</l>
<c>    *</c>
<c>    * Create camera 3D object models.</c>
<l>    if (CameraSize == 'auto')</l>
<c>        * In auto mode, the camera size for all cameras</c>
<c>        * is defined by the first camera's cone length.</c>
<l>        CameraSize := ConeLength * 0.1</l>
<l>    endif</l>
<l>    gen_camera_object_model_3d (CameraSetupModelID, CurrentCamera, CameraSize, ObjectModel3DCameraTmp)</l>
<l>    ObjectModel3DCamera := [ObjectModel3DCamera,ObjectModel3DCameraTmp]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_camera_setup_object_model_3d">
<abstract lang="en_US">The procedure gen_camera_setup_object_model_3d generates 3D object models which visualize the cameras of a camera setup as well as their fields of view. 

The procedure can be used, e.g., to visualize a stereo setup with its bounding box and cameras which is particularly helpful while adjusting the bounding box. The procedure gen_bounding_box_object_model_3d creates the according 3D object model for the bounding box.

Note that if a 3D object model is no longer needed or should be overwritten, the memory has to be freed first by calling the operator clear_object_model_3d.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
* Prepare camera setup and stereo model.
read_camera_setup_model ('cam_setup_model.csm', CameraSetupModelID)
create_stereo_model (CameraSetupModelID, 'surface_fusion', [], [], StereoModelID)
set_stereo_model_image_pairs (StereoModelID, [1, 2], [0, 0])
* Estimate and set bounding box automatically.
estimate_bounding_box_3d_reconstruction (StereoModelID, 0.06, BoundingBox)
set_stereo_model_param (StereoModelID, 'bounding_box', BoundingBox)
* Create and visualize object models that represent the setup.
gen_camera_setup_object_model_3d (CameraSetupModelID, 'auto', 'auto', ObjectModel3DCamera, ObjectModel3DCone)
gen_bounding_box_object_model_3d (StereoModelID, ObjectModel3DBoundingBox)
visualize_object_model_3d (WindowHandle, [ObjectModel3DBoundingBox, ObjectModel3DCamera, ObjectModel3DCone], [], [], ['color_0', 'alpha'], ['red', 0.5], [], [],[] , Pose)</example>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_stereo_model</item>
<item>set_stereo_model_param</item>
</predecessor>
<see_also>
<item>reconstruct_surface_stereo</item>
</see_also>
<short lang="en_US">Generate 3D object models which visualize the cameras of a stereo model.</short>
<successor>
<item>visualize_object_model_3d</item>
<item>dev_inspect_ctrl</item>
<item>gen_bounding_box_object_model_3d</item>
</successor>
<parameters>
<parameter id="CameraSetupModelID">
<default_type>integer</default_type>
<description lang="en_US">Handle of the stereo model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CameraSize">
<default_type>string</default_type>
<default_value>'auto'</default_value>
<description lang="en_US">Size of represented cameras.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'auto'</item>
<item>0.01</item>
<item>0.04</item>
<item>0.08</item>
<item>0.1</item>
<item>0.4</item>
<item>0.8</item>
<item>1</item>
<item>4</item>
<item>8</item>
</values>
</parameter>
<parameter id="ConeLength">
<default_type>string</default_type>
<default_value>'auto'</default_value>
<description lang="en_US">Depth of represented fields of view. </description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'auto'</item>
<item>0.01</item>
<item>0.04</item>
<item>0.08</item>
<item>0.1</item>
<item>0.4</item>
<item>0.8</item>
<item>1</item>
<item>4</item>
<item>8</item>
</values>
</parameter>
<parameter id="ObjectModel3DCamera">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models representing cameras.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DCone">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models representing fields of view.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cone_perspective_object_model_3d" access="local">
<interface>
<ic>
<par name="CameraSetupModelID" base_type="ctrl" dimension="0"/>
<par name="CameraIndex" base_type="ctrl" dimension="0"/>
<par name="ConeLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_camera_setup_param (CameraSetupModelID, CameraIndex, 'pose', CamPose)</l>
<l>pose_to_hom_mat3d (CamPose, HomMat3D)</l>
<l>get_camera_setup_param (CameraSetupModelID, CameraIndex, 'params', CamParam)</l>
<c>* </c>
<c>* Get the lines of sight of the four corner points of the image.</c>
<c>* Scale them to the given length and transform into world coordinates.</c>
<l>Points := {[]}</l>
<c>* First corner.</c>
<l>get_line_of_sight (0, 0, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>QXT := QX / QZ * ConeLength</l>
<l>QYT := QY / QZ * ConeLength</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QXT, QYT, QZT, Qx, Qy, Qz)</l>
<l>Points.at(0) := [Qx,Qy,Qz]</l>
<c>* Second corner.</c>
<l>get_line_of_sight (CamParam[|CamParam| - 1] - 1, 0, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>QXT := QX / QZ * ConeLength</l>
<l>QYT := QY / QZ * ConeLength</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QXT, QYT, QZT, Qx, Qy, Qz)</l>
<l>Points.at(1) := [Qx,Qy,Qz]</l>
<c>* Third corner.</c>
<l>get_line_of_sight (CamParam[|CamParam| - 1] - 1, CamParam[|CamParam| - 2] - 1, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>QXT := QX / QZ * ConeLength</l>
<l>QYT := QY / QZ * ConeLength</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QXT, QYT, QZT, Qx, Qy, Qz)</l>
<l>Points.at(2) := [Qx,Qy,Qz]</l>
<c>* Fourth corner.</c>
<l>get_line_of_sight (0, CamParam[|CamParam| - 2] - 1, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>QXT := QX / QZ * ConeLength</l>
<l>QYT := QY / QZ * ConeLength</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QXT, QYT, QZT, Qx, Qy, Qz)</l>
<l>Points.at(3) := [Qx,Qy,Qz]</l>
<c>* </c>
<c>* Get camera center.</c>
<l>affine_trans_point_3d (HomMat3D, 0, 0, 0, Qx, Qy, Qz)</l>
<l>Points.at(4) := [Qx,Qy,Qz]</l>
<c>* </c>
<c>* Sort the points by coordinate direction.</c>
<l>PX := []</l>
<l>PY := []</l>
<l>PZ := []</l>
<l>for Index := 0 to 4 by 1</l>
<l>    PX := [PX,Points.at(Index)[0]]</l>
<l>    PY := [PY,Points.at(Index)[1]]</l>
<l>    PZ := [PZ,Points.at(Index)[2]]</l>
<l>endfor</l>
<l>gen_object_model_3d_from_points (PX, PY, PZ, ObjectModel3D)</l>
<c>* </c>
<c>* Set the sides of the cone.</c>
<l>Faces := []</l>
<l>Faces := [Faces,4,0,1]</l>
<l>Faces := [Faces,4,1,2]</l>
<l>Faces := [Faces,4,2,3]</l>
<l>Faces := [Faces,4,3,0]</l>
<l>set_object_model_3d_attrib_mod (ObjectModel3D, 'triangles', [], Faces)</l>
<l>return ()</l>
</body>
<docu id="gen_cone_perspective_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a 3D object model representing the view cone of a perspective camera.</short>
<parameters>
<parameter id="CameraIndex">
<default_type>integer</default_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CameraSetupModelID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ConeLength">
<default_type>integer</default_type>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_cone_telecentric_object_model_3d" access="local">
<interface>
<ic>
<par name="CameraSetupModelID" base_type="ctrl" dimension="0"/>
<par name="CameraIndex" base_type="ctrl" dimension="0"/>
<par name="ConeLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>get_camera_setup_param (CameraSetupModelID, CameraIndex, 'pose', CamPose)</l>
<l>pose_to_hom_mat3d (CamPose, HomMat3D)</l>
<l>get_camera_setup_param (CameraSetupModelID, CameraIndex, 'params', CamParam)</l>
<c>* </c>
<c>* Get the lines of sight of the four corner points of the image.</c>
<c>* Scale them to the given length and transform into world coordinates.</c>
<l>Points := {[]}</l>
<c>* First corner.</c>
<l>get_line_of_sight (0, 0, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>affine_trans_point_3d (HomMat3D, PX, PY, PZ, Qx, Qy, Qz)</l>
<l>Points.at(0) := [Qx,Qy,Qz]</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QX, QY, QZT, Qx, Qy, Qz)</l>
<l>Points.at(1) := [Qx,Qy,Qz]</l>
<c>* Second corner.</c>
<l>get_line_of_sight (CamParam[|CamParam| - 1] - 1, 0, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>affine_trans_point_3d (HomMat3D, PX, PY, PZ, Qx, Qy, Qz)</l>
<l>Points.at(2) := [Qx,Qy,Qz]</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QX, QY, QZT, Qx, Qy, Qz)</l>
<l>Points.at(3) := [Qx,Qy,Qz]</l>
<c>* Third corner.</c>
<l>get_line_of_sight (CamParam[|CamParam| - 1] - 1, CamParam[|CamParam| - 2] - 1, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>affine_trans_point_3d (HomMat3D, PX, PY, PZ, Qx, Qy, Qz)</l>
<l>Points.at(4) := [Qx,Qy,Qz]</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QX, QY, QZT, Qx, Qy, Qz)</l>
<l>Points.at(5) := [Qx,Qy,Qz]</l>
<c>* Fourth corner.</c>
<l>get_line_of_sight (0, CamParam[|CamParam| - 2] - 1, CamParam, PX, PY, PZ, QX, QY, QZ)</l>
<l>affine_trans_point_3d (HomMat3D, PX, PY, PZ, Qx, Qy, Qz)</l>
<l>Points.at(6) := [Qx,Qy,Qz]</l>
<l>QZT := ConeLength</l>
<l>affine_trans_point_3d (HomMat3D, QX, QY, QZT, Qx, Qy, Qz)</l>
<l>Points.at(7) := [Qx,Qy,Qz]</l>
<c>* </c>
<c>* Sort the points by coordinate direction.</c>
<l>PX := []</l>
<l>PY := []</l>
<l>PZ := []</l>
<l>for Index := 0 to 7 by 1</l>
<l>    PX := [PX,Points.at(Index)[0]]</l>
<l>    PY := [PY,Points.at(Index)[1]]</l>
<l>    PZ := [PZ,Points.at(Index)[2]]</l>
<l>endfor</l>
<l>gen_object_model_3d_from_points (PX, PY, PZ, ObjectModel3D)</l>
<c>* </c>
<c>* Set the sides of the cone.</c>
<l>Faces := []</l>
<l>Faces := [Faces,4,0,1,3,2]</l>
<l>Faces := [Faces,4,2,3,5,4]</l>
<l>Faces := [Faces,4,4,5,7,6]</l>
<l>Faces := [Faces,4,6,7,1,0]</l>
<l>set_object_model_3d_attrib_mod (ObjectModel3D, 'polygons', [], Faces)</l>
<l>return ()</l>
</body>
<docu id="gen_cone_telecentric_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a 3D object model representing the view cone of a telecentric camera.</short>
<parameters>
<parameter id="CameraIndex">
<default_type>integer</default_type>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CameraSetupModelID">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ConeLength">
<default_type>integer</default_type>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_confusion_matrix">
<interface>
<ic>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="PredictedClasses" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ConfusionMatrix" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure computes a confusion matrix.</c>
<c>* Therefore, it compares the classes </c>
<c>* assigned in GroundTruthLabels and PredictedClasses.</c>
<c>* The resulting confusion matrix can be </c>
<c>* visualized, returned, or both.</c>
<c>* In each case, the output can be changed </c>
<c>* via generic parameters using GenParamName and GenParamValue.</c>
<c>* For the visualization, the graphics window </c>
<c>* must be specified with WindowHandle.</c>
<c>*</c>
<l>if (|GroundTruthLabels| != |PredictedClasses|)</l>
<l>    throw('Number of ground truth labels and predicted classes must be equal.')</l>
<l>endif</l>
<c>*</c>
<c>* Set generic parameter defaults.</c>
<l>DisplayMatrix := 'absolute'</l>
<l>ReturnMatrix := 'absolute'</l>
<l>DisplayColor := 'true'</l>
<l>DisplayColumnWidth := 'minimal'</l>
<c>*</c>
<c>* Parse generic parameters.</c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>    if (GenParamName[GenParamIndex] == 'display_matrix')</l>
<c>        * Set 'display_matrix'.</c>
<l>        DisplayMatrix := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'return_matrix')</l>
<c>        * Set 'return_matrix'.</c>
<l>        ReturnMatrix := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'display_color')</l>
<c>        * Set 'display_color'.</c>
<l>        DisplayColor := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'display_column_width')</l>
<c>        * Set 'display_column_width'.</c>
<l>        DisplayColumnWidth := GenParamValue[GenParamIndex]</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>*</c>
<l>if (DisplayMatrix == 'relative' or ReturnMatrix == 'relative' or DisplayColor == 'true')</l>
<l>    CalculateRelativeMatrix := 1</l>
<l>else</l>
<l>    CalculateRelativeMatrix := 0</l>
<l>endif</l>
<c>*</c>
<c>* Calculate the confusion matrix with absolute values</c>
<c>* and the confusion matrix with relative errors.</c>
<c>* We start with an empty matrix </c>
<c>* and add the number of matching labels.</c>
<l>Classes := uniq(sort(GroundTruthLabels))</l>
<l>NumClasses := |Classes|</l>
<l>create_matrix (NumClasses, NumClasses, 0, AbsoluteMatrixID)</l>
<l>if (CalculateRelativeMatrix)</l>
<l>    create_matrix (NumClasses, NumClasses, 0, RelativeMatrixID)</l>
<l>endif</l>
<l>for ColumnMatrix := 0 to NumClasses-1 by 1</l>
<l>    Class := Classes[ColumnMatrix]</l>
<l>    ThisLabel := GroundTruthLabels [==] Class</l>
<l>    if (CalculateRelativeMatrix)</l>
<c>        * Obtain the number of ground truth labels per class.</c>
<l>        NumClassGroundTruth := sum(ThisLabel)</l>
<l>    endif</l>
<l>    for RowMatrix := 0 to NumClasses-1 by 1</l>
<c>        * Select classes for this row/column.</c>
<l>        PredictedClass := Classes[RowMatrix]</l>
<c>        * Check whether the input data </c>
<c>        * corresponds to these classes.</c>
<l>        ThisPredictedClass := PredictedClasses [==] PredictedClass</l>
<c>        * Count the number of elements where the predicted class </c>
<c>        * matches the ground truth label.</c>
<l>        NumMatches :=  sum((ThisLabel + ThisPredictedClass) [==] 2)</l>
<c>        * Set value in matrix.</c>
<l>        set_value_matrix (AbsoluteMatrixID, RowMatrix, ColumnMatrix, NumMatches)</l>
<l>        if (CalculateRelativeMatrix)</l>
<l>            if (NumClassGroundTruth &gt; 0)</l>
<l>                RelativeError := real(NumMatches)/NumClassGroundTruth</l>
<l>            else </l>
<l>                RelativeError := 0</l>
<l>            endif</l>
<l>            set_value_matrix (RelativeMatrixID, RowMatrix, ColumnMatrix, RelativeError)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<c>*</c>
<c>* Return the result.</c>
<l>if (ReturnMatrix == 'absolute')</l>
<l>    copy_matrix (AbsoluteMatrixID, ConfusionMatrix)</l>
<l>elseif (ReturnMatrix == 'relative')</l>
<l>    copy_matrix (RelativeMatrixID, ConfusionMatrix)</l>
<l>elseif (ReturnMatrix == 'none')</l>
<c>    * No matrix is returned.</c>
<l>else</l>
<l>    throw ('Unsupported mode for \'return_matrix\'')</l>
<l>endif</l>
<c>*</c>
<c>* Display the matrix.</c>
<l>if (DisplayMatrix != 'none')</l>
<c>    *</c>
<c>    * Find maximal string width and set display position parameters.</c>
<l>    StringWidths := []</l>
<c>    * Get the string width of each class.</c>
<l>    for StringIndex := 0 to |Classes|-1 by 1</l>
<l>        String := Classes[StringIndex]</l>
<l>        get_string_extents (WindowHandle, String, Ascent, Descent, StringWidth, StringHeight)</l>
<l>        StringWidths := [StringWidths, StringWidth]</l>
<l>    endfor</l>
<c>    * The columns should have a minimum width for 4 characters.</c>
<l>    get_string_extents (WindowHandle, 'test', Ascent, Descent, StringWidth, StringHeight)</l>
<l>    MaxStringWidth := max2(max(StringWidths), StringWidth)</l>
<c>    * Get the maximum string width </c>
<c>    * and resize the window accordingly.</c>
<l>    RowStart := 80 </l>
<l>    RowDistance := StringHeight + 10</l>
<l>    RowEnd := StringHeight * 7</l>
<l>    ColumnStart := 50 + MaxStringWidth</l>
<l>    ColumnOffset := 20</l>
<l>    ColumnEnd := ColumnOffset</l>
<c>    *</c>
<c>    * Adapt the window size to fit the confusion matrix.</c>
<l>    if (DisplayColumnWidth == 'minimal')</l>
<c>        * Every column of the confusion matrix is as narrow as possible </c>
<c>        * based to the respective string widths.</c>
<l>        Width := sum(StringWidths) + ColumnOffset * (NumClasses) + ColumnStart + ColumnEnd</l>
<l>    elseif (DisplayColumnWidth == 'equal')</l>
<c>        * Every column of the confusion matrix should have the same width. </c>
<c>        * based on the maximum string width.</c>
<l>        Width := (MaxStringWidth + ColumnOffset) * (NumClasses) + ColumnStart + ColumnEnd</l>
<l>    else</l>
<l>        throw('')</l>
<l>    endif</l>
<l>    Height := RowDistance * NumClasses + RowStart + RowEnd</l>
<l>    dev_set_window (WindowHandle)</l>
<l>    dev_clear_window ()</l>
<c>    * </c>
<c>    * Set reasonable limits for graphics window (adapt if necessary).</c>
<l>    WidthLimit := [450, 1920]</l>
<l>    HeightLimit := [250, 1080]</l>
<l>    if (Width &gt; WidthLimit[1] or Height &gt; HeightLimit[1])</l>
<l>        throw ('Confusion Matrix does not fit into graphics window. Please adapt font and/or size limits.')</l>
<l>    endif</l>
<l>    dev_resize_window_fit_size (0, 0, Width, Height, WidthLimit, HeightLimit)</l>
<c>    *</c>
<c>    * Get display coordinates.</c>
<c>    * Get row coordinates for display.</c>
<l>    TextRow := []</l>
<l>    for ColumnMatrix := 0 to NumClasses-1 by 1</l>
<l>        TextRow := [TextRow, [0:RowDistance:(NumClasses-1)*RowDistance]]</l>
<l>    endfor</l>
<c>    * Get column coordinates for display.</c>
<l>    TextColumn := []</l>
<l>    for Index := 0 to NumClasses-1 by 1</l>
<l>        TextColumn := [TextColumn, gen_tuple_const(NumClasses, ColumnStart)]</l>
<l>        if (DisplayColumnWidth == 'minimal')</l>
<l>            ColumnStart := ColumnStart + StringWidths[Index] + ColumnOffset</l>
<l>        elseif (DisplayColumnWidth == 'equal')</l>
<l>            ColumnStart := ColumnStart + MaxStringWidth + ColumnOffset</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Display the confusion matrix with a margin from the top.</c>
<l>    TextRow := TextRow + RowStart</l>
<c>    * Display axis titles.</c>
<l>    dev_disp_text ('Ground truth labels', 'window', 'top', 'right', 'white', 'box', 'false')</l>
<l>    dev_disp_text ('Predicted classes', 'window', 'bottom', 'left', 'white', 'box', 'false')</l>
<l>    for Index := 0 to |Classes|-1 by 1</l>
<l>        Text := Classes[Index]</l>
<c>        * Display predicted class names.</c>
<l>        Row := TextRow[Index]</l>
<l>        Column := TextColumn[0] - MaxStringWidth - ColumnOffset</l>
<l>        dev_disp_text (Text, 'window', Row, Column, 'light gray', 'box', 'false')</l>
<c>        * Display ground truth label names.</c>
<l>        Row := TextRow[0] - 25</l>
<l>        Column := TextColumn[Index*NumClasses]</l>
<l>        dev_disp_text (Text, 'window', Row, Column, 'light gray', 'box', 'false')</l>
<l>    endfor</l>
<c>    *</c>
<c>    * Get the confusion matrix values for display.</c>
<l>    if (DisplayMatrix == 'absolute')</l>
<c>        * Displayed matrix corresponds to the transposed returned matrix.</c>
<l>        transpose_matrix (AbsoluteMatrixID, AbsoluteTransposedMatrixID)</l>
<l>        get_full_matrix (AbsoluteTransposedMatrixID, MatrixText)</l>
<l>        clear_matrix (AbsoluteTransposedMatrixID)</l>
<c>        * Align the numbers right.</c>
<l>        max_matrix (AbsoluteMatrixID,'full', MatrixMaxID)</l>
<l>        get_full_matrix (MatrixMaxID, MaxValue)</l>
<l>        clear_matrix (MatrixMaxID)</l>
<l>        StringConversion:=[int(ceil(log10(MaxValue)))+'.0f']</l>
<l>        MatrixText := MatrixText $ StringConversion</l>
<l>    else</l>
<c>        * Displayed matrix corresponds to the transposed returned matrix.</c>
<l>        transpose_matrix (RelativeMatrixID, RelativeTransposedMatrixID)</l>
<l>        get_full_matrix (RelativeTransposedMatrixID, MatrixText)</l>
<l>        clear_matrix (RelativeTransposedMatrixID)</l>
<l>        MatrixText := MatrixText $ '.2f'</l>
<l>    endif</l>
<c>    * Set color for displayed confusion matrix.</c>
<l>    if (DisplayColor == 'true')</l>
<l>        tuple_gen_const (|MatrixText|, '#666666', TextColor)</l>
<c>        * Use the relative values to adapt the color of the text.</c>
<l>        transpose_matrix (RelativeMatrixID, RelativeTransposedMatrixID)</l>
<l>        get_full_matrix (RelativeTransposedMatrixID, RelativeValues)</l>
<l>        clear_matrix (RelativeTransposedMatrixID)</l>
<c>        * Set the colors and respective thresholds for the off-diagonal values. </c>
<l>        Thresholds := [0.0, 0.05, 0.1, 0.2]</l>
<l>        Colors := ['#8C4D4D', '#B33333', '#D91A1A', '#FF0000']</l>
<l>        for Index := 0 to |Thresholds|-1 by 1</l>
<l>            tuple_greater_elem (RelativeValues, Thresholds[Index], Greater)</l>
<l>            tuple_find (Greater, 1, Indices)</l>
<l>            if (Indices != -1)</l>
<l>                tuple_replace (TextColor, Indices, Colors[Index], TextColor)</l>
<l>            else</l>
<l>                break</l>
<l>            endif</l>
<l>        endfor</l>
<c>        * Set the colors and respective thresholds for the diagonal values. </c>
<l>        Thresholds := [-0.01, 0.60, 0.80, 0.90, 0.95, 0.98]</l>
<l>        Colors := ['#666666', '#508650', '#419C41', '#2BBD2B', '#15DE15', '#00FF00']</l>
<l>        for DiagonalIndex := 0 to NumClasses-1 by 1</l>
<l>            get_value_matrix (RelativeMatrixID, DiagonalIndex, DiagonalIndex, Value)</l>
<l>            for Index := 0 to |Thresholds|-1 by 1</l>
<l>                if (Value &gt; Thresholds[Index])</l>
<l>                    TextColor[DiagonalIndex*(NumClasses+1)] := Colors[Index]</l>
<l>                else</l>
<l>                    break</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endfor</l>
<l>    else</l>
<c>        * Default value for the text color.</c>
<l>        tuple_gen_const (|MatrixText|, 'white', TextColor)</l>
<l>    endif</l>
<c>    *</c>
<c>    * Display confusion matrix.</c>
<l>    dev_disp_text (MatrixText, 'window', TextRow, TextColumn, TextColor, ['box'], ['false'])</l>
<c>    *</c>
<c>    * Clean up.</c>
<l>    if (CalculateRelativeMatrix)</l>
<l>        clear_matrix (RelativeMatrixID)</l>
<l>    endif</l>
<l>    clear_matrix (AbsoluteMatrixID)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="gen_confusion_matrix">
<abstract lang="de_DE">Diese Prozedur berechnet eine Konfusionsmatrix ConfusionMatrix. Dafür vergleicht es die Label, die mit GroundTruthLabels und PredictedClasses übergeben werden. Die resultierende Konfusionsmatrix kann visualisiert werden, zurückgegeben werden oder beides. In allen diesen Fällen kann das Ergebnis mit generischen Parametern beeinflusst werden, die mit GenParamName und GenParamValue übergeben werden. Für die Visualisierung muss ein Grafikfenster mit WindowHandle übergeben werden.

Die folgenden generischen Parameter werden unterstützt:

* 'display_matrix': 'absolute' (Standardwert),'relative','none'. Dieser Parameter steuert die visualisierte Konfusionsmatrix. 'absolute' stellt die Gesamtanzahl der Kombinationen korrekte / inferiertes Label dar. Mit 'relative' wird je Klasse das Verhältnis von inferierten Labels zu den korrekten Labels dargestellt. Wenn 'none' ausgewählt wird, wird keine Konfusionsmatrix dargestellt, und die Matrix wird nur wie in 'display_matrix' spezifiziert zurückgegeben.

* 'return_matrix': 'absolute' (default), 'relative', 'none'. Dieser Parameter steuert die zurückgegebene Konfusionsmatrix. Die Parameter haben die selbe Bedeutung und das selbe Verhalten wie für 'display_matrix'.

* 'display_color': 'true' (default), 'false'. Dieser Parameter bestimmt, ob die visualisierten Werte der Konfusionsmatrix farbig dargestellt werden oder nicht. Wenn er auf 'true' gesetzt wird, werden die Werte auf der Diagonal von einem blassen grau (relatives Verhältnis &lt; 0.6) bis hin zu grün (relatives Verhältnis &gt; 0.98, was auf ein gutes Ergebnis hindeutet) dargestellt. Die Werte abseits der Diagonale werden von einem blassen grau (relatives Verhältnis &lt; 0.02, was auf ein gutes Ergebnis hindeutet) bis hin zu rot (relatives Verhältnis == 0) dargestellt. Wenn der Parameter auf 'false' gesetzt wird, werden alle Werte in weiß dargestellt. 

* 'display_column_width': 'minimal' (default), 'equal'. Dieser Parameter bestimmt, ob die Spalten der Konfusionsmatrix equidistant dargestellt werden oder nicht. Mit 'equal'  bestimmt der längste Klassenname die Breite aller Spalten, damit die Diagonale gut sichtbar ist. Mit 'minimal' wird die Breite jeder Spalte durch den jeweiligen Klassennamen festgelegt.

Diese Prozedur gibt ein Handle zurück, wenn 'return_matrix' nicht 'none' ist. Der Speicher, der für diese Matrix alloziert wird, sollte mit clear_matrix freigegeben werden, wenn die Matrix nicht mehr gebraucht wird.</abstract>
<abstract lang="en_US">This procedure computes a confusion matrix. Therefore, it compares the classes assigned in GroundTruthLabels and PredictedClasses. The resulting confusion matrix can be visualized, returned, or both. In each case, the output can be changed via generic parameters using GenParamName and GenParamValue. For the visualization, the graphics window must be specified with WindowHandle.

The following generic parameters are supported:

* 'display_matrix': 'absolute' (default),'relative','none'. Parameters for the confusion matrix displayed by this procedure. 'absolute' displays the total counted combinations of inferred / ground truth labels. 'relative' means for a given class the number of inferred images are given in ratio to the number of images having this ground truth label. If 'none' is chosen, no visualization is performed, and the confusion matrix is only returned as specified by 'return_matrix'.

* 'return_matrix': 'absolute' (default), 'relative', 'none'. Parameters for the confusion matrix returned from this procedure. The parameters have the same meaning and behavior as for 'display_matrix'.

* 'display_color': 'true' (default), 'false'. This parameter determines if the entries of the confusion matrix are shown in different colors or not. If it is set to 'true', the diagonal values are displayed in colors from dim gray (relative match &lt; 0.6) to green (relative match &gt; 0.98, suggesting a good result), while the off-diagonal values are displayed in colors from dim gray (relative match == 0, suggesting a good result) to red (relative match &gt; 0.2). If the parameter is set to 'false', all entries are shown in white.

* 'display_column_width': 'minimal' (default), 'equal'. This parameter determines if the columns of the confusion matrix are shown equidistantly or not. 'equal' means the width is adapted to the longest class name in order to facilitate the vision of the diagonal. 'minimal' sets the width of every column is according to the respective length of the class name.

This procedure returns a handle if 'return_matrix' is not set to 'none'. This handle should be cleared using clear_matrix when it is not needed anymore, to free the allocated memory.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Klassifikation</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="de_DE">Visualisieren und Zurückgeben der Konfusionsmatrix für die übergebenen Labels.
</short>
<short lang="en_US">Visualize and return the confusion matrix for the given labels. </short>
<successor>
<item>get_full_matrix</item>
<item>get_value_matrix</item>
<item>sum_matrix</item>
</successor>
<parameters>
<parameter id="ConfusionMatrix">
<default_type>integer</default_type>
<description lang="de_DE">Die resultierende Konfusionsmatrix.</description>
<description lang="en_US">The resulting confusion matrix.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>matrix</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<description lang="de_DE">Name des generischen Parameters.</description>
<description lang="en_US">Name of the generic parameter.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.name</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'display_matrix'</item>
<item>'return_matrix'</item>
<item>'display_color'</item>
<item>'display_column_width'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<description lang="de_DE">Wert des generischen Parameters.</description>
<description lang="en_US">Value of the generic parameter.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'absolute'</item>
<item>'relative'</item>
<item>'true'</item>
<item>'false'</item>
<item>'minimal'</item>
<item>'equal'</item>
<item>'none'</item>
</values>
</parameter>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="de_DE">Die tatsächlich korrekten Labels.</description>
<description lang="en_US">The correct labels.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="PredictedClasses">
<default_type>string</default_type>
<description lang="de_DE">Die vom Klassifikator vorhergesagten Klassen.</description>
<description lang="en_US">The classes as inferred by the classifier.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="de_DE">Handle des Grafikfensters.</description>
<description lang="en_US">Handle of the window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_current_setup_moving_cam_object_model_3d">
<interface>
<ic>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="OM3DToolOrigin" base_type="ctrl" dimension="0"/>
<par name="OM3DBase" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
<par name="OM3DTool" base_type="ctrl" dimension="0"/>
<par name="OM3DPlane" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure visualizes the camera, tool, and plane in their</c>
<c>* current positions.</c>
<c>*</c>
<l>read_message_tuple (HandEyeCalibData, 'ToolInCamPose', ToolInCamPose)</l>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (HandEyeCalibData, 'PlaneInBasePose0', PlaneInBasePose0)</l>
<c>*</c>
<l>if (CameraSize &lt;= 0)</l>
<l>    throw ('CameraSize should be &gt; 0')</l>
<l>endif</l>
<c>*</c>
<c>* Visualize current camera and tool position.</c>
<c>*</c>
<c>* Get the intersection of the optical axis of the camera and the plane</c>
<l>pose_invert (ToolInBasePose, BaseInToolPose)</l>
<l>pose_compose (BaseInToolPose, PlaneInBasePose0, PlaneInToolPose)</l>
<l>pose_compose (ToolInCamPose, PlaneInToolPose, PlaneInCamPose)</l>
<l>get_cam_par_data (CamParam, 'cx', CX)</l>
<l>get_cam_par_data (CamParam, 'cy', CY)</l>
<l>image_points_to_world_plane (CamParam, PlaneInCamPose, CY, CX, 'm', OptAxisPlaneX, OptAxisPlaneY)</l>
<c>* Transform to camera coordinates</c>
<l>pose_to_hom_mat3d (PlaneInCamPose, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, OptAxisPlaneX, OptAxisPlaneY, 0, OptAxisCamX, OptAxisCamY, OptAxisCamZ)</l>
<l>ConeLength := OptAxisCamZ*1.1</l>
<c>* If the optical axis does not intersect the plane, we still want to visualize the camera.</c>
<l>if (ConeLength &lt;= 0.0)</l>
<l>    ConeLength := CameraSize</l>
<l>endif</l>
<l>gen_camera_and_tool_moving_cam_object_model_3d (ToolInCamPose, ToolInBasePose, CameraSize, ConeLength, OM3DToolOrigin, CamParam, OM3DCamera, OM3DTool)</l>
<c>*</c>
<c>* Create 3D object model of plane.</c>
<l>FactorBorder := 1.5</l>
<l>gen_ground_plane_object_model_3d (OM3DTool, OM3DCamera, OM3DBase, FactorBorder, PlaneInBasePose0, OM3DPlane)</l>
<l>return ()</l>
</body>
<docu id="gen_current_setup_moving_cam_object_model_3d">
<abstract lang="en_US">This procedure generates the 3D object models for the camera, robot's tool and plane in their current positions.

CameraSize determines the size of generated 3D object model of the camera.
ToolInBasePose is the current position of the robot's tool. HandEyeCalibData must contain the ToolInCamPose and CamParam as obtained through hand-eye calibration, as well as the PlaneInBasePose.

The input parameters OM3DToolOrigin and OM3DBase are 3D object models of the robot's tool and base respectively.

The output parameter OM3DCamera is a 3D object model of the camera and its cone. OM3DTool is the 3D object model of the robot's tool in its current position. OM3DPlane is the 3D model of the plane.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>prepare_moving_cam_for_model_creation</item>
<item>gen_moving_cam_robot_3d</item>
</predecessor>
<short lang="en_US">Generate 3D object models for the camera, robot's tool and plane.</short>
<parameters>
<parameter id="CameraSize">
<default_type>real</default_type>
<description lang="en_US">Visualization factor.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DBase">
<default_type>integer</default_type>
<description lang="en_US">3D models representing the robot's base.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<description lang="en_US">3D model of the camera and its cone.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DPlane">
<default_type>integer</default_type>
<description lang="en_US">3D model of the plane.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DTool">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's tool in its current position.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DToolOrigin">
<default_type>integer</default_type>
<description lang="en_US">Initial 3D object model of the robot's tool.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Pose of the tool in the base coordinate system.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_current_setup_stationary_cam_object_model_3d">
<interface>
<ic>
<par name="ArrowThickness" base_type="ctrl" dimension="0"/>
<par name="ArrowLength" base_type="ctrl" dimension="0"/>
<par name="CameraSize" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
<par name="OM3DPlane" base_type="ctrl" dimension="0"/>
<par name="OM3DBase" base_type="ctrl" dimension="0"/>
<par name="OM3DToolOrigin" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure generates the 3D object models of the camera and its</c>
<c>* cone, the plane, the robot's base and the robot's tool at its</c>
<c>* initial position.</c>
<c>*</c>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (HandEyeCalibData, 'PlaneInCamPose0', PlaneInCamPose0)</l>
<l>read_message_tuple (HandEyeCalibData, 'BaseInCamPose', BaseInCamPose)</l>
<c>*</c>
<c>* Visualize base and tool in the origin.</c>
<l>gen_robot_tool_and_base_object_model_3d (ArrowThickness, ArrowLength, OM3DToolOrigin, OM3DBase)</l>
<c>* Visualize camera.</c>
<l>get_cam_par_data (CamParam, 'cx', CX)</l>
<l>get_cam_par_data (CamParam, 'cy', CY)</l>
<l>image_points_to_world_plane (CamParam, PlaneInCamPose0, CY, CX, 'm', OptAxisPlaneX, OptAxisPlaneY)</l>
<l>pose_to_hom_mat3d (PlaneInCamPose0, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, OptAxisPlaneX, OptAxisPlaneY, 0, OptAxisCamX, OptAxisCamY, OptAxisCamZ)</l>
<l>ConeLength := OptAxisCamZ*1.1</l>
<c>* If the optical axis does not intersect the plane, we still want to visualize the camera.</c>
<l>if (ConeLength &lt;= 0.0)</l>
<l>    ConeLength := CameraSize</l>
<l>endif</l>
<l>create_pose (0, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', IdentityPose)</l>
<l>create_camera_setup_model (1, CameraSetupModelID)</l>
<l>set_camera_setup_cam_param (CameraSetupModelID, 0, [], CamParam, IdentityPose)</l>
<l>gen_camera_setup_object_model_3d (CameraSetupModelID, CameraSize, ConeLength, OM3DCameraOrigin, OM3DConeOrig)</l>
<l>clear_camera_setup_model (CameraSetupModelID)</l>
<l>OM3DCameraOrigin := [OM3DCameraOrigin, OM3DConeOrig]</l>
<l>pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>rigid_trans_object_model_3d (OM3DCameraOrigin, CamInBasePose, OM3DCamera)</l>
<l>clear_object_model_3d (OM3DCameraOrigin)</l>
<c>*</c>
<c>* Create 3D object model of plane.</c>
<l>FactorBorder := 1.5</l>
<l>pose_compose (CamInBasePose, PlaneInCamPose0, PlaneInBasePose)</l>
<l>gen_ground_plane_object_model_3d (OM3DToolOrigin, OM3DCamera, OM3DBase, FactorBorder, PlaneInBasePose, OM3DPlane)</l>
<l>return ()</l>
<c></c>
</body>
<docu id="gen_current_setup_stationary_cam_object_model_3d">
<abstract lang="en_US">This procedure generates the 3D object model for the camera, the plane, the robot's base and the robot's tool in their positions. A stationary camera setup is assumed.

The parameters CameraSize, ArrowThickness and ArrowLength determine the size of generated 3D object models.HandEyeCalibData must contain the BaseInCamPose and CamParam as obtained through hand-eye calibration, as well as the PlaneInBasePose. 

The output parameter OM3DCamera is the 3D object models of the camera and its cone. OM3DPlane is the 3D object of the plane. OM3DBase is the 3D object models defining the robot's base; a lower plane as well as a coordinate system represent the current position of the base. OM3DToolOrigin is the coordinate system at the origin of the robot's tool.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate 3D object models for the camera, the plane, the robot's base and the robot's tool in a stationary camera setup.</short>
<parameters>
<parameter id="ArrowLength">
<default_type>real</default_type>
<description lang="en_US">Length of the arrows.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowThickness">
<default_type>real</default_type>
<description lang="en_US">Thickness of the arrows.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="CameraSize">
<default_type>real</default_type>
<description lang="en_US">Size of the 3D object model of the camera.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DBase">
<default_type>integer</default_type>
<description lang="en_US">3D models representing the robot's base.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<description lang="en_US">3D model of the camera and its cone.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DPlane">
<default_type>integer</default_type>
<description lang="en_US">3D model of the plane.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DToolOrigin">
<default_type>integer</default_type>
<description lang="en_US">3D models representing the robot's tool.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_dl_classifier_heatmap">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="HeatmapRegions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="DLClassifierHandle" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure generates a heatmap for the Image which is classified</c>
<c>* with the deep learning classifier DLClassifierHandle. The heatmap can</c>
<c>* be visualized and is returned in HeatMapRegions. The procedure </c>
<c>* can be adjusted with generic parameters using GenParamName and GenParamValue.</c>
<c>*</c>
<c>* Set default parameters.</c>
<l>FeatureSize := 30    </l>
<l>SamplingSize := 5</l>
<l>DisplayHeatmap := true</l>
<c></c>
<c>*</c>
<c>* Parse the input parameters.</c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>    if (GenParamName[GenParamIndex] == 'feature_size')</l>
<c>        * Set 'feature_size'.</c>
<l>        FeatureSize := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'sampling_size')</l>
<c>        * Set 'sampling_size'.</c>
<l>        SamplingSize := GenParamValue[GenParamIndex]   </l>
<l>    elseif (GenParamName[GenParamIndex] == 'display_heatmap')</l>
<c>        * Set 'display_heatmap'.</c>
<l>        DisplayHeatmap := GenParamValue[GenParamIndex]</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>*</c>
<c>* Check the input parameters.</c>
<l>if (SamplingSize &lt; 0)</l>
<l>    throw ('The "sampling_size" (' + SamplingSize + ') must be greater than zero.')</l>
<l>endif</l>
<l>if (FeatureSize &lt; 0)</l>
<l>    throw ('The "feature_size" (' + FeatureSize + ') must be greater than zero.')</l>
<l>endif</l>
<l>if (SamplingSize &gt;= FeatureSize)</l>
<l>    throw ('The "sampling_size" (' + SamplingSize + ') must be smaller than the "feature_size" (' + FeatureSize + ')')</l>
<l>endif</l>
<c>*</c>
<c>* Get the predicted class and its confidence </c>
<c>* when classifying the original (unoccluded) image.</c>
<l>apply_dl_classifier (Image, DLClassifierHandle, DLClassifierResultHandle)</l>
<l>get_dl_classifier_result (DLClassifierResultHandle, 'all', 'confidences', OriginalConfidence) </l>
<l>get_dl_classifier_result (DLClassifierResultHandle, 'all', 'predicted_classes', OriginalPredictedClass)</l>
<l>clear_dl_classifier_result (DLClassifierResultHandle)</l>
<c></c>
<c></c>
<l>get_system ('clip_region', ClipRegionSettingBefore)</l>
<l>set_system ('clip_region', 'false')</l>
<c>*</c>
<c>* Generate a set of regions to be occluded. </c>
<c>* Depending on the values of feature_size and sampling_size,</c>
<c>* these regions may overlap.</c>
<l>get_image_size (Image, Width, Height)</l>
<l>Shift := SamplingSize/2</l>
<l>gen_grid_region (RegionGrid, SamplingSize, SamplingSize, 'points', Width-Shift, Height-Shift)</l>
<l>get_region_points (RegionGrid, CenterRows, CenterColumns)</l>
<l>NumRegions := |CenterRows|</l>
<l>gen_circle (OccludedRegions, CenterRows+Shift, CenterColumns+Shift, gen_tuple_const(NumRegions, FeatureSize/2))</l>
<c>*</c>
<c>* Generate and classify the occluded images.</c>
<l>Confidences := []</l>
<l>decompose3 (Image, ImageR, ImageG, ImageB)</l>
<l>intensity (OccludedRegions, ImageR, MeanRed, DeviationRed)</l>
<l>intensity (OccludedRegions, ImageG, MeanGreen, DeviationGreen)</l>
<l>intensity (OccludedRegions, ImageB, MeanBlue, DeviationBlue)</l>
<l>get_dl_classifier_param (DLClassifierHandle, 'batch_size', BatchSize)</l>
<l>for BatchIndex := 0 to int(NumRegions / BatchSize) by 1</l>
<l>    gen_empty_obj (ImagesOccluded)</l>
<l>    tuple_gen_sequence (BatchIndex*BatchSize+1, min([(BatchIndex+1)*BatchSize,NumRegions]), 1, BatchIndices)</l>
<l>    for Index := 0 to |BatchIndices|-1 by 1</l>
<l>        select_obj (OccludedRegions, OccludedRegion, BatchIndices[Index])  </l>
<l>        paint_region (OccludedRegion, Image, ImageOccluded, [MeanRed[BatchIndices[Index]-1], MeanGreen[BatchIndices[Index]-1], MeanBlue[BatchIndices[Index]-1]], 'fill')</l>
<l>        concat_obj (ImagesOccluded, ImageOccluded, ImagesOccluded)  </l>
<l>    endfor</l>
<c>    *</c>
<c>    * For each occluded image, get the confidence </c>
<c>    * for the predicted class of the unoccluded image.</c>
<l>    count_obj (ImagesOccluded, NumImagesOccluded)</l>
<l>    if (NumImagesOccluded &gt; 0)</l>
<l>        apply_dl_classifier (ImagesOccluded, DLClassifierHandle, DLClassifierResultHandle)</l>
<l>        for IndexOccluded := 0 to NumImagesOccluded-1 by 1</l>
<l>            get_dl_classifier_result (DLClassifierResultHandle, IndexOccluded, 'predicted_classes', PredictedClass)</l>
<l>            get_dl_classifier_result (DLClassifierResultHandle, IndexOccluded, 'confidences', Confidence)</l>
<l>            Confidences := [Confidences, Confidence[find(PredictedClass, OriginalPredictedClass)]]</l>
<l>        endfor</l>
<l>        clear_dl_classifier_result (DLClassifierResultHandle)</l>
<l>    endif</l>
<l>endfor</l>
<c>*</c>
<c>* Since it is too expensive to compute the confidence value </c>
<c>* for each individual pixel, we work with a subsampling of the image. </c>
<c>* The distance between two sampling points is controlled </c>
<c>* by the parameter 'sampling_size'. For each sampling point, </c>
<c>* we average over the confidence values of all images </c>
<c>* which were occluded with a regions to which this point belongs.</c>
<l>tuple_gen_const (NumRegions, 0, PartitionConfidences)</l>
<l>for PartIndex := 0 to NumRegions-1 by 1</l>
<l>    get_region_index (OccludedRegions, int(CenterRows[PartIndex]), int(CenterColumns[PartIndex]), ConfidenceIndices)</l>
<l>    PartitionConfidences[PartIndex]:= mean(Confidences[ConfidenceIndices - 1])</l>
<l>endfor</l>
<c>*  </c>
<c>* Compute the deviation and the maximum deviation.</c>
<l>DeviationsFromMean:= abs(mean(Confidences) - PartitionConfidences)</l>
<l>MaxDeviation:= max(DeviationsFromMean)</l>
<c>*</c>
<c>* The heatmap categorized into 'bins'. The regions </c>
<c>* where the deviation is highest are in the first bin, </c>
<c>* the regions where the deviation is lowest are in the last bin.</c>
<l>NumBins := 10</l>
<l>Step := 1/real(NumBins)</l>
<l>End := 1-(NumBins-1) * Step</l>
<l>gen_empty_obj (HeatmapRegions)</l>
<l>partition_rectangle (Image, Partition, SamplingSize, SamplingSize)</l>
<l>for Factor := 1 to End by -Step</l>
<l>    Lesser := DeviationsFromMean [&lt;=] MaxDeviation*Factor</l>
<l>    Greater := DeviationsFromMean [&gt;] MaxDeviation*(Factor-0.2)</l>
<l>    IndicesInBin := find(Lesser + Greater, 2)    </l>
<l>    if (IndicesInBin != -1)</l>
<l>        select_obj (Partition, PartsSelected, IndicesInBin+1)</l>
<l>        union1 (PartsSelected, HeatmapRegion)</l>
<l>    else</l>
<l>        gen_empty_region (HeatmapRegion)</l>
<l>    endif</l>
<l>    concat_obj (HeatmapRegions, HeatmapRegion, HeatmapRegions)</l>
<l>endfor</l>
<l>dev_get_preferences ('suppress_handled_exceptions_dlg', SuppressHandledExceptionsDlg)</l>
<l>dev_set_preferences ('suppress_handled_exceptions_dlg', 'true')</l>
<c>*</c>
<c>* Visualize the heatmap.</c>
<l>if (DisplayHeatmap)</l>
<l>    dev_set_window (WindowHandle)</l>
<l>    dev_clear_window ()</l>
<l>    get_image_size (Image, WidthImage, HeightImage)</l>
<l>    dev_set_part (0, 0, HeightImage-1, WidthImage-1)</l>
<l>    dev_display (Image)</l>
<c>    * Generate a color palette from red to yellow with 66% transparency</c>
<l>    Colors:=['#ff0000','#ff3300','#ff6600','#ff9900','#ffcc00', '#ffff00'] + '66'</l>
<l>    for BinIndex := 1 to 5 by 1</l>
<l>        select_obj (HeatmapRegions, BinRegion, BinIndex)</l>
<l>        dev_set_color (Colors[BinIndex])</l>
<l>        dev_display (BinRegion) </l>
<l>    endfor</l>
<l>    dev_get_preferences ('suppress_handled_exceptions_dlg', SuppressHandledExceptionsDlg)</l>
<l>endif</l>
<c></c>
<l>set_system ('clip_region', ClipRegionSettingBefore)</l>
<l>return ()</l>
</body>
<docu id="gen_dl_classifier_heatmap">
<abstract lang="de_DE">Diese Prozedur generiert eine Heatmap, indem der Deep-Learning-Klassifikator DLClassifierHandle auf das Bild Image angewendet wird. Die Heatmap wird in HeatmapRegions zurückgegeben und bei Bedarf visualisiert. Die Prozedur kann mit generischen Parametern (GenParamName und GenParamValue) konfiguriert werden. Beachten Sie, dass die Bilder für die Berechnung der Heatmap vorverarbeitet werden müssen,  z.B. mit der Prozedur preprocess_dl_classifier_images. 

Die Heatmap kann den Benutzer dabei unterstützen, zu verstehen, welcher Teils des Bildes für die Entscheidung des Klassifikators wichtig war. Die Heatmap wird berechnet, indem mehrere modifizierte Bilder erzeugt werden, auf denen jeweils ein Teil des Bildes ausgegraut ist. Jedes dieser Bilder wird klassifiziert und die dadurch erhaltene Konfidenz mit der Konfidenz des unveränderten Bildes verglichen. Der Unterschied zwischen diesen beiden Werten wird in der Heatmap dargestellt: Ein roter Bereich stellt einen hohen Unterschied dar, orange repräsentiert eine mittlere Änderung, gelb eine kleine. Wenn keine Farbe dargestellt wird, ist die Konfidenz nahezu oder gänzlich unverändert. In den ausgegebenen HeatmapRegions sind Regionen nach der Größe der Änderung der Konfidenz angeordnet. 

Die Heatmap ist ein Werkzeug, mit dem man die Entscheidungen eines Klassifikators besser nachvollziehen kann. Sie ist im Allgemeinen nicht als Segmentierungstool geeignet. 

Die folgenden generischen Parameter stehen zur Verfügung:

* 'display_heatmap':  'true' (Standard), 'false'. Kontrolliert, ob die Heatmap angezeigt wird.

* 'feature_size': die Größe einer Region, von der angenommen wird, dass sie für die Klassifikation ausschlaggebend ist. Der Standardwert ist '30'.

* 'sampling_size': ist die Distanz zwischen zwei Punkten, an denen der Wert der Heatmap berechnet und dargestellt wird. Der Standardwert ist '5'.
</abstract>
<abstract lang="en_US">This procedure generates a heatmap for an Image which is classified with the deep learning classifier DLClassifierHandle. The heatmap is returned in HeatmapRegions and can optionally be visualized. The procedure can be adjusted with generic parameters using GenParamName and GenParamValue. Note that the Image needs to be preprocessed for the computation of the heatmap, for example using preprocess_dl_classifier_images.

The heatmap can indicate parts of the image which are important for the decision of the classifier. To compute the heatmap, several new images are created by partially occluding (graying out) a certain region of the original image.  For each modified image is classified and the resulting confidence value is compared with the originally one. The deviation of these two values is visualized: Red represents a region where the deviation is high, orange represents a medium deviation, yellow a minor one. If no color is displayed, the confidence values are (almost) not affected by the occlusions. In HeatmapRegions, the regions are ordered accordingly. 

The heatmap should be used as a tool for better understanding classification results. It is not recommended to use it for segmentation. 

The following generic parameters are available:

* 'display_heatmap':  'true' (default), 'false'. Controls whether or not the heatmap is displayed by this procedure.

* 'feature_size': should be set to the expected size (diameter) of the feature/defect that you want to detect. The default is '30'.

* 'sampling_size': represents the distance between two sampling points a which the heatmap is evaluated. The sampling_size must be smaller than the feature_size. The default is '5'.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Klassifikation</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Visualize and return the heatmap of a deep learning classification.</short>
<parameters>
<parameter id="DLClassifierHandle">
<default_type>integer</default_type>
<description lang="de_DE">Der auf Deep Learning basierte Klassifikator.</description>
<description lang="en_US">The deep-learning-based classifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_classifier</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="de_DE">Name des generischen Parameters.</description>
<description lang="en_US">Name of the generic parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.name</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
<values>
<item>'feature_size'</item>
<item>'sampling_size'</item>
<item>'display_heatmap'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>integer</default_type>
<description lang="de_DE">Wert des generischen Parameters.</description>
<description lang="en_US">Value of the generic parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
<values>
<item>5</item>
<item>10</item>
<item>15</item>
<item>20</item>
<item>30</item>
<item>50</item>
<item>75</item>
<item>100</item>
<item>'true'</item>
<item>'false'</item>
</values>
</parameter>
<parameter id="HeatmapRegions">
<description lang="de_DE">Die berechnete Heatmap</description>
<description lang="en_US">The regions of the heatmap.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
<parameter id="Image">
<description lang="de_DE">Das Bild, dessen Heatmap berechnet wird.</description>
<description lang="en_US">The image for which the heatmap is computed.</description>
<multichannel>true</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="de_DE">Handle des Grafikfensters, in dem die Heatmap dargestellt wird.</description>
<description lang="en_US">Handle of the window in which the heatmap is displayed.</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_dummy_objects" access="local">
<interface>
<oo>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c>* </c>
<c>* Create dummy objects for the feature calculation</c>
<c>* (may be used to determine the lengths of the</c>
<c>* vectors etc.).</c>
<c>* </c>
<l>gen_image_const (Image, 'byte', 3, 3)</l>
<l>compose3 (Image, Image, Image, Image)</l>
<l>get_domain (Image, Region)</l>
<l>return ()</l>
</body>
<docu id="gen_dummy_objects">
<abstract lang="en_US">Generate a dummy image and region.

This is an auxiliary procedure for get_feature_lengths, get_feature_names, query_feature_names_by_group, and query_feature_group_names.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a dummy image and region that are, e.g., used to determine the lengths of the feature vectors in get_feature_lengths.</short>
<parameters>
<parameter id="Image">
<description lang="en_US">Dummy image.</description>
<multichannel>true</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
</type_list>
</parameter>
<parameter id="Region">
<description lang="en_US">Dummy region.</description>
<multivalue>false</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_ground_plane_object_model_3d">
<interface>
<ic>
<par name="OM3DTool" base_type="ctrl" dimension="0"/>
<par name="OM3DCamera" base_type="ctrl" dimension="0"/>
<par name="OM3DBase" base_type="ctrl" dimension="0"/>
<par name="FactorBorder" base_type="ctrl" dimension="0"/>
<par name="PlaneInBasePose" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DPlane" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure generates the 3D object model of </c>
<c>* the plane on which objects are matched and grasped. </c>
<c>*</c>
<l>XBase := []</l>
<l>YBase := []</l>
<l>ZBase := []</l>
<c>* Extent of tool in base coordinates.</c>
<l>get_extent_by_axis (OM3DTool, XBase, YBase, ZBase, XBase, YBase, ZBase)</l>
<c>* Extent of camera in base coordinates.</c>
<l>get_extent_by_axis (OM3DCamera, XBase, YBase, ZBase, XBase, YBase, ZBase)</l>
<c>* Extent of base in base coordinates.</c>
<l>get_extent_by_axis (OM3DBase, XBase, YBase, ZBase, XBase, YBase, ZBase)</l>
<c>*</c>
<c>* Joint bounding box.</c>
<l>MinXt := min(XBase)</l>
<l>MinYt := min(YBase)</l>
<l>MinZt := min(ZBase)</l>
<l>MaxXt := max(XBase)</l>
<l>MaxYt := max(YBase)</l>
<l>MaxZt := max(ZBase)</l>
<l>Min := [MinXt, MinYt, MinZt]</l>
<l>Max := [MaxXt, MaxYt, MaxZt]</l>
<c>*</c>
<c>* Joint bounding box extended by a factor of FactorBorder.</c>
<l>MinT := Max*(1.0-FactorBorder)/2.0 + Min*(1.0+FactorBorder)/2.0</l>
<l>MaxT := Max*(1.0+FactorBorder)/2.0 + Min*(1.0-FactorBorder)/2.0</l>
<l>BoundingBox := [MinT, MaxT]</l>
<c>*</c>
<c>* Get the eight corner points of the bounding box from the min/max representation.</c>
<l>get_bounding_box_points_from_min_max (BoundingBox, PXBB, PYBB, PZBB)</l>
<c></c>
<c>* Transform to plane coordinates (z is direction of the normal of the plane).</c>
<l>pose_invert (PlaneInBasePose, BaseInPlanePose)</l>
<l>pose_to_hom_mat3d (BaseInPlanePose, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, PXBB, PYBB, PZBB, PX, PY, PZ)</l>
<c>*</c>
<c>* Get outline of projection onto the plane.</c>
<l>Qx := min(PX)</l>
<l>Qx1 := max(PX)</l>
<l>Qy := min(PY)</l>
<l>Qy1 := max(PY)</l>
<l>XPlane := [Qx, Qx, Qx1, Qx1]</l>
<l>YPlane := [Qy, Qy1, Qy1, Qy]</l>
<l>tuple_gen_const (4, 0, ZPlane)</l>
<c>*</c>
<c>* Transform back to base coordinates.</c>
<l>pose_to_hom_mat3d (PlaneInBasePose, HomMat3D1)</l>
<l>affine_trans_point_3d (HomMat3D1, XPlane, YPlane, ZPlane, Qx2, Qy2, Qz)</l>
<c>*</c>
<c>* Generate the visualization.</c>
<l>gen_object_model_3d_from_points (Qx2, Qy2, Qz, OM3DPlane)</l>
<l>Faces := []</l>
<l>Faces := [Faces,4,0,1,2,3]</l>
<l>set_object_model_3d_attrib_mod (OM3DPlane, 'polygons', [], Faces)</l>
<c>*</c>
<l>return ()</l>
</body>
<docu id="gen_ground_plane_object_model_3d">
<abstract lang="en_US">This procedure generates the 3D object model of the plane, on which we attempt to match and grip.
The input parameters OM3DTool, OM3DCamera, and OM3DBase are the respective 3D object models of the robot's tool, the camera, and the robot's base. FactorBorder controls the extent of the visualized plane. PlaneInBasePose is the adapted pose of the plane in the base coordinate system.
The output parameter OM3DPlane is the 3D object model of the plane.
</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate the 3D object model of the plane.</short>
<parameters>
<parameter id="FactorBorder">
<default_type>real</default_type>
<description lang="en_US">Extent of the plane.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DBase">
<default_type>integer</default_type>
<description lang="en_US">3D models representing the robot's base.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DCamera">
<default_type>integer</default_type>
<description lang="en_US">3D model of the camera and its cone.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DPlane">
<default_type>integer</default_type>
<description lang="en_US">3D model of the plane.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DTool">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's tool in its current position.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PlaneInBasePose">
<default_type>real</default_type>
<description lang="en_US">Pose of the plane.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_matching_object_model_3d">
<interface>
<ic>
<par name="ModelID" base_type="ctrl" dimension="0"/>
<par name="ObjectHeight" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DModel" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure generates a 3D model from a shape model for</c>
<c>* visualization for a known (rectified) matching plane. </c>
<c>*</c>
<c>* The 3D model consists of the model-contours transformed to</c>
<c>* their real world size. The origin of the 3D model coordinate system</c>
<c>* lies in the origin of the input shape model with the z-axis</c>
<c>* pointing towards the camera. The model contours are displayed</c>
<c>* twice, at z = 0 and z = ObjectHeight. </c>
<c>*</c>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (Poses, 'MatchingPlaneInCamPose', MatchingPlaneInCamPose)</l>
<l>read_message_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage == 'true' or RectifyImage = 'only_rectify' or RectifyImage = 'align_and_rectify')</l>
<l>    read_message_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>endif</l>
<c>*</c>
<c>* Get shape model contours.</c>
<l>get_shape_model_contours (ModelContours, ModelID, 1)</l>
<l>count_obj (ModelContours, Number)</l>
<l>ModelRows := []</l>
<l>ModelCols := []</l>
<l>for Index := 1 to Number by 1</l>
<l>    select_obj (ModelContours, ObjectSelected, Index)</l>
<l>    get_contour_xld (ObjectSelected, Row1, Col1)</l>
<l>    ModelRows := [ModelRows, Row1]</l>
<l>    ModelCols := [ModelCols, Col1]</l>
<l>endfor</l>
<c>* Obtain real world size (col = x, row = y), centered around the shape model origin (0,0).</c>
<l>if (RectifyImage == 'true' or RectifyImage = 'only_rectify' or RectifyImage = 'align_and_rectify')</l>
<l>    PX := ModelCols*ScaleRectification</l>
<l>    PY := ModelRows*ScaleRectification</l>
<l>else</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, ModelRows, ModelCols, 'm', PXPlane, PYPlane)</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, 0, 0, 'm', PXPlaneOrig, PYPlaneOrig)</l>
<l>    PX := PXPlane - PXPlaneOrig</l>
<l>    PY := PYPlane - PYPlaneOrig</l>
<l>endif</l>
<c>* Display the contours twice, once in the plane, once above.</c>
<l>tuple_gen_const (|PY|, 0, PZ1)</l>
<l>tuple_gen_const (|PY|, ObjectHeight, PZ2)</l>
<c>* Transform from plane to model coordinate system. The plane</c>
<c>* coordinate system has previously been adapted such that its </c>
<c>* z-axis points away from the camera.</c>
<l>create_pose (0, 0, ObjectHeight, 180, 0, 0, 'Rp+T', 'gba', 'point', PlanePartRectToModelPose)</l>
<l>pose_to_hom_mat3d (PlanePartRectToModelPose, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, [PX,PX], [PY,PY], [PZ1,PZ2], Qx, Qy, Qz)</l>
<l>gen_object_model_3d_from_points (Qx, Qy, Qz, OM3DModel)</l>
<l>return ()</l>
</body>
<docu id="gen_matching_object_model_3d">
<abstract lang="en_US">This procedure generates a 3D object model of the matched object from the contours.

The parameter ModelID is a handle of the matching model. ScaleRect is the rectification scale used.

ObjectHeight is the height of the matched object, which is the difference between the matching and actual planes.

The input message HandEyeCalibData must contain the camera parameters, the input message Poses must contain the pose MatchingPlaneInCamPose, and the input message RectificationData must contain the parameter RectifyImage, and, if the model ist to be rectified, the parameter ScaleRectification.

The output parameter OM3DModel is the 3D object representing the matched object on the plane.
</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate a 3D object of the matched model, in the case of rectification.</short>
<parameters>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Hand-eye calibration data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelID">
<default_type>integer</default_type>
<description lang="en_US">Handle of the shape-based matching model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>shape_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DModel">
<default_type>integer</default_type>
<description lang="en_US">3D object model of the matched object contour.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ObjectHeight">
<default_type>real</default_type>
<description lang="en_US">Height of the matched object.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Pose data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Rectification data.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_robot_tool_and_base_object_model_3d">
<interface>
<ic>
<par name="ArrowThickness" base_type="ctrl" dimension="0"/>
<par name="ArrowLength" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DToolOrigin" base_type="ctrl" dimension="0"/>
<par name="OM3DBase" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure creates 3D models that represent the tool and the base</c>
<c>* of the robot.</c>
<c>*</c>
<l>if (ArrowThickness &lt;= 0)</l>
<l>    throw ('ArrowThickness should be &gt; 0')</l>
<l>endif</l>
<l>if (ArrowLength &lt;= 0)</l>
<l>    throw ('ArrowLength should be &gt; 0')</l>
<l>endif</l>
<l>create_pose (0, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', IdentityPose)</l>
<c>*</c>
<c>* 3D model for the tool.</c>
<l>create_pose (ArrowLength, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransXPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransXPose, OM3DToolXOrigin)</l>
<l>create_pose (0, ArrowLength, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransYPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransYPose, OM3DToolYOrigin)</l>
<l>create_pose (0, 0, ArrowLength, 0, 0, 0, 'Rp+T', 'gba', 'point', TransZPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransZPose, OM3DToolZOrigin)</l>
<l>OM3DToolOrigin := [OM3DToolXOrigin, OM3DToolYOrigin, OM3DToolZOrigin]</l>
<c>*</c>
<c>* 3D model for the base.</c>
<l>FactorVisBase := ArrowThickness * 10</l>
<l>gen_box_object_model_3d (IdentityPose, FactorVisBase*1.5, FactorVisBase*1.5, FactorVisBase/12, OM3DBasePlate)</l>
<l>create_pose (ArrowLength, 0, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransXPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransXPose, OM3DBaseX)</l>
<l>create_pose (0, ArrowLength, 0, 0, 0, 0, 'Rp+T', 'gba', 'point', TransYPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransYPose, OM3DBaseY)</l>
<l>create_pose (0, 0, ArrowLength, 0, 0, 0, 'Rp+T', 'gba', 'point', TransZPose)</l>
<l>gen_arrow_object_model_3d (ArrowThickness, IdentityPose, TransZPose, OM3DBaseZ)</l>
<l>OM3DBase := [OM3DBaseX, OM3DBaseY, OM3DBaseZ, OM3DBasePlate]</l>
<l>return ()</l>
</body>
<docu id="gen_robot_tool_and_base_object_model_3d">
<abstract lang="en_US">This procedures generates the 3D models of the base and the tool coordinate systems of the robot.

The input parameters ArrowThickness and ArrowLength determine the size of the objects in 3D. 

The output parameters OM3DToolOrigin and OM3DBase carry the handles for the tool and base 3D models respectively.</abstract>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Generate base and tool 3D models of the robot.</short>
<parameters>
<parameter id="ArrowLength">
<default_type>real</default_type>
<description lang="en_US">Length of the arrows.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ArrowThickness">
<default_type>real</default_type>
<description lang="en_US">Thickness of the arrows.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="OM3DBase">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's base.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="OM3DToolOrigin">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's tool.</description>
<mixed_type>false</mixed_type>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="gen_tool_to_touching_point_object_model_3d">
<interface>
<ic>
<par name="ToolInBasePosesTouchingPoint" base_type="ctrl" dimension="1"/>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="OM3DToolTouchingPoint" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<l>gen_robot_tool_and_base_object_model_3d (0.0025, 0.05, OM3DToolOrigin, OM3DBase)</l>
<l>gen_object_model_3d_from_points ([0, RobotTouchingPointInToolCoordinates[0]], [0, RobotTouchingPointInToolCoordinates[1]], [0, RobotTouchingPointInToolCoordinates[2]], OM3DToolTouchingPoint)</l>
<l>set_object_model_3d_attrib_mod (OM3DToolTouchingPoint, 'lines', [], [2,0,1])</l>
<l>OM3DToolTouchingPointTmp := [OM3DToolOrigin, OM3DToolTouchingPoint]</l>
<c>*</c>
<l>OM3DToolTouchingPoint := []</l>
<l>for Index := 0 to ToolInBasePosesTouchingPoint.length()-1 by 1</l>
<l>    rigid_trans_object_model_3d (OM3DToolTouchingPointTmp, ToolInBasePosesTouchingPoint.at(Index), OM3DRigidTrans)</l>
<l>    OM3DToolTouchingPoint := [OM3DToolTouchingPoint, OM3DRigidTrans]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="gen_tool_to_touching_point_object_model_3d">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Generierung</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Creation</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="OM3DToolTouchingPoint">
<default_type>integer</default_type>
<description lang="en_US">3D model of the robot's tool in its current position.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RobotTouchingPointInToolCoordinates">
<description lang="en_US">A point on the gripper that has been used to approach points in the measurement plane of the robot.</description>
<sem_type>coordinates</sem_type>
</parameter>
<parameter id="ToolInBasePosesTouchingPoint">
<default_type>real</default_type>
<description lang="en_US">Robot positions.</description>
<multivalue>false</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_bounding_box_points_from_min_max" access="local">
<interface>
<ic>
<par name="BoundingBox" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PX" base_type="ctrl" dimension="0"/>
<par name="PY" base_type="ctrl" dimension="0"/>
<par name="PZ" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>Points := {[]}</l>
<l>Points.at(0) := [BoundingBox[0],BoundingBox[1],BoundingBox[2]]</l>
<l>Points.at(1) := [BoundingBox[3],BoundingBox[1],BoundingBox[2]]</l>
<l>Points.at(2) := [BoundingBox[3],BoundingBox[4],BoundingBox[2]]</l>
<l>Points.at(3) := [BoundingBox[0],BoundingBox[4],BoundingBox[2]]</l>
<l>Points.at(4) := [BoundingBox[0],BoundingBox[1],BoundingBox[5]]</l>
<l>Points.at(5) := [BoundingBox[3],BoundingBox[1],BoundingBox[5]]</l>
<l>Points.at(6) := [BoundingBox[3],BoundingBox[4],BoundingBox[5]]</l>
<l>Points.at(7) := [BoundingBox[0],BoundingBox[4],BoundingBox[5]]</l>
<l>PX := []</l>
<l>PY := []</l>
<l>PZ := []</l>
<l>for Index := 0 to 7 by 1</l>
<l>    PX := [PX,Points.at(Index)[0]]</l>
<l>    PY := [PY,Points.at(Index)[1]]</l>
<l>    PZ := [PZ,Points.at(Index)[2]]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_bounding_box_points_from_min_max">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Merkmale</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Features</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="BoundingBox">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PX">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PY">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PZ">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_cam_par_data">
<interface>
<ic>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
<par name="ParamName" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ParamValue" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* get_cam_par_data returns in ParamValue the value of the</c>
<c>* parameter that is given in ParamName from the tuple of</c>
<c>* camera parameters that is given in CameraParam.</c>
<c>* </c>
<c>* Get the parameter names that correspond to the</c>
<c>* elements in the input camera parameter tuple.</c>
<l>get_cam_par_names (CameraParam, CameraType, CameraParamNames)</l>
<c>* </c>
<c>* Find the index of the requested camera data and return</c>
<c>* the corresponding value.</c>
<l>ParamValue := []</l>
<l>for Index := 0 to |ParamName| - 1 by 1</l>
<l>    ParamNameInd := ParamName[Index]</l>
<l>    if (ParamNameInd == 'camera_type')</l>
<l>        ParamValue := [ParamValue,CameraType]</l>
<l>        continue</l>
<l>    endif</l>
<l>    I := find(CameraParamNames,ParamNameInd)</l>
<l>    if (I != -1)</l>
<l>        ParamValue := [ParamValue,CameraParam[I]]</l>
<l>    else</l>
<l>        throw ('Unknown camera parameter ' + ParamNameInd)</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_cam_par_data">
<abstract lang="en_US">get_cam_par_data returns the value ParamValue of the camera parameter ParamName from the camera parameter tuple CameraParam. The following parameter names can be queried: 'camera_type', 'focus', 'magnification', 'kappa', 'k1', 'k2', 'k3', 'p1', 'p2', 'image_plane_dist', 'tilt', 'rot', 'sx' ,'sy', 'cx', 'cy', 'image_width', 'image_height', 'vx', 'vy', 'vz'. If the camera type does not support the requested value, an exception is raised.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam) 
get_cam_par_data (CameraParam, 'image_width', ImageWidth)
get_cam_par_data (CameraParam, 'image_height', ImageHeight)
gen_image_const (Image, 'byte', ImageWidth, ImageHeight)</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>set_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Get the value of a specified camera parameter from the camera parameter tuple.</short>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ParamName">
<default_type>string</default_type>
<default_value>'image_width'</default_value>
<description lang="en_US">Name of the camera parameter for that the value should be returned.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'camera_type'</item>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</value_list>
</parameter>
<parameter id="ParamValue">
<default_type>real</default_type>
<description lang="en_US">Value of the requested camera parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_cam_par_names">
<interface>
<ic>
<par name="CameraParam" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraType" base_type="ctrl" dimension="0"/>
<par name="ParamNames" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* get_cam_par_names returns for each element in the camera</c>
<c>* parameter tuple that is passed in CameraParam the name</c>
<c>* of the respective camera parameter. The parameter names</c>
<c>* are returned in ParamNames. Additionally, the camera</c>
<c>* type is returned in CameraType. Alternatively, instead of</c>
<c>* the camera parameters, the camera type can be passed in</c>
<c>* CameraParam in form of one of the following strings:</c>
<c>*   - 'area_scan_division'</c>
<c>*   - 'area_scan_polynomial'</c>
<c>*   - 'area_scan_tilt_division'</c>
<c>*   - 'area_scan_tilt_polynomial'</c>
<c>*   - 'area_scan_telecentric_division'</c>
<c>*   - 'area_scan_telecentric_polynomial'</c>
<c>*   - 'area_scan_tilt_bilateral_telecentric_division'</c>
<c>*   - 'area_scan_tilt_bilateral_telecentric_polynomial'</c>
<c>*   - 'area_scan_tilt_object_side_telecentric_division'</c>
<c>*   - 'area_scan_tilt_object_side_telecentric_polynomial'</c>
<c>*   - 'line_scan'</c>
<c>* </c>
<l>CameraParamAreaScanDivision := ['focus','kappa','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanPolynomial := ['focus','k1','k2','k3','p1','p2','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTelecentricDivision := ['magnification','kappa','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTelecentricPolynomial := ['magnification','k1','k2','k3','p1','p2','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTiltDivision := ['focus','kappa','image_plane_dist','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTiltPolynomial := ['focus','k1','k2','k3','p1','p2','image_plane_dist','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanImageSideTelecentricTiltDivision := ['focus','kappa','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanImageSideTelecentricTiltPolynomial := ['focus','k1','k2','k3','p1','p2','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltDivision := ['magnification','kappa','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltPolynomial := ['magnification','k1','k2','k3','p1','p2','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanObjectSideTelecentricTiltDivision := ['magnification','kappa','image_plane_dist','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanObjectSideTelecentricTiltPolynomial := ['magnification','k1','k2','k3','p1','p2','image_plane_dist','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamLinesScan := ['focus','kappa','sx','sy','cx','cy','image_width','image_height','vx','vy','vz']</l>
<c>* Legacy parameter names</c>
<l>CameraParamAreaScanTiltDivisionLegacy := ['focus','kappa','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTiltPolynomialLegacy := ['focus','k1','k2','k3','p1','p2','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTelecentricDivisionLegacy := ['focus','kappa','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanTelecentricPolynomialLegacy := ['focus','k1','k2','k3','p1','p2','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy := ['focus','kappa','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<l>CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy := ['focus','k1','k2','k3','p1','p2','tilt','rot','sx','sy','cx','cy','image_width','image_height']</l>
<c>* </c>
<c>* If the camera type is passed in CameraParam</c>
<l>if (|CameraParam| == 1 and is_string(CameraParam[0]))</l>
<l>    CameraType := CameraParam[0]</l>
<l>    if (CameraType == 'area_scan_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanDivision]</l>
<l>    elseif (CameraType == 'area_scan_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricDivision]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_division')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_polynomial')</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'line_scan')</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScan]</l>
<l>    else</l>
<l>        throw ('Unknown camera type \'' + CameraType + '\' passed in CameraParam.')</l>
<l>    endif</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<c>* If the camera parameters are passed in CameraParam</c>
<l>if (not is_string(CameraParam[0]))</l>
<c>    * Format of camera parameters for HALCON 12 and earlier</c>
<l>    switch (|CameraParam|)</l>
<c>        * </c>
<c>        * Area Scan</c>
<l>    case 8:</l>
<c>        * CameraType: 'area_scan_division' or 'area_scan_telecentric_division'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanDivision</l>
<l>            CameraType := 'area_scan_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanTelecentricDivisionLegacy</l>
<l>            CameraType := 'area_scan_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 10:</l>
<c>        * CameraType: 'area_scan_tilt_division' or 'area_scan_telecentric_tilt_division'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanTiltDivisionLegacy</l>
<l>            CameraType := 'area_scan_tilt_division'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanBilateralTelecentricTiltDivisionLegacy</l>
<l>            CameraType := 'area_scan_tilt_bilateral_telecentric_division'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 12:</l>
<c>        * CameraType: 'area_scan_polynomial' or 'area_scan_telecentric_polynomial'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanPolynomial</l>
<l>            CameraType := 'area_scan_polynomial'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanTelecentricPolynomialLegacy</l>
<l>            CameraType := 'area_scan_telecentric_polynomial'</l>
<l>        endif</l>
<l>        break</l>
<l>    case 14:</l>
<c>        * CameraType: 'area_scan_tilt_polynomial' or 'area_scan_telecentric_tilt_polynomial'</c>
<l>        if (CameraParam[0] != 0.0)</l>
<l>            ParamNames := CameraParamAreaScanTiltPolynomialLegacy</l>
<l>            CameraType := 'area_scan_tilt_polynomial'</l>
<l>        else</l>
<l>            ParamNames := CameraParamAreaScanBilateralTelecentricTiltPolynomialLegacy</l>
<l>            CameraType := 'area_scan_tilt_bilateral_telecentric_polynomial'</l>
<l>        endif</l>
<l>        break</l>
<c>        * </c>
<c>        * Line Scan</c>
<l>    case 11:</l>
<c>        * CameraType: 'line_scan'</c>
<l>        ParamNames := CameraParamLinesScan</l>
<l>        CameraType := 'line_scan'</l>
<l>        break</l>
<l>    default:</l>
<l>        throw ('Wrong number of values in CameraParam.')</l>
<l>    endswitch</l>
<l>else</l>
<c>    * Format of camera parameters since HALCON 13</c>
<l>    CameraType := CameraParam[0]</l>
<l>    if (CameraType == 'area_scan_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanDivision]</l>
<l>    elseif (CameraType == 'area_scan_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_division')</l>
<l>        if (|CameraParam| != 9)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricDivision]</l>
<l>    elseif (CameraType == 'area_scan_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 13)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTelecentricPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_division')</l>
<l>        if (|CameraParam| != 11)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_image_side_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 15)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanImageSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_division')</l>
<l>        if (|CameraParam| != 11)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_bilateral_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 15)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanBilateralTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_division')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltDivision]</l>
<l>    elseif (CameraType == 'area_scan_tilt_object_side_telecentric_polynomial')</l>
<l>        if (|CameraParam| != 16)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamAreaScanObjectSideTelecentricTiltPolynomial]</l>
<l>    elseif (CameraType == 'line_scan')</l>
<l>        if (|CameraParam| != 12)</l>
<l>            throw ('Wrong number of values in CameraParam.')</l>
<l>        endif</l>
<l>        ParamNames := ['camera_type',CameraParamLinesScan]</l>
<l>    else</l>
<l>        throw ('Unknown camera type in CameraParam.')</l>
<l>    endif</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_cam_par_names">
<abstract lang="en_US">get_cam_par_names returns the names ParamNames of the camera parameters for each element of CameraParam. The parameter names are returned in ParamNames. Additionally, the camera type is returned in CameraType.

Alternatively, instead of the camera parameters, the camera type can be passed in CameraParam in form of one of the following strings:
   - 'area_scan_division'
   - 'area_scan_polynomial'
   - 'area_scan_tilt_division'
   - 'area_scan_tilt_polynomial'
   - 'area_scan_telecentric_division'
   - 'area_scan_telecentric_polynomial'
   - 'area_scan_tilt_bilateral_telecentric_division'
   - 'area_scan_tilt_bilateral_telecentric_polynomial'
   - 'area_scan_tilt_object_side_telecentric_division'
   - 'area_scan_tilt_object_side_telecentric_polynomial'
   - 'line_scan'</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam)
get_cam_par_names (CameraParam, CameraType, ParamNames)
</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>set_cam_par_data</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Get the names of the parameters in a camera parameter tuple.</short>
<parameters>
<parameter id="CameraParam">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple or camera type.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'area_scan_division'</item>
<item>'area_scan_polynomial'</item>
<item>'area_scan_tilt_division'</item>
<item>'area_scan_tilt_polynomial'</item>
<item>'area_scan_telecentric_division'</item>
<item>'area_scan_telecentric_polynomial'</item>
<item>'area_scan_tilt_bilateral_telecentric_division'</item>
<item>'area_scan_tilt_bilateral_telecentric_polynomial'</item>
<item>'area_scan_tilt_object_side_telecentric_division'</item>
<item>'area_scan_tilt_object_side_telecentric_polynomial'</item>
<item>'area_scan_tilt_image_side_telecentric_division'</item>
<item>'area_scan_tilt_image_side_telecentric_polynomial'</item>
<item>'line_scan'</item>
</values>
</parameter>
<parameter id="CameraType">
<default_type>string</default_type>
<description lang="en_US">The camera type that is described by CameraParam.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'area_scan_division'</item>
<item>'area_scan_polynomial'</item>
<item>'area_scan_tilt_division'</item>
<item>'area_scan_tilt_polynomial'</item>
<item>'area_scan_telecentric_division'</item>
<item>'area_scan_telecentric_polynomial'</item>
<item>'area_scan_tilt_bilateral_telecentric_division'</item>
<item>'area_scan_tilt_bilateral_telecentric_polynomial'</item>
<item>'area_scan_tilt_object_side_telecentric_division'</item>
<item>'area_scan_tilt_object_side_telecentric_polynomial'</item>
<item>'line_scan'</item>
</value_list>
</parameter>
<parameter id="ParamNames">
<default_type>string</default_type>
<description lang="en_US">Parameter names of the camera parameter tuple or camera type passed in CameraParam.</description>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_custom_features">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CurrentName" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Output" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* This procedure can be used to extend the functionality</c>
<c>* of the calculate_feature_set procedure library by</c>
<c>* user-defined features.</c>
<c>* </c>
<c>* Instructions:</c>
<c>* </c>
<c>* 1. Find the template block at the beginning the procedure</c>
<c>* (marked by comments) and duplicate it.</c>
<c>* </c>
<c>* 2. In the copy edit the two marked areas as follows:</c>
<c>* </c>
<c>* 2.1. Feature name and groups:</c>
<c>* Assign a unique identifier for your feature to the variable "Name".</c>
<c>* Then, assign the groups that you want your feature to belong to</c>
<c>* to the variable "Groups".</c>
<c>* </c>
<c>* 2.2. Feature calculation:</c>
<c>* Enter the code that calculates your feature and</c>
<c>* assign the result to the variable "Feature".</c>
<c>* </c>
<c>* 3. Test</c>
<c>* Use the "test_feature" procedure to check,</c>
<c>* if the feature is calculated correctly.</c>
<c>* If the procedure throws an exception,</c>
<c>* maybe the order of the feature vector is wrong</c>
<c>* (See note below).</c>
<c>* </c>
<c>* 4. Integration</c>
<c>* - Save your modified procedure get_custom_features.hdvp</c>
<c>*   to a location of your choice.</c>
<c>*   (We recommend not to overwrite the template.)</c>
<c>* - Make sure, that your version of get_custom_procedures</c>
<c>*   is included in the procedure directories of HDevelop.</c>
<c>*   (Choose Procedures -&gt; Manage Procedures -&gt; Directories -&gt; Add from the HDevelop menu bar.)</c>
<c>* </c>
<c>* Note:</c>
<c>* The current implementation supports region arrays as input.</c>
<c>* In that case, multi-dimensional feature vectors are simply concatenated.</c>
<c>* Example: The feature 'center' has two dimensions [Row,Column].</c>
<c>* If an array of three regions is passed, the correct order of the "Feature" variable is</c>
<c>* [Row1, Column1, Row2, Column2, Row3, Column3].</c>
<c>* </c>
<l>TmpResults := []</l>
<c>* ************************************************</c>
<c>* ************************************************</c>
<c>* **** Copy the following template block     *****</c>
<c>* **** and edit the two marked code sections *****</c>
<c>* **** to add user-defined features          *****</c>
<c>* ************************************************</c>
<c>* ************************************************</c>
<c>* </c>
<c>* ***************************************</c>
<c>* *********** TEMPLATE BLOCK ************</c>
<c>* ***************************************</c>
<c>* </c>
<c>* ********************************************************************</c>
<c>* ** Section 1:</c>
<c>* ** Enter unique feature name and groups to which it belongs here ***</c>
<l>Name := 'custom_feature_numlines'</l>
<l>Groups := 'custom'</l>
<c>* ** Enter unique feature name and groups above this line ************</c>
<c>* ********************************************************************</c>
<l>if (Name == CurrentName)</l>
<c>    * ******************************************************</c>
<c>    * ** Section 2:</c>
<c>    * ** Enter code to calculate feature here **************</c>
<l>    Feature := []</l>
<l>    count_obj (Region, NumRegions)</l>
<l>    for I := 1 to NumRegions by 1</l>
<l>        select_obj (Region, RegionSelected, I)</l>
<l>        gen_contour_region_xld (RegionSelected, Contours, 'border')</l>
<l>        count_obj (Contours, NumContours)</l>
<l>        NumLines := 0</l>
<l>        for J := 1 to NumContours by 1</l>
<l>            select_obj (Contours, ContoursSelected, J)</l>
<l>            segment_contours_xld (ContoursSelected, ContoursSplit, 'lines', 5, 2, 1)</l>
<l>            count_obj (ContoursSplit, NumSplit)</l>
<l>            NumLines := NumLines + NumSplit</l>
<l>        endfor</l>
<l>        Feature := [Feature,NumLines]</l>
<l>    endfor</l>
<c>    * ** Enter code to calculate feature above this line ***</c>
<c>    * ******************************************************</c>
<l>    append_length_or_values (Mode, Feature, TmpResults, TmpResults)</l>
<l>endif</l>
<l>append_names_or_groups (Mode, Name, Groups, CurrentName, TmpResults, TmpResults)</l>
<c>* </c>
<c>* ************************************</c>
<c>* ****** END OF TEMPLATE BLOCK *******</c>
<c>* ************************************</c>
<c>* </c>
<l>Output := TmpResults</l>
<l>return ()</l>
</body>
<docu id="get_custom_features">
<abstract lang="en_US">This procedure can be used to extend the functionality of the calculate_feature_set procedure library by user-defined features.

Instructions:

1. Find the 'template block' at the beginning of the procedure (enclosed by comments) and duplicate it.

2. In the duplicate edit the two marked code sections as follows:

2.1. 'Section 1': Feature name and groups

 Assign a unique identifier for your feature to the variable 'Name'. Then, assign the groups your feature belongs to to the variable 'Groups'.

2.2. 'Section 2': Feature calculation

Enter the code that calculates your feature and assign the result to the variable 'Feature'.

3. Test

Use the "test_feature" procedure to check, if the feature is integrated correctly.
If the procedure throws an exception, first check if the order of the feature vector is correct (see note below).

4. Integration

Save your modified procedure get_custom_features.hdvp to a location of your choice. We recommend not to overwrite the template.

Make sure that your version of get_custom_features is included in the procedure directories of HDevelop (Choose the following  from the HDevelop menu bar: Procedures -&gt; Manage Procedures -&gt; Directories -&gt; Add).

Note that the current implementation supports region arrays as input. In that case, multi-dimensional feature vectors are simply concatenated.

Example: The feature 'center' has two dimensions [Row,Column]. If an array of three regions is passed, the correct order of thevalues in the  variable Feature is [Row1, Column1, Row2, Column2, Row3, Column3].

The Output depends on the processing mode Mode:
If  Mode == 'get_names', the names of all features that belong to the input group in CurrentName are returned.
If  Mode == 'get_lengths', the length of the feature vector of the feature in CurrentName is returned.
If  Mode == 'get_groups', the names of all groups to which the feature in CurrentNamebelongs to are returned.
If  Mode == 'calculate', the feature vector of the feature in CurrentName is returned.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.
</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Procedure Templates</library>
<short lang="en_US">Describe and calculate user-defined features to be used in conjunction with the calculate_feature_set procedure library.</short>
<parameters>
<parameter id="CurrentName">
<default_type>string</default_type>
<description lang="en_US">Current feature or group name as received from the caller procedure get_features.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Gray-value image.</description>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Processing mode as received from the caller procedure get_features.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_lengths'</item>
<item>'get_groups'</item>
<item>'calculate'</item>
</value_list>
</parameter>
<parameter id="Output">
<default_type>string</default_type>
<description lang="en_US">Feature names, feature vector, feature vector lengths, or group names.</description>
<multivalue>optional</multivalue>
</parameter>
<parameter id="Region">
<description lang="en_US">Regions to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_dl_classifier_image_results">
<interface>
<oo>
<par name="Images" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="PredictedClasses" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure can be used to visualize classified</c>
<c>* ImageFiles selected according to the specifications</c>
<c>* given with GenParamName and GenParamValue.</c>
<c>*</c>
<c>* Set parameter defaults.</c>
<l>LabelSelection := 'all'</l>
<l>PredictedClassSelection := 'all'</l>
<l>GlobalSelection := 'erroneously_classified'</l>
<l>DisplayImages := 'true'</l>
<c>* </c>
<c>* Check if number of elements in</c>
<c>* GenParamName and GenParamValue is equal.</c>
<l>if (|GenParamName| != |GenParamValue|)</l>
<l>    throw ('Number of generic parameter names does not match number of generic parameter values.')</l>
<l>endif</l>
<c>*</c>
<c>* Parse generic parameters.</c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>    if (GenParamName[GenParamIndex] == 'label_selection')</l>
<c>        * Set 'label_selection'.</c>
<l>        LabelSelection := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'predicted_class_selection')</l>
<c>        * Set 'predicted_class_selection'.</c>
<l>        PredictedClassSelection := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'global_selection')</l>
<c>        * Set 'global_selection'.</c>
<l>        GlobalSelection := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'display_images')</l>
<c>        * Set 'display_images'.</c>
<l>        DisplayImages := GenParamValue[GenParamIndex]</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>*</c>
<c>* Filter data according to LabelSelection.</c>
<l>if (LabelSelection != 'all')</l>
<l>    Mask := GroundTruthLabels [==] LabelSelection</l>
<l>    if (sum(Mask) == 0)</l>
<l>        throw ('LabelSelection \'' + LabelSelection + '\' not found in GroundTruthLabels.')</l>
<l>    endif</l>
<l>    ImageFiles := select_mask(ImageFiles, Mask)</l>
<l>    GroundTruthLabels := select_mask(GroundTruthLabels, Mask)</l>
<l>    PredictedClasses := select_mask(PredictedClasses, Mask)</l>
<l>endif</l>
<c>*</c>
<c>* Filter data according to PredictedClassSelection.</c>
<l>if (PredictedClassSelection != 'all')</l>
<l>    Mask := PredictedClasses [==] PredictedClassSelection</l>
<l>    if (sum(Mask) == 0)</l>
<l>        throw ('PredictedClassSelection \'' + PredictedClassSelection + '\' not found in PredictedClasses.')</l>
<l>    endif</l>
<l>    ImageFiles := select_mask(ImageFiles, Mask)</l>
<l>    GroundTruthLabels := select_mask(GroundTruthLabels, Mask)</l>
<l>    PredictedClasses := select_mask(PredictedClasses, Mask)</l>
<l>endif</l>
<c>*</c>
<c>* Filter data according to GlobalSelection.</c>
<l>if (GlobalSelection != 'all')</l>
<l>    Mask := GroundTruthLabels [==] PredictedClasses</l>
<l>    if (GlobalSelection  == 'erroneously_classified')</l>
<c>        * Flip the mask.</c>
<l>        Mask := abs(Mask-1)</l>
<l>    endif</l>
<l>    ImageFiles := select_mask(ImageFiles, Mask)</l>
<l>    GroundTruthLabels := select_mask(GroundTruthLabels, Mask)</l>
<l>    PredictedClasses := select_mask(PredictedClasses, Mask)</l>
<l>endif</l>
<c>*</c>
<l>if (DisplayImages == 'true')</l>
<c>    * Loop over the images.</c>
<l>    gen_empty_obj (Images)</l>
<l>    for ImageIndex := 0 to |ImageFiles|-1 by 1</l>
<c>        *</c>
<c>        * Concatenate selected images.</c>
<l>        read_image (Image, ImageFiles[ImageIndex])</l>
<l>        concat_obj (Images, Image, Images)</l>
<c>        *</c>
<l>        Label := GroundTruthLabels[ImageIndex]</l>
<l>        PredictedClass := PredictedClasses[ImageIndex]</l>
<c>        *</c>
<l>        Text[0] := 'Image ' + ImageIndex + '/' + (|ImageFiles|-1)</l>
<l>        Text[1] := 'Label: ' + Label</l>
<l>        Text[2] := 'Predicted Class: ' + PredictedClass</l>
<l>        if (Label == PredictedClass)</l>
<l>            Color := 'forest green'</l>
<l>        else</l>
<l>            Color := 'red'</l>
<l>        endif</l>
<c>        *</c>
<c>        * Display the image.</c>
<l>        dev_resize_window_fit_image (Image, 0, 0, -1, -1)</l>
<l>        dev_display (Image)</l>
<l>        dev_disp_text (Text, 'window', 'top', 'left', ['black', Color], [], [])</l>
<l>        dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>        stop ()</l>
<l>    endfor</l>
<l>else</l>
<l>    read_image (Images, ImageFiles)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_dl_classifier_image_results">
<abstract lang="de_DE">Diese Prozedur kann benutzt werden, um die klassifizierten Bilder in ImageFiles entsprechend der Spezifikationen in GenParamName und GenParamValue anzuzeigen. Die Klassifikationsergebnisse werden dabei durch die Labels (die vom Benutzer vergebenen Klassen) und vorhergesagten Klassen PredictedClasses festgelegt. Wenn die Bilder dargestellt werden sollen, muss ein WindowHandle übergeben werden. Die ausgewählten Bilder werden in Images zurückgegeben.

Die folgenden Werte für die generischen Parameter werden unterstützt: 

* 'label_selection': Nur die Bilder mit dem entsprechenden Label (die eigentliche Klasse) werden angezeigt und zurückgegeben, oder alle mit 'all'. Der Standard ist 'all'. 
* 'predicted_class_selection': Nur die Bilder mit der entsprechenden vorhergesagten Klasse werden angezeigt und zurückgegeben, oder alle mit 'all'. Der Standard ist 'all'. 
* 'global_selection': Entweder werden alle 'all' Bilder angezeigt und zurückgegeben, oder nur die falsch klassifizierten 'erroneously_classified'. Der Standard ist 'erroneously_classified'. 
* 'display_images': Wenn dieser Parameter auf 'false' gesetzt wird, werden die Bilder nur zurückgegeben, nicht angezeigt. Der Standard ist 'true'. </abstract>
<abstract lang="en_US">This procedure can be used to visualize classified ImageFiles according to the specifications given with GenParamName and GenParamValue. The classification success is determined with the given ground truth Labels and PredictedClasses. If the images are to be displayed, a WindowHandle must be given. The selected Images are returned. 

The following parameter values for the generic parameters are available:

* 'label_selection': Only the images with the ground truth labels are displayed and returned, or 'all' images are used. The default is 'all'.
* 'predicted_class_selection': Only the images with the predicted classes (the inferred classes) are displayed and returned, or 'all' images are used. The default is 'all'.
* 'global_selection': Either 'all' images or only the 'erroneously_classified' images can be displayed and returned. The default is 'erroneously_classified'.
* 'display_images': If set to 'false', the images are only returned in Images, not displayed. The default is 'true'.</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Klassifikation</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="de_DE">Anzeigen und Zurückgeben von klassifizierten Bildern.</short>
<short lang="en_US">Display and return the classified images.</short>
<parameters>
<parameter id="GenParamName">
<description lang="de_DE">Name des generischen Parameters.</description>
<description lang="en_US">Name of the generic parameter.</description>
<multivalue>optional</multivalue>
<sem_type>attribute.name</sem_type>
<values>
<item>'label_selection'</item>
<item>'predicted_class_selection'</item>
<item>'global_selection'</item>
<item>'display_images'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<description lang="de_DE">Wert des generischen Parameters.</description>
<description lang="en_US">Value of the generic parameter.</description>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<values>
<item>'all'</item>
<item>'true'</item>
<item>'false'</item>
</values>
</parameter>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="de_DE">Die vom Benutzer vergebenen Labels der Bilder.</description>
<description lang="en_US">Ground truth labels of the images.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="de_DE">Tuple mit den Bildpfaden.</description>
<description lang="en_US">Tuple of the image paths. </description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Images">
<description lang="de_DE">Die ausgewählten Bilder.</description>
<description lang="en_US">The selected images.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="PredictedClasses">
<default_type>string</default_type>
<description lang="de_DE">Die vom Klassifikator vorhergesagten Klassen.</description>
<description lang="en_US">The classes predicted from the classifier.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="de_DE">Handle des Grafikfensters.</description>
<description lang="en_US">Handle of the graphics window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_extent_by_axis" access="local">
<interface>
<ic>
<par name="OM3D" base_type="ctrl" dimension="0"/>
<par name="XExtent" base_type="ctrl" dimension="0"/>
<par name="YExtent" base_type="ctrl" dimension="0"/>
<par name="ZExtent" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="XExtentOut" base_type="ctrl" dimension="0"/>
<par name="YExtentOut" base_type="ctrl" dimension="0"/>
<par name="ZExtentOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>XExtentOut := XExtent</l>
<l>YExtentOut := YExtent</l>
<l>ZExtentOut := ZExtent</l>
<l>get_object_model_3d_params (OM3D, 'bounding_box1', BB)</l>
<l>for Index := 0 to |BB|/6-1 by 1</l>
<l>    XExtentOut := [XExtentOut, BB[Index*6], BB[Index*6+3]]</l>
<l>    YExtentOut := [YExtentOut, BB[Index*6+1], BB[Index*6+4]]</l>
<l>    ZExtentOut := [ZExtentOut, BB[Index*6+2], BB[Index*6+5]]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="get_extent_by_axis">
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Transformationen</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Transformations</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="OM3D">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>true</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="XExtent">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="XExtentOut">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="YExtent">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="YExtentOut">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ZExtent">
<default_type>real</default_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ZExtentOut">
<default_type>real</default_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_feature_lengths">
<interface>
<ic>
<par name="FeatureNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Lengths" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Calculate the lengths of the feature vectors of</c>
<c>* the features in FeatureNames.</c>
<c>* </c>
<l>gen_dummy_objects (Region, Image)</l>
<l>get_features (Region, Image, FeatureNames, 'get_lengths', Lengths)</l>
<l>return ()</l>
</body>
<docu id="get_feature_lengths">
<abstract lang="en_US">Returns the length of the feature vector for each feature name in FeatureNames.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>get_feature_names</item>
</predecessor>
<see_also>
<item>get_feature_names</item>
<item>set_feature_lengths_class_train_data</item>
<item>select_feature_set_knn</item>
<item>select_feature_set_svm</item>
<item>select_feature_set_mlp</item>
</see_also>
<short lang="en_US">Returns the length of the feature vector for each feature name.</short>
<successor>
<item>set_feature_lengths_class_train_data</item>
</successor>
<parameters>
<parameter id="FeatureNames">
<default_type>string</default_type>
<default_value>'area'</default_value>
<description lang="en_US">A list of feature names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'area'</item>
<item>'width'</item>
<item>'height'</item>
<item>'ra'</item>
<item>'rb'</item>
<item>'phi'</item>
<item>'roundness'</item>
<item>'num_sides'</item>
<item>'num_connected'</item>
<item>'num_holes'</item>
<item>'area_holes'</item>
<item>'max_diameter'</item>
<item>'orientation'</item>
<item>'outer_radius'</item>
<item>'inner_radius'</item>
<item>'inner_width'</item>
<item>'inner_height'</item>
<item>'circularity'</item>
<item>'compactness'</item>
<item>'convexity'</item>
<item>'rectangularity'</item>
<item>'anisometry'</item>
<item>'bulkiness'</item>
<item>'struct_factor'</item>
<item>'dist_mean'</item>
<item>'dist_deviation'</item>
<item>'euler_number'</item>
<item>'rect2_phi'</item>
<item>'rect2_len1'</item>
<item>'rect2_len2'</item>
<item>'contlength'</item>
<item>'porosity'</item>
<item>'gray_area'</item>
<item>'gray_ra'</item>
<item>'gray_rb'</item>
<item>'gray_phi'</item>
<item>'gray_min'</item>
<item>'gray_max'</item>
<item>'gray_range'</item>
<item>'gray_mean'</item>
<item>'gray_deviation'</item>
<item>'gray_plane_deviation'</item>
<item>'gray_anisotropy'</item>
<item>'gray_entropy'</item>
<item>'gray_hor_proj'</item>
<item>'gray_vert_proj'</item>
<item>'gray_hor_proj_histo'</item>
<item>'gray_vert_proj_histo'</item>
<item>'grad_dir_histo'</item>
<item>'edge_density'</item>
<item>'edge_density_histogram'</item>
<item>'edge_density_pyramid_2'</item>
<item>'edge_density_pyramid_3'</item>
<item>'edge_density_pyramid_4'</item>
<item>'edge_density_histogram_pyramid_2'</item>
<item>'edge_density_histogram_pyramid_3'</item>
<item>'edge_density_histogram_pyramid_4'</item>
<item>'cooc'</item>
<item>'cooc_pyramid_2'</item>
<item>'cooc_pyramid_3'</item>
<item>'cooc_pyramid_4'</item>
<item>'polar_gray_proj'</item>
<item>'polar_grad_proj'</item>
<item>'polar_grad_x_proj'</item>
<item>'polar_grad_y_proj'</item>
<item>'polar_gray_proj_histo'</item>
<item>'cielab_mean'</item>
<item>'cielab_dev'</item>
<item>'hls_mean'</item>
<item>'hls_dev'</item>
<item>'rgb_mean'</item>
<item>'rgb_dev'</item>
</values>
</parameter>
<parameter id="Lengths">
<default_type>integer</default_type>
<description lang="en_US">The lengths of the feature vectors.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_feature_names">
<interface>
<ic>
<par name="GroupNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Names" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Return all features that belong to</c>
<c>* at least one of the groups in GroupNames</c>
<c>* </c>
<l>gen_dummy_objects (Region, Image)</l>
<l>get_features (Region, Image, GroupNames, 'get_names', Names)</l>
<l>return ()</l>
</body>
<docu id="get_feature_names">
<abstract lang="en_US">Returns a list of feature names that belong to the feature groups given in GroupNames.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>query_feature_group_names</item>
<item>query_feature_names_by_group</item>
</predecessor>
<see_also>
<item>get_feature_lengths</item>
<item>query_feature_group_names</item>
<item>query_feature_names_by_group</item>
</see_also>
<short lang="en_US">Returns a list of feature names that belong to the feature groups given in GroupNames.</short>
<successor>
<item>get_feature_lengths</item>
<item>calculate_features</item>
<item>tuple_intersection</item>
<item>tuple_union</item>
</successor>
<parameters>
<parameter id="GroupNames">
<default_type>string</default_type>
<default_value>'region'</default_value>
<description lang="en_US">Name(s) of the feature group(s)</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'color'</item>
<item>'gray'</item>
<item>'region'</item>
<item>'rot_invar'</item>
<item>'scale_invar'</item>
<item>'texture'</item>
<item>'all'</item>
</values>
</parameter>
<parameter id="Names">
<default_type>string</default_type>
<description lang="en_US">Names of the features belonging to at least one of the input feature groups</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_features" access="local">
<interface>
<io>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Namelist" base_type="ctrl" dimension="0"/>
<par name="Mode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Output" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* *********************************************************</c>
<c>* Feature procedure</c>
<c>* Contains the names, properties and calculation of</c>
<c>* all supproted features.</c>
<c>* It consists of similar blocks for each feature.</c>
<c>* </c>
<c>* If you like to add your own features, please use</c>
<c>* the external procedure get_custom_features.hdvp</c>
<c>* in the HALCON procedures/templates directory.</c>
<c>* *********************************************************</c>
<c>* </c>
<c>* Insert location of your custom procedure here</c>
<c>* </c>
<l>get_system ('empty_region_result', EmptyRegionResult)</l>
<l>set_system ('empty_region_result', 'true')</l>
<l>AccumulatedResults := []</l>
<l>CustomResults := []</l>
<l>count_obj (Region, NumRegions)</l>
<l>get_image_size (Image, ImageWidth, ImageHeight)</l>
<c>* </c>
<l>for I := 0 to |Namelist| - 1 by 1</l>
<l>    CurrentName := Namelist[I]</l>
<c>    * </c>
<l>    get_custom_features (Region, Image, CurrentName, Mode, CustomResults)</l>
<l>    AccumulatedResults := [AccumulatedResults,CustomResults]</l>
<c>    * </c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * HALCON REGION FEATURES</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * BASIC</c>
<c>    * ************************************</c>
<c>    * ** area ***</c>
<l>    Name := 'area'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        area_center (Region, Feature, _, _)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** width ***</c>
<l>    Name := 'width'</l>
<l>    Groups := 'region'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle1 (Region, Row1, Column1, Row2, Column2)</l>
<l>        Feature := Column2 - Column1 + 1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** height ***</c>
<l>    Name := 'height'</l>
<l>    Groups := 'region'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle1 (Region, Row1, Column1, Row2, Column2)</l>
<l>        Feature := Row2 - Row1 + 1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** ra ***</c>
<l>    Name := 'ra'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis (Region, Ra, Rb, Phi)</l>
<l>        Feature := Ra</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rb ***</c>
<l>    Name := 'rb'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis (Region, Ra, Rb, Phi)</l>
<l>        Feature := Rb</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** phi ***</c>
<l>    Name := 'phi'</l>
<l>    Groups := ['region','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis (Region, Ra, Rb, Phi)</l>
<l>        Feature := Phi</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** roundness ***</c>
<l>    Name := 'roundness'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        roundness (Region, Distance, Sigma, Roundness, Sides)</l>
<l>        Feature := Roundness</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** num_sides ***</c>
<l>    Name := 'num_sides'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        roundness (Region, Distance, Sigma, Roundness, Sides)</l>
<l>        Feature := Sides</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** num_connected ***</c>
<l>    Name := 'num_connected'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        connect_and_holes (Region, NumConnected, NumHoles)</l>
<l>        Feature := NumConnected</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** num_holes ***</c>
<l>    Name := 'num_holes'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        connect_and_holes (Region, NumConnected, NumHoles)</l>
<l>        Feature := NumHoles</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** area_holes ***</c>
<l>    Name := 'area_holes'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        area_holes (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** max_diameter ***</c>
<l>    Name := 'max_diameter'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        diameter_region (Region, Row1, Column1, Row2, Column2, Diameter)</l>
<l>        Feature := Diameter</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** orientation ***</c>
<l>    Name := 'orientation'</l>
<l>    Groups := ['region','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        orientation_region (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * SHAPE</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** outer_radius ***</c>
<l>    Name := 'outer_radius'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_circle (Region, Row, Column, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** inner_radius ***</c>
<l>    Name := 'inner_radius'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        inner_circle (Region, Row, Column, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** inner_width ***</c>
<l>    Name := 'inner_width'</l>
<l>    Groups := 'region'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        inner_rectangle1 (Region, Row1, Column1, Row2, Column2)</l>
<l>        Feature := Column2 - Column1 + 1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** inner_height ***</c>
<l>    Name := 'inner_height'</l>
<l>    Groups := 'region'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        inner_rectangle1 (Region, Row1, Column1, Row2, Column2)</l>
<l>        Feature := Row2 - Row1 + 1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** circularity ***</c>
<l>    Name := 'circularity'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        circularity (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** compactness ***</c>
<l>    Name := 'compactness'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        compactness (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** convexity ***</c>
<l>    Name := 'convexity'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        convexity (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rectangularity ***</c>
<l>    Name := 'rectangularity'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        rectangularity (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** anisometry ***</c>
<l>    Name := 'anisometry'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        eccentricity (Region, Anisometry, Bulkiness, StructureFactor)</l>
<l>        Feature := Anisometry</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** bulkiness ***</c>
<l>    Name := 'bulkiness'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        eccentricity (Region, Anisometry, Bulkiness, StructureFactor)</l>
<l>        Feature := Bulkiness</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** struct_factor ***</c>
<l>    Name := 'struct_factor'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        eccentricity (Region, Anisometry, Bulkiness, StructureFactor)</l>
<l>        Feature := StructureFactor</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** dist_mean ***</c>
<l>    Name := 'dist_mean'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        roundness (Region, Distance, Sigma, Roundness, Sides)</l>
<l>        Feature := Distance</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** dist_deviation ***</c>
<l>    Name := 'dist_deviation'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        roundness (Region, Distance, Sigma, Roundness, Sides)</l>
<l>        Feature := Sigma</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** euler_number ***</c>
<l>    Name := 'euler_number'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        euler_number (Region, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rect2_phi ***</c>
<l>    Name := 'rect2_phi'</l>
<l>    Groups := ['region','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle2 (Region, Row, Column, Phi, Length1, Length2)</l>
<l>        Feature := Phi</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rect2_len1 ***</c>
<l>    Name := 'rect2_len1'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle2 (Region, Row, Column, Phi, Length1, Length2)</l>
<l>        Feature := Length1</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rect2_len2 ***</c>
<l>    Name := 'rect2_len2'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        smallest_rectangle2 (Region, Row, Column, Phi, Length1, Length2)</l>
<l>        Feature := Length2</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** contlength ***</c>
<l>    Name := 'contlength'</l>
<l>    Groups := ['region','rot_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        contlength (Region, ContLength)</l>
<l>        Feature := ContLength</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * REGION FEATURES</c>
<c>    * ************************************</c>
<c>    * MISC</c>
<c>    * ************************************</c>
<c>    * ** porosity ***</c>
<l>    Name := 'porosity'</l>
<l>    Groups := ['region','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        area_holes (Region, AreaHoles)</l>
<l>        area_center (Region, Area, Row, Column)</l>
<l>        if (Area == 0)</l>
<l>            Feature := 0.0</l>
<l>        else</l>
<l>            Feature := real(AreaHoles) / (Area + AreaHoles)</l>
<l>        endif</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * HALCON GRAY VALUE FEATURES</c>
<c>    * ************************************</c>
<c>    * BASIC</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ** gray_area ***</c>
<l>    Name := 'gray_area'</l>
<l>    Groups := ['gray','rot_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        area_center_gray (Region, Image, Area, Row, Column)</l>
<l>        Feature := Area</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_ra ***</c>
<l>    Name := 'gray_ra'</l>
<l>    Groups := ['gray','rot_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis_gray (Region, Image, Ra, Rb, Phi)</l>
<l>        Feature := Ra</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_rb ***</c>
<l>    Name := 'gray_rb'</l>
<l>    Groups := ['gray','rot_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis_gray (Region, Image, Ra, Rb, Phi)</l>
<l>        Feature := Rb</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_phi ***</c>
<l>    Name := 'gray_phi'</l>
<l>    Groups := ['gray','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        elliptic_axis_gray (Region, Image, Ra, Rb, Phi)</l>
<l>        Feature := Phi</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_min ***</c>
<l>    Name := 'gray_min'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        min_max_gray (Region, Image, 0, Min, Max, Range)</l>
<l>        Feature := Min</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_max ***</c>
<l>    Name := 'gray_max'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        min_max_gray (Region, Image, 0, Min, Max, Range)</l>
<l>        Feature := Max</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_range ***</c>
<l>    Name := 'gray_range'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        min_max_gray (Region, Image, 0, Min, Max, Range)</l>
<l>        Feature := Range</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * TEXTURE</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_mean ***</c>
<l>    Name := 'gray_mean'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        intensity (Region, Image, Mean, Deviation)</l>
<l>        Feature := Mean</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_deviation ***</c>
<l>    Name := 'gray_deviation'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        intensity (Region, Image, Mean, Deviation)</l>
<l>        Feature := Deviation</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_plane_deviation ***</c>
<l>    Name := 'gray_plane_deviation'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        plane_deviation (Region, Image, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_anisotropy ***</c>
<l>    Name := 'gray_anisotropy'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        entropy_gray (Region, Image, Entropy, Anisotropy)</l>
<l>        Feature := Anisotropy</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_entropy ***</c>
<l>    Name := 'gray_entropy'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        entropy_gray (Region, Image, Entropy, Anisotropy)</l>
<l>        Feature := Entropy</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_hor_proj ***</c>
<l>    Name := 'gray_hor_proj'</l>
<l>    Groups := ['gray','texture','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Size := 20</l>
<l>        calc_feature_gray_proj (Region, Image, 'hor', Size, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_vert_proj ***</c>
<l>    Name := 'gray_vert_proj'</l>
<l>    Groups := ['gray','texture','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Size := 20</l>
<l>        calc_feature_gray_proj (Region, Image, 'vert', Size, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_hor_proj_histo ***</c>
<l>    Name := 'gray_hor_proj_histo'</l>
<l>    Groups := ['gray','texture','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Size := 20</l>
<l>        calc_feature_gray_proj (Region, Image, 'hor_histo', Size, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** gray_vert_proj_histo ***</c>
<l>    Name := 'gray_vert_proj_histo'</l>
<l>    Groups := ['gray','texture','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Size := 20</l>
<l>        calc_feature_gray_proj (Region, Image, 'vert_histo', Size, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** grad_dir_histo ***</c>
<l>    Name := 'grad_dir_histo'</l>
<l>    Groups := ['gray','texture']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumBins := 20</l>
<l>        calc_feature_grad_dir_histo (Region, Image, NumBins, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** edge_density ***</c>
<l>    Name := 'edge_density'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_edge_density (Region, Image, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** edge_density_histogram ***</c>
<l>    Name := 'edge_density_histogram'</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumBins := 4</l>
<l>        calc_feature_edge_density_histogram (Region, Image, NumBins, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** edge_density_pyramid ***</c>
<l>    NameRegExp := 'edge_density_pyramid_([234])'</l>
<l>    Names := 'edge_density_pyramid_' + [2:4]</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (CurrentName =~ NameRegExp)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumPyramids := number(regexp_match(CurrentName,NameRegExp))</l>
<l>        calc_feature_pyramid (Region, Image, 'edge_density', NumPyramids, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups_pyramid (Mode, Groups, CurrentName, Names, NameRegExp, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** edge_density_histogram_pyramid ***</c>
<l>    NameRegExp := 'edge_density_histogram_pyramid_([234])'</l>
<l>    Names := 'edge_density_histogram_pyramid_' + [2:4]</l>
<l>    Groups := ['gray','texture','rot_invar','scale_invar']</l>
<c>    * ****************</c>
<l>    if (CurrentName =~ NameRegExp)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumPyramids := number(regexp_match(CurrentName,NameRegExp))</l>
<l>        calc_feature_pyramid (Region, Image, 'edge_density_histogram', NumPyramids, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups_pyramid (Mode, Groups, CurrentName, Names, NameRegExp, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** cooc ***</c>
<l>    Name := 'cooc'</l>
<l>    Groups := ['gray','texture']</l>
<c>    * ****************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Feature := []</l>
<l>        cooc_feature_image (Region, Image, 6, 0, Energy, Correlation, Homogeneity, Contrast)</l>
<l>        if (NumRegions &gt; 0)</l>
<l>            Index := [0:4:4 * NumRegions - 1]</l>
<l>            Feature[Index] := Energy</l>
<l>            Feature[1 + Index] := Correlation</l>
<l>            Feature[2 + Index] := Homogeneity</l>
<l>            Feature[3 + Index] := Contrast</l>
<l>        endif</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** cooc_pyramid ***</c>
<l>    NameRegExp := 'cooc_pyramid_([234])'</l>
<l>    Names := 'cooc_pyramid_' + [2:4]</l>
<l>    Groups := ['gray','texture']</l>
<c>    * ****************</c>
<l>    if (CurrentName =~ NameRegExp)</l>
<c>        * ** Calculate feature ***</c>
<l>        NumPyramids := number(regexp_match(CurrentName,NameRegExp))</l>
<l>        calc_feature_pyramid (Region, Image, 'cooc', NumPyramids, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups_pyramid (Mode, Groups, CurrentName, Names, NameRegExp, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * </c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * POLAR TRANSFORM FEATURES</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_gray_proj ***</c>
<l>    Name := 'polar_gray_proj'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'hor_gray', Width, Height, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_grad_proj ***</c>
<l>    Name := 'polar_grad_proj'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'hor_sobel_amp', Width, Height, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_grad_x_proj ***</c>
<l>    Name := 'polar_grad_x_proj'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'hor_sobel_x', Width, Height, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_grad_y_proj ***</c>
<l>    Name := 'polar_grad_y_proj'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'hor_sobel_y', Width, Height, Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** polar_gray_proj_histo ***</c>
<l>    Name := 'polar_gray_proj_histo'</l>
<l>    Groups := ['gray','rot_invar','scale_invar']</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        Width := 100</l>
<l>        Height := 40</l>
<l>        calc_feature_polar_gray_proj (Region, Image, 'vert_gray', Width, Height, Projection)</l>
<l>        NumBins := 20</l>
<l>        Feature := []</l>
<l>        for Index := 1 to NumRegions by 1</l>
<l>            Start := (Index - 1) * Width</l>
<l>            tuple_histo_range (Projection[Start:Start + Width - 1], 0, 255, NumBins, Histo, BinSize)</l>
<l>            Feature := [Feature,Histo]</l>
<l>        endfor</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * COLOR FEATURES</c>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** cielab_mean ***</c>
<l>    Name := 'cielab_mean'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'cielab', 'mean', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** cielab_dev ***</c>
<l>    Name := 'cielab_dev'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'cielab', 'deviation', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** hls_mean ***</c>
<l>    Name := 'hls_mean'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'hls', 'mean', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** hls_dev ***</c>
<l>    Name := 'hls_dev'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'hls', 'deviation', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rgb_mean ***</c>
<l>    Name := 'rgb_mean'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'rgb', 'mean', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<c>    * ************************************</c>
<c>    * </c>
<c>    * ************************************</c>
<c>    * ** rgb_dev ***</c>
<l>    Name := 'rgb_dev'</l>
<l>    Groups := 'color'</l>
<c>    * *************</c>
<l>    if (Name == CurrentName)</l>
<c>        * ** Calculate feature ***</c>
<l>        calc_feature_color_intensity (Region, Image, 'rgb', 'deviation', Feature)</l>
<c>        * *************************</c>
<l>        append_length_or_values (Mode, Feature, AccumulatedResults, ExtendedResults)</l>
<l>        AccumulatedResults := ExtendedResults</l>
<l>    endif</l>
<l>    append_names_or_groups (Mode, Name, Groups, CurrentName, AccumulatedResults, ExtendedResults)</l>
<l>    AccumulatedResults := ExtendedResults</l>
<l>endfor</l>
<l>Output := AccumulatedResults</l>
<l>set_system ('empty_region_result', EmptyRegionResult)</l>
<l>return ()</l>
</body>
<docu id="get_features">
<abstract lang="en_US">This procedure contains all feature names, the groups they belong to and the code how to calculate them.

It is designed in a way, that it can be easily used to handle user-defined features. 
The user-defined features have to be defined in an external procedure get_custom_features.hdvp (See there for detailed instructions).

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

Currently, get_features supports the following features (associated groups in parenthesis):

'area' ('REGION','ROT_INVAR'): Area of the region (see area_center).

'width' ('REGION'): Width of the region (see smallest_rectangle1).

'height' ('height'): Height of the region (see smallest_rectangle1).

'ra' ('REGION','ROT_INVAR'): Main radius of the equivalent ellipse (see elliptic_axis).

'rb' ('REGION','ROT_INVAR'): Secondary radius of the equivalent ellipse (see elliptic_axis).

'phi' ('REGION','SCALE_INVAR'): Orientation of the equivalent ellipse (see elliptic_axis).

'roundness' ('REGION','ROT_INVAR','SCALE_INVAR'): Roundness (see roundness).

'num_sides' ('REGION','ROT_INVAR','SCALE_INVAR'): Number of polygon sides (see roundness).

'num_connected' ('REGION','ROT_INVAR','SCALE_INVAR'): Number of connection components (see connect_and_holes).

'num_holes' ('REGION','ROT_INVAR','SCALE_INVAR'): Number of holes (see connect_and_holes).

'area_holes' ('REGION','ROT_INVAR'): Area of the holes of the object (see area_holes).

'max_diameter' ('REGION','ROT_INVAR'): Maximum diameter of the region (see diameter_region).

'orientation' ('REGION','SCALE_INVAR'): Orientation of the region (see orientation_region).

'outer_radius' ('REGION','ROT_INVAR'): Radius of smallest surrounding circle (see smallest_circle).

'inner_radius' ('REGION','ROT_INVAR'): Radius of largest inner circle (see inner_circle).

'inner_width' ('REGION'): Width of the largest axis-parallel rectangle that fits into the region (see inner_rectangle1).

'inner_height' ('REGION'): Height of the largest axis-parallel rectangle that fits into the region (see (see inner_rectangle1).

'circularity' ('REGION','ROT_INVAR','SCALE_INVAR'): Circularity (see circularity).

'compactness' ('REGION','ROT_INVAR','SCALE_INVAR'): Compactness (see compactness).

'convexity' ('REGION','ROT_INVAR','SCALE_INVAR'): Convexity (see convexity).

'rectangularity' ('REGION','ROT_INVAR','SCALE_INVAR'): Rectangularity (see rectangularity).

'anisometry: ('REGION','ROT_INVAR','SCALE_INVAR')' Anisometry (see eccentricity).

'bulkiness: ('REGION','ROT_INVAR','SCALE_INVAR')' Bulkiness (see eccentricity).

'struct_factor: ('REGION','ROT_INVAR','SCALE_INVAR')' Structur Factor (see eccentricity).

'dist_mean' ('REGION','ROT_INVAR'): Mean distance from the region border to the center (see roundness).

'dist_deviation': ('REGION','ROT_INVAR') Deviation of the distance from the region border from the center (see roundness).

'euler_number' ('REGION','ROT_INVAR','SCALE_INVAR'): Euler number (see euler_number).

'rect2_phi' ('REGION','SCALE_INVAR'): Orientation of the smallest surrounding rectangle (see smallest_rectangle2).

'rect2_len1' ('REGION','ROT_INVAR'): Half the length of the smallest surrounding rectangle (see smallest_rectangle2).

'rect2_len2' ('REGION','ROT_INVAR'): Half the width of the smallest surrounding rectangle (see smallest_rectangle2).

'contlength' ('REGION','ROT_INVAR'): Total length of the region's contour (see contlength).

'poriosity' ('REGION','ROT_INVAR','SCALE_INVAR'): Ratio of the area of the holes to the region area.

'gray_area' ('GRAY','ROT_INVAR'): Gray-value volume of region (see area_center_gray).

'gray_ra' ('GRAY','ROT_INVAR'): Major axis of equivallent ellipse (see elliptic_axis_gray).

'gray_rb' ('GRAY','ROT_INVAR'): Minor axis of equivallent ellipse (see elliptic_axis_gray).

'gray_phi' ('GRAY','SCALE_INVAR'): Orientation of equivallent ellipse (see elliptic_axis_gray).

'gray_min' ('GRAY','ROT_INVAR','SCALE_INVAR'): Minimum gray value (see min_max_gray).

'gray_max' ('GRAY','ROT_INVAR','SCALE_INVAR'): Maximum gray value (see min_max_gray).

'gray_range' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value range.

'gray_mean' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Mean gray value (see intensity).

'gray_deviation' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Deviation of gray values (see intensity).

'gray_plane_deviation' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Deviation from the approximating plane (see plane_deviation).

'gray_anisotropy' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Anisotropy (see entropy_gray).

'gray_entropy' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Entropy (see entropy_gray).

'gray_hor_proj' ('GRAY','TEXTURE','SCALE_INVAR'): Horizontal gray-value projection.

'gray_vert_proj' ('GRAY','TEXTURE','SCALE_INVAR'): Vertical gray-value projection.

'gray_hor_proj_histo' ('GRAY','TEXTURE','SCALE_INVAR'): Histogram of horizontal gray-value projection.

'gray_vert_proj_histo' ('GRAY','TEXTURE','SCALE_INVAR'): Histogram of horizontal gray-value projection.

'grad_dir_histo' ('GRAY','TEXTURE'): Gradient direction histogram.

'edge_density' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Ratio of the gray-value volume of the edge image to the region area.

'edge_density_pyramid_[234]' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Edge density for 2, 3, or 4 pyramid levels.

'edge_density_histogram' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Ratio of the gray-value histogram of the edge image to the region area.

'edge_density_histogram_pyramid_[234]' ('GRAY','TEXTURE','ROT_INVAR','SCALE_INVAR'): Edge density histogram for 2, 3, or 4 pyramid levels.

'cooc' ('GRAY','TEXTURE'): Energy, correlation, local homogeneity, and contrast of co-occurrance matrix (see cooc_feature_matrix).

'cooc_pyramid_[234]' ('GRAY','TEXTURE'): 'cooc' feature for 2, 3, or 4 pyramid levels.

'polar_gray_proj' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value projection along the tangential axis of the polar-transformed image.

'polar_grad_proj' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value projection along the tangential axis of the polar-transformed edge image.

'polar_grad_x_proj' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value projection along the tangential axis of the polar-transformed derivative in x direction.

'polar_grad_y_proj' ('GRAY','ROT_INVAR','SCALE_INVAR'): Gray-value projection along the tangential axis of the polar-transformed derivative in y direction.

'polar_gray_proj_histo' ('GRAY','ROT_INVAR','SCALE_INVAR'): Histogram of the gray-value projection along the radial axis of the polar-transformed image.

'cielab_mean' ('COLOR'): Mean gray values of the L, A, and B channel.

'cielab_dev' ('COLOR'): Gray value deviation of the L, A, and B channel.

'hls_mean' ('COLOR'): Mean gray values of the H, L, and S channel.

'hls_dev' ('COLOR'): Gray value deviation of the H, L, and S channel.

'rgb_mean' ('COLOR'): Mean gray values of the R, G, and B channel.

'rgb_dev' ('COLOR'): Gray value deviation of the R, G, and B channel.</abstract>
<alternatives>
<item>get_custom_features</item>
</alternatives>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calculate_features</item>
<item>get_feature_names</item>
<item>get_feature_lengths</item>
<item>query_feature_names_by_group</item>
<item>query_feature_group_names</item>
</see_also>
<short lang="en_US">This procedure contains all relevant information about the supported features.</short>
<parameters>
<parameter id="Image">
<description lang="en_US">Input image.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Mode">
<default_type>string</default_type>
<description lang="en_US">Calculation mode.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'get_names'</item>
<item>'get_groups'</item>
<item>'get_length'</item>
<item>'calculate'</item>
</value_list>
</parameter>
<parameter id="Namelist">
<default_type>string</default_type>
<description lang="en_US">Feature names or feature group names</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Output">
<default_type>real</default_type>
<description lang="en_US">Feature names, feature vector, feature vector lengths, or group names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Region">
<description lang="en_US">Region to be examined.</description>
<multivalue>optional</multivalue>
<sem_type>region</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_nearest_finder_pattern_coordinates">
<interface>
<io>
<par name="CalibPlateImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="RowNearFinderPattern" base_type="ctrl" dimension="0"/>
<par name="ColumNearFinderPattern" base_type="ctrl" dimension="0"/>
<par name="CalibObjectData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RowFinderPattern" base_type="ctrl" dimension="0"/>
<par name="ColumnFinderPattern" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*</c>
<l>read_message_tuple (CalibObjectData, 'CamParam', CamParam)</l>
<l>read_message_tuple (CalibObjectData, 'CalPlateDescr', CalPlateDescr)</l>
<l>read_message_tuple (CalibObjectData, 'MarksPerRow', MarksPerRow)</l>
<l>read_message_tuple (CalibObjectData, 'FinderRow', FinderRow)</l>
<l>read_message_tuple (CalibObjectData, 'FinderColumn', FinderColumn)</l>
<c>*</c>
<c>* Check input.</c>
<c>*</c>
<c>* Check image coordinates.</c>
<l>if (|RowNearFinderPattern| &gt; 1 or |ColumNearFinderPattern| &gt; 1)</l>
<l>    throw ('Please specify only one image coordinate.')</l>
<l>endif</l>
<c>* Check number of marks per row.</c>
<l>if (MarksPerRow &lt; 3)</l>
<l>    throw ('At least three marks per row are necessary for a valid finder pattern.')</l>
<l>endif</l>
<c>* Find calibration plate.</c>
<l>create_calib_data ('calibration_object', 1, 1, CalibDataID)</l>
<l>set_calib_data_cam_param (CalibDataID, 0, [], CamParam)</l>
<l>set_calib_data_calib_object (CalibDataID, 0, CalPlateDescr)</l>
<l>try</l>
<l>    find_calib_object (CalibPlateImage, CalibDataID, 0, 0, 0, [], [])</l>
<l>catch (Exception)</l>
<l>    throw ('Calibration plate could not be find, please make sure that at least one finder pattern is visible.')</l>
<l>endtry</l>
<l>get_calib_data_observ_points (CalibDataID, 0, 0, 0, Row, Column, Index1, Pose)</l>
<l>get_calib_data_observ_contours (Contours, CalibDataID, 'caltab', 0, 0, 0)</l>
<c>* Get the finder pattern used to find the calibration plate.</c>
<l>gen_region_contour_xld (Contours, Region, 'filled')</l>
<l>union1 (Region, RegionUnion)</l>
<l>area_center (RegionUnion, Area1, Row2, Column2)</l>
<l>RowTmp := abs(Row - Row2)</l>
<l>ColTmp := abs(Column - Column2)</l>
<l>Diff := sqrt(RowTmp * RowTmp + ColTmp * ColTmp)</l>
<l>tuple_find (Diff, min(Diff), IndexFinal)</l>
<l>RowToApproach1 := Row[IndexFinal]</l>
<l>ColToApproach1 := Column[IndexFinal]</l>
<l>clear_calib_data (CalibDataID)</l>
<c>* Get remaining finder pattern.</c>
<c>*</c>
<c>* Get finder pattern in world coordinates.</c>
<l>caltab_points (CalPlateDescr, XCal, YCal, ZCal)</l>
<l>XFP := XCal[FinderRow*MarksPerRow + FinderColumn]</l>
<l>YFP := YCal[FinderRow*MarksPerRow + FinderColumn]</l>
<c>* Get finder pattern in camera coordinates.</c>
<l>pose_to_hom_mat3d (Pose, HomMat3D)</l>
<l>tuple_gen_const (|XFP|, 0.0, ZFP)</l>
<l>affine_trans_point_3d (HomMat3D, XFP, YFP, ZFP, X1, Y1, Z1)</l>
<c>* Project into the image.</c>
<l>project_3d_point (X1, Y1, Z1, CamParam, Row, Column)</l>
<c> *</c>
<c>* Get the image coordinates that are the closest ones to the passed ones.</c>
<l>RowTmp := abs(Row - RowNearFinderPattern)</l>
<l>ColTmp := abs(Column - ColumNearFinderPattern)</l>
<l>Diff := sqrt(RowTmp * RowTmp + ColTmp * ColTmp)</l>
<l>tuple_find (Diff, min(Diff), IndexFinal)</l>
<c>* Return the image coordinates.</c>
<l>RowFinderPattern := Row[IndexFinal]</l>
<l>ColumnFinderPattern := Column[IndexFinal]</l>
<l>return ()</l>
</body>
<docu id="get_nearest_finder_pattern_coordinates">
<abstract lang="en_US">This procedure returns the image coordinates of the central mark of the finder pattern (RowFinderPattern, ColumnFinderPattern) in the CalibPlateImage that is the closest one to the passed image coordinates in the parameters RowNearFinderPattern and ColumnNearFinderPattern.

The message CalibObjectData must contain the parameters CamParam, CalPlateDescr, MarksPerRow, FinderRow and FinderColumn.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>calibrate_camera_and_plane_single_image</item>
<item>get_mbutton_sub_pix</item>
</predecessor>
<short lang="en_US">Get the coordinates of the central mark of the closest finder pattern.</short>
<successor>
<item>calibrate_hand_eye_stationary_cam</item>
</successor>
<parameters>
<parameter id="CalibObjectData">
<default_type>integer</default_type>
<description lang="en_US">Calibration data.</description>
<mixed_type>false</mixed_type>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CalibPlateImage">
<description lang="en_US">Image of the calibration plate describing the measurement plane.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>uint2</item>
</type_list>
</parameter>
<parameter id="ColumNearFinderPattern">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Column coordinate near the touching point / central mark of the approached finder pattern.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ColumnFinderPattern">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the central mark of the closest finder pattern.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="RowFinderPattern">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the central mark of the closest finder pattern.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="RowNearFinderPattern">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Row coordinate near the touching point / central mark of the approached finder pattern.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_object_models_center">
<interface>
<ic>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Center" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Compute the mean of all model centers (weighted by the diameter of the object models)</c>
<l>if (|ObjectModel3DID| &gt; 0)</l>
<l>    get_object_model_3d_params (ObjectModel3DID, 'diameter_axis_aligned_bounding_box', Diameter)</l>
<c>    * Normalize Diameter to use it as weights for a weighted mean of the individual centers</c>
<l>    MD := mean(Diameter)</l>
<l>    if (MD &gt; 1e-10)</l>
<l>        Weight := Diameter / MD</l>
<l>    else</l>
<l>        Weight := Diameter</l>
<l>    endif</l>
<l>    SumW := sum(Weight)</l>
<l>    if (SumW &lt; 1e-10)</l>
<l>        Weight := gen_tuple_const(|Weight|,1.0)</l>
<l>        SumW := sum(Weight)</l>
<l>    endif</l>
<l>    Center := [0,0,0]</l>
<l>    for Index := 0 to |ObjectModel3DID| - 1 by 1</l>
<l>        ObjectModel3DIDSelected := ObjectModel3DID[Index]</l>
<l>        get_object_model_3d_params (ObjectModel3DIDSelected, 'center', C)</l>
<l>        Center[0] := Center[0] + C[0] * Weight[Index]</l>
<l>        Center[1] := Center[1] + C[1] * Weight[Index]</l>
<l>        Center[2] := Center[2] + C[2] * Weight[Index]</l>
<l>    endfor</l>
<l>    InvSum := 1.0 / SumW</l>
<l>    Center[0] := Center[0] * InvSum</l>
<l>    Center[1] := Center[1] * InvSum</l>
<l>    Center[2] := Center[2] * InvSum</l>
<l>else</l>
<l>    Center := []</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_object_models_center">
<abstract lang="en_US">get_object_models_center computes the center of all given 3D object models.

The center is computed as the weighted mean of all centers of the individual 3D object models. The weighting ensures that larger 3D object models have an higher impact on the calculated center.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">read_object_model_3d ('pipe_joint', 'm', [], [], ObjectModel3D, Status)
CamParam := [0.1,0,6e-6,6e-6,256,256,512,512]
dev_resize_window_fit_size (0, 0, CamParam[6]-1, CamParam[7]-1, -1, -1)
get_object_models_center (ObjectModel3D, Center)
create_pose (-Center[0], -Center[1], -Center[2], 135, 0, 0, \
             'Rp+T', 'gba', 'point', PoseIn)
determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, PoseIn, \
                                 PoseEstimated)
dev_get_window (WindowHandle)
disp_object_model_3d (WindowHandle, ObjectModel3D, \
                      CamParam, PoseEstimated, [], [])</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_object_model_3d</item>
</predecessor>
<see_also>
<item>determine_optimum_pose_distance</item>
<item>disp_object_model_3d</item>
</see_also>
<short lang="en_US">Compute the center of all given 3D object models.</short>
<successor>
<item>create_pose</item>
<item>determine_optimum_pose_distance</item>
</successor>
<parameters>
<parameter id="Center">
<default_type>real</default_type>
<description lang="en_US">Center of the 3D object models.</description>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ObjectModel3DID">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_robot_touching_point_in_tool_coordinates">
<interface>
<ic>
<par name="ToolInBasePosesTouchingPoint" base_type="ctrl" dimension="1"/>
</ic>
<oc>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* To estimate the touching point with respect to the tool coordinate system, we have to</c>
<c>* arrange three equations in the following form:</c>
<c>* Rp + T = q,</c>
<c>* where R is a is the rotation matrix that rotates a point from the tool to the base coordinate</c>
<c>* system and T is a translation that translates a point from the tool to the base coordinate.</c>
<c>* q is the touching point with respect to the base coordinate system</c>
<c>* and p the unknown touching point with respect to the tool coordinate system.</c>
<c>*</c>
<c>* Approaching the same point three times while rotating the tool leads to three rotation matrices</c>
<c>* R0, R1 and R2 and three translations T0, T1 and T2.</c>
<c>* Solving this equation for the unknown touching point yields therefore:</c>
<c>* R0*p + T0 = q, R1*p + T1 = q and R2*p + T2 = q.</c>
<c>* After building two equations in the form (R1-R0)*p = T0-T1 and (R2-R0)*p = T0-T2,</c>
<c>* the DLT (direct linear transformation) can be used to efficiently solve for the unknown</c>
<c>* touching point p.</c>
<c></c>
<c></c>
<c>* Check input.</c>
<l>if (ToolInBasePosesTouchingPoint.length() &lt; 3)</l>
<l>    throw ('Please specify at least three robot poses.')</l>
<l>endif</l>
<c></c>
<c>* Initialize equation.</c>
<l>create_matrix ((ToolInBasePosesTouchingPoint.length()-1)*3, 3, 0, LHS)</l>
<l>create_matrix ((ToolInBasePosesTouchingPoint.length()-1)*3, 1, 0, RHS)</l>
<l>RotationAxisRelativ := {[]}</l>
<l>DiffToIdentity := {[]}</l>
<c>* Decompose first pose.</c>
<l>pose_to_hom_mat3d (ToolInBasePosesTouchingPoint.at(0), HomMat3D0)</l>
<l>create_matrix (3, 4, HomMat3D0, Mat0)</l>
<l>get_sub_matrix (Mat0, 0, 0, 3, 3, MatRot0)</l>
<l>get_sub_matrix (Mat0, 0, 3, 3, 1, MatTrans0)</l>
<c>* </c>
<l>for Index := 1 to ToolInBasePosesTouchingPoint.length()-1 by 1</l>
<c>    * Decompose current pose.</c>
<l>    pose_to_hom_mat3d (ToolInBasePosesTouchingPoint.at(Index), HomMat3D)</l>
<l>    create_matrix (3, 4, HomMat3D, Mat)</l>
<l>    get_sub_matrix (Mat, 0, 0, 3, 3, MatRot)</l>
<l>    get_sub_matrix (Mat, 0, 3, 3, 1, MatTrans)</l>
<c>    * Get rotation axis relativ to first pose.</c>
<l>    get_rotation_axis (MatRot, MatRot0, RotationAxisRelativ.at(Index), DiffToIdentity.at(Index))</l>
<c>    * Fill equation.</c>
<l>    sub_matrix_mod (MatRot, MatRot0)</l>
<l>    set_sub_matrix (LHS, MatRot, (Index-1)*3, 0)</l>
<l>    sub_matrix_mod (MatTrans, MatTrans0)</l>
<l>    scale_matrix_mod (MatTrans, -1.0)</l>
<l>    set_sub_matrix (RHS, MatTrans, (Index-1)*3, 0)</l>
<c>    * Clear.</c>
<l>    clear_matrix (Mat)</l>
<l>    clear_matrix (MatRot)</l>
<l>    clear_matrix (MatTrans)</l>
<l>endfor</l>
<c>* Solve.</c>
<l>solve_matrix (LHS, 'general', 0, RHS, MatrixResultID)</l>
<l>get_full_matrix (MatrixResultID, RobotTouchingPointInToolCoordinates)</l>
<c>* Detailed errors.</c>
<l>DetailedErrors := 0</l>
<l>if (DetailedErrors)</l>
<c>    * Check that the tool was tilted enough compared to the first pose.</c>
<l>    MinDiffToIdentity := 1e8</l>
<l>    for Index := 1 to ToolInBasePosesTouchingPoint.length()-1 by 1</l>
<l>        if (DiffToIdentity.at(Index)&lt;MinDiffToIdentity)</l>
<l>            MinDiffToIdentity := DiffToIdentity.at(Index)</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Check that different rotation axis were used when tilted away from first pose.</c>
<l>    MinCosAngle := 1.5</l>
<l>    for Index := 1 to ToolInBasePosesTouchingPoint.length()-2 by 1</l>
<l>        for Index1 := Index+1 to ToolInBasePosesTouchingPoint.length()-1 by 1</l>
<l>            CosAngle := abs(sum(RotationAxisRelativ.at(Index)*RotationAxisRelativ.at(Index1)))</l>
<l>            if (CosAngle&lt;MinCosAngle)</l>
<l>                MinCosAngle := CosAngle</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<l>    MaxAngleBetweenRotationAxes := deg(acos(MinCosAngle))</l>
<l>endif</l>
<l>svd_matrix (LHS, 'full', 'both', MatrixUID, MatrixSID, MatrixVID)</l>
<l>get_value_matrix (MatrixSID, [0,1,2], [0,1,2], SingularValues)</l>
<l>MinSingularValue := min(abs(SingularValues))</l>
<l>if (MinSingularValue &lt; 0.15)</l>
<c>    * Consider the rotations of the tool from its first position to each following position.</c>
<c>    * Please rotate the tool enough away from the first position.</c>
<c>    * Furthermore, please use at least two significantly different rotation axis when rotating the tool</c>
<c>    * from its first position (preferably orthogonal directions?).</c>
<c>    * The maximum angle between the corresponding rotation axis is MaxAngleBetweenRotationAxes.</c>
<c>    *   </c>
<l>    throw ('The estimated touching point might not be reliable. Try to use at least two different rotation axis and/or increase the rotations around these axis.')</l>
<l>endif</l>
<c>* </c>
<c>* Clear.</c>
<l>clear_matrix (MatrixUID)</l>
<l>clear_matrix (MatrixSID)</l>
<l>clear_matrix (MatrixVID)</l>
<l>clear_matrix (Mat0)</l>
<l>clear_matrix (MatRot0)</l>
<l>clear_matrix (MatTrans0)</l>
<l>clear_matrix (LHS)</l>
<l>clear_matrix (RHS)</l>
<l>return ()</l>
</body>
<docu id="get_robot_touching_point_in_tool_coordinates">
<abstract lang="en_US">This procedure calculates the touching point with respect to the tool coordinate system.

The touching point is a point that has to be fixed with respect to to the tool coordinate system but does not have to be located on the surface of the gripper. It can e.g. lie halfway between two fingers of a gripper.

To determine the touching point, choose a fixed point in the real setup that can be approached easily and accurately. Approach this point with the touching point and register the corresponding tool pose with respect to the base coordinate system. Repeat this at least two times, rotating the tool around at least two axis and register the tool poses.

With the three robot poses approaching the same point, it is possible to arrange the following three equations:
 R0*p + T0 = q
 R1*p + T1 = q 
 R2*p + T2 = q,

where R0, R1 and R2 are the rotation matrices that rotate a point from the tool to the base coordinate system and T0, T1 and T2 are the translations that translate a point from the tool to the base coordinate.
q is the touching point with respect to the base coordinate system and p the unknown touching point with respect to the tool coordinate system.

Solving the above equations for the unknown touching point p yields
(R1-R0)*p = T0-T1 and (R2-R0)*p = T0-T2 that can be solved efficiently using the DLT (direct linear transformation).

The calculated touching point is returned in the parameter RobotTouchingPointInToolCoordinates and describes the point with respect to the robot's tool coordinate system.
    </abstract>
<alternatives>
<item>calibrate_robot_touching_point</item>
</alternatives>
<chapters lang="de_DE">
<item>Transformationen</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Transformations</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_pose</item>
</predecessor>
<short lang="en_US">Calculate the touching point in tool coordinates.</short>
<successor>
<item>visualize_calibrated_touching_point</item>
</successor>
<parameters>
<parameter id="RobotTouchingPointInToolCoordinates">
<default_type>real</default_type>
<description lang="en_US">Touching point with respect to the tool coordinate system.</description>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[]</item>
</values>
</parameter>
<parameter id="ToolInBasePosesTouchingPoint">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Poses of the robot's tool with respect to robot's base.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_rotation_axis" access="local">
<interface>
<ic>
<par name="MatRot" base_type="ctrl" dimension="0"/>
<par name="MatRot0" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="RotationAxis" base_type="ctrl" dimension="0"/>
<par name="DiffToIdentity" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Get (R_i)^(-1)R_0</c>
<l>mult_matrix (MatRot, MatRot0, 'ATB', MatrixMultID)</l>
<c>* Get some measure for how far the matrix is from the identity.</c>
<l>create_matrix (3, 3, 'identity', Identity)</l>
<l>sub_matrix (MatrixMultID, Identity, MatrixSubID)</l>
<l>get_full_matrix (MatrixSubID, Values)</l>
<l>DiffToIdentity := sum(Values*Values)</l>
<c>* Get its rotation axis.</c>
<l>svd_matrix (MatrixSubID, 'full', 'both', MatrixUID, MatrixSID, MatrixVID)</l>
<l>get_value_matrix (MatrixSID, [0,1,2], [0,1,2], SingularValues)</l>
<l>AbsSingularValues := abs(SingularValues)</l>
<l>tuple_sort_index (AbsSingularValues, Indices)</l>
<l>get_value_matrix (MatrixVID, [0,1,2], [Indices[0], Indices[0], Indices[0]], RotationAxis)</l>
<c>* Clear matrices.</c>
<l>clear_matrix (MatrixMultID)</l>
<l>clear_matrix (MatrixUID)</l>
<l>clear_matrix (MatrixSID)</l>
<l>clear_matrix (MatrixVID)</l>
<l>clear_matrix (MatrixSubID)</l>
<l>clear_matrix (Identity)</l>
<l>return ()</l>
</body>
<docu id="get_rotation_axis">
<chapters lang="en_US">
<item>Matrix</item>
<item>Arithmetic</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="DiffToIdentity"/>
<parameter id="MatRot"/>
<parameter id="MatRot0"/>
<parameter id="RotationAxis"/>
</parameters>
</docu>
</procedure>
<procedure name="get_sheet_of_light_calib_object_dimensions">
<interface>
<ic>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Length" base_type="ctrl" dimension="0"/>
<par name="HeightMin" base_type="ctrl" dimension="0"/>
<par name="HeightMax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DiameterCircle" base_type="ctrl" dimension="0"/>
<par name="PyramidHeight" base_type="ctrl" dimension="0"/>
<par name="PyramidDistanceFromFront" base_type="ctrl" dimension="0"/>
<par name="PyramidBottomDiagonal" base_type="ctrl" dimension="0"/>
<par name="PyramidTopDiagonal" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*</c>
<c>* Constants:</c>
<l>CircleFactor := 0.075</l>
<l>PyramidBottomFactor := 0.9</l>
<l>PyramidTopFactor := 0.5</l>
<l>OffsetFactor := 0.1</l>
<l>MaxAngle := rad(45)</l>
<l>Pi := rad(180)</l>
<c>*</c>
<c>* Circle:</c>
<l>DiameterCircle := CircleFactor*Width</l>
<c>*</c>
<l>PyramidBottomDiagonal := Width*PyramidBottomFactor</l>
<l>PyramidTopDiagonal := PyramidBottomDiagonal * PyramidTopFactor</l>
<l>PyramidDistanceFromFront := 0.1 * Length + 0.5*PyramidBottomDiagonal</l>
<c>*</c>
<c>* Find the height of the truncated pyramid such that </c>
<c>* its highest point's Z coordinate is equal to HeightMax.</c>
<l>Height := HeightMax - HeightMin</l>
<l>Hypotenuse := sqrt(Length*Length + Height*Height)</l>
<l>CosAlpha := Length/Hypotenuse</l>
<l>SinAlpha := Height/Hypotenuse</l>
<l>Angle := acos(CosAlpha)</l>
<l>Dist := OffsetFactor*Length + 0.5*PyramidBottomDiagonal + 0.5*PyramidTopDiagonal</l>
<l>PyramidHeight1 := (Height-Dist*SinAlpha)/CosAlpha</l>
<c>*</c>
<c>* Limit the height of the pyramid such that the angle of </c>
<c>* its side planes to the ground plane is at most MaxAngle.</c>
<l>PyramidHeight2 := tan(MaxAngle)*0.5*(PyramidBottomDiagonal-PyramidTopDiagonal)</l>
<l>PyramidHeight := min2(PyramidHeight1, PyramidHeight2)</l>
<l>return ()</l>
</body>
<docu id="get_sheet_of_light_calib_object_dimensions">
<abstract lang="de_DE">Im Operatorreferenzeintrag von create_sheet_of_light_calib_object kann eine technische Zeichnung gefunden werden, die die hier berechneten Werte visualisiert.</abstract>
<abstract lang="en_US">See the reference entry of create_sheet_of_light_calib_object for a technical drawing which visualizes the calculated dimensions.</abstract>
<chapters lang="de_DE">
<item>3D-Rekonstruktion</item>
<item>Sheet-of-light</item>
</chapters>
<chapters lang="en_US">
<item>3D Reconstruction</item>
<item>Sheet of Light</item>
</chapters>
<example lang="de_DE">Width := 0.1
Length := 0.15
HeightMin := 0.005
HeightMax := 0.04
create_sheet_of_light_calib_object (Width, Length, HeightMin, HeightMax, 'calib_object.dxf')
get_sheet_of_light_calib_object_dimensions (Width, Length, HeightMin, HeightMax, DiameterCircle, \
                                            PyramidHeight, PyramidDistanceFromFront, PyramidBottomDiagonal, \
                                            PyramidTopDiagonal, Angle)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_sheet_of_light_calib_object</item>
</predecessor>
<short lang="de_DE">Berechnen der Abmessungen eines Kalibrierobjekts für die Lichtschnittkalibrierung.</short>
<short lang="en_US">Calculate the dimensions of a sheet-of-light calibration object.</short>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="de_DE">Winkel der schiefen Ebene.</description>
<description lang="en_US">Angle of the ramp.</description>
<sem_type>angle.rad</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="DiameterCircle">
<default_type>real</default_type>
<description lang="de_DE">Durchmesser der kreisförmigen Orientierungsmarkierung.</description>
<description lang="en_US">Diameter of the circular orientation mark.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="HeightMax">
<default_type>real</default_type>
<description lang="de_DE">Maximale Höhe der Grundebene.</description>
<description lang="en_US">Maximum height of the ramp.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="HeightMin">
<default_type>real</default_type>
<description lang="de_DE">Minimale Höhe der Grundebene.</description>
<description lang="en_US">Minimum height of the ramp.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Length">
<default_type>real</default_type>
<description lang="de_DE">Länge des Kalibrierkörpers.</description>
<description lang="en_US">Length of the calibration object.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PyramidBottomDiagonal">
<default_type>real</default_type>
<description lang="de_DE">Länge der Diagonalen an der Unterseite des Pyramidenstumpfes.</description>
<description lang="en_US">Length of the bottom diagonal of the truncated pyramid.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PyramidDistanceFromFront">
<default_type>real</default_type>
<description lang="de_DE">Abstand des Pyramidenstumpfes von der Vorderseite des Kalibrierkörpers.</description>
<description lang="en_US">Distance of the truncated pyramid from the front of the calibration object.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PyramidHeight">
<default_type>real</default_type>
<description lang="de_DE">Höhe des Pyramidenstumpfes.</description>
<description lang="en_US">Height of the truncated pyramid.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="PyramidTopDiagonal">
<default_type>real</default_type>
<description lang="de_DE">Länge der Diagonalen an der Oberseite des Pyramidenstumpfes.</description>
<description lang="en_US">Length of the top diagonal of the truncated pyramid.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Width">
<default_type>real</default_type>
<description lang="de_DE">Breite des Kalibrierkörpers.</description>
<description lang="en_US">Width of the calibration object.</description>
<sem_type>number</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="get_trackball_center" access="local">
<interface>
<ic>
<par name="SelectedObject" base_type="ctrl" dimension="0"/>
<par name="TrackballRadiusPixel" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TBCenter" base_type="ctrl" dimension="0"/>
<par name="TBSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>NumModels := |ObjectModel3D|</l>
<l>TBCenter[0] := 0</l>
<l>TBCenter[1] := 0</l>
<l>TBCenter[2] := 0</l>
<l>get_object_model_3d_params (ObjectModel3D, 'center', Centers)</l>
<l>get_object_model_3d_params (ObjectModel3D, 'diameter_axis_aligned_bounding_box', Diameter)</l>
<c>* Normalize Diameter to use it as weights for a weighted mean of the individual centers</c>
<l>MD := mean(Diameter)</l>
<l>if (MD &gt; 1e-10)</l>
<l>    Weight := Diameter / MD</l>
<l>else</l>
<l>    Weight := Diameter</l>
<l>endif</l>
<l>SumW := sum(select_mask(Weight,abs(sgn(SelectedObject))))</l>
<l>if (SumW &lt; 1e-10)</l>
<l>    Weight := gen_tuple_const(|Weight|,1.0)</l>
<l>    SumW := sum(select_mask(Weight,abs(sgn(SelectedObject))))</l>
<l>endif</l>
<l>for Index := 0 to NumModels - 1 by 1</l>
<l>    if (SelectedObject[Index])</l>
<l>        ObjectModel3DIDSelected := ObjectModel3D[Index]</l>
<l>        PoseSelected := Poses[Index * 7:Index * 7 + 6]</l>
<l>        pose_to_hom_mat3d (PoseSelected, HomMat3D)</l>
<l>        affine_trans_point_3d (HomMat3D, Centers[Index * 3 + 0], Centers[Index * 3 + 1], Centers[Index * 3 + 2], TBCenterCamX, TBCenterCamY, TBCenterCamZ)</l>
<l>        TBCenter[0] := TBCenter[0] + TBCenterCamX * Weight[Index]</l>
<l>        TBCenter[1] := TBCenter[1] + TBCenterCamY * Weight[Index]</l>
<l>        TBCenter[2] := TBCenter[2] + TBCenterCamZ * Weight[Index]</l>
<l>    endif</l>
<l>endfor</l>
<l>if (max(SelectedObject) != 0)</l>
<l>    InvSum := 1.0 / SumW</l>
<l>    TBCenter[0] := TBCenter[0] * InvSum</l>
<l>    TBCenter[1] := TBCenter[1] * InvSum</l>
<l>    TBCenter[2] := TBCenter[2] * InvSum</l>
<l>    TBSize := (0.5 + 0.5 * sum(SelectedObject) / NumModels) * TrackballRadiusPixel</l>
<l>else</l>
<l>    TBCenter := []</l>
<l>    TBSize := 0</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_trackball_center">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the center of the virtual trackback that is used to move the camera.</short>
<parameters>
<parameter id="ObjectModel3D"/>
<parameter id="Poses"/>
<parameter id="SelectedObject"/>
<parameter id="TBCenter"/>
<parameter id="TBSize"/>
<parameter id="TrackballRadiusPixel"/>
</parameters>
</docu>
</procedure>
<procedure name="get_trackball_center_fixed" access="local">
<interface>
<ic>
<par name="SelectedObject" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterRow" base_type="ctrl" dimension="0"/>
<par name="TrackballCenterCol" base_type="ctrl" dimension="0"/>
<par name="TrackballRadiusPixel" base_type="ctrl" dimension="0"/>
<par name="Scene3D" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3DID" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="WindowHandleBuffer" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TBCenter" base_type="ctrl" dimension="0"/>
<par name="TBSize" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Determine the trackball center for the fixed trackball</c>
<l>NumModels := |ObjectModel3DID|</l>
<l>get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>get_cam_par_data (CamParam, 'image_height', Height)</l>
<c>* </c>
<c>* Project the selected objects</c>
<l>SelectPose := []</l>
<l>for Index1 := 0 to |SelectedObject| - 1 by 1</l>
<l>    SelectPose := [SelectPose,gen_tuple_const(7,SelectedObject[Index1])]</l>
<l>    if (SelectedObject[Index1] == 0)</l>
<l>        set_scene_3d_instance_param (Scene3D, Index1, 'visible', 'false')</l>
<l>    endif</l>
<l>endfor</l>
<l>set_scene_3d_param (Scene3D, 'depth_persistence', 'true')</l>
<l>display_scene_3d (WindowHandleBuffer, Scene3D, 0)</l>
<l>set_scene_3d_param (Scene3D, 'visible', 'true')</l>
<c>* </c>
<c>* determine the depth of the object point that appears closest to the trackball</c>
<c>* center</c>
<l>gen_region_points (RegionCenter, TrackballCenterRow, TrackballCenterCol)</l>
<l>distance_transform (RegionCenter, DistanceImage, 'chamfer-3-4-unnormalized', 'false', Width, Height)</l>
<l>get_domain (DistanceImage, Domain)</l>
<l>get_region_points (Domain, Rows, Columns)</l>
<l>get_grayval (DistanceImage, Rows, Columns, Grayval)</l>
<l>tuple_sort_index (Grayval, IndicesG)</l>
<l>get_display_scene_3d_info (WindowHandleBuffer, Scene3D, subset(Rows,IndicesG), subset(Columns,IndicesG), 'depth', Value)</l>
<l>tuple_find (sgn(Value), 1, Pos)</l>
<c>* </c>
<l>set_scene_3d_param (Scene3D, 'depth_persistence', 'false')</l>
<c>* </c>
<c>* </c>
<c>* set TBCenter</c>
<l>if (Pos != -1)</l>
<c>    * if the object is visible in the image</c>
<l>    TBCenter := [0,0,Value[Pos[0]]]</l>
<l>else</l>
<c>    * if the object is not visible in the image, set the z coordinate to -1</c>
<c>    * to indicate, the the previous z value should be used instead</c>
<l>    TBCenter := [0,0,-1]</l>
<l>endif</l>
<c>* </c>
<l>if (max(SelectedObject) != 0)</l>
<l>    TBSize := (0.5 + 0.5 * sum(SelectedObject) / NumModels) * TrackballRadiusPixel</l>
<l>else</l>
<l>    TBCenter := []</l>
<l>    TBSize := 0</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="get_trackball_center_fixed">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get the center of the virtual trackback that is used to move the camera (version for inspection_mode = 'surface').</short>
<parameters>
<parameter id="CamParam"/>
<parameter id="GenParamName"/>
<parameter id="GenParamValue"/>
<parameter id="ObjectModel3DID"/>
<parameter id="Poses"/>
<parameter id="Scene3D"/>
<parameter id="SelectedObject"/>
<parameter id="TBCenter"/>
<parameter id="TBSize"/>
<parameter id="TrackballCenterCol"/>
<parameter id="TrackballCenterRow"/>
<parameter id="TrackballRadiusPixel"/>
<parameter id="WindowHandleBuffer"/>
</parameters>
</docu>
</procedure>
<procedure name="list_image_files">
<interface>
<ic>
<par name="ImageDirectory" base_type="ctrl" dimension="0"/>
<par name="Extensions" base_type="ctrl" dimension="0"/>
<par name="Options" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure returns all files in a given directory</c>
<c>* with one of the suffixes specified in Extensions.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* ImageDirectory: Directory or a tuple of directories with images.</c>
<c>*    If a local directory is not found, the directory is searched</c>
<c>*    under %HALCONIMAGES%/ImageDirectory. If %HALCONIMAGES% is not set,</c>
<c>*    %HALCONROOT%/images is used instead.</c>
<c>* Extensions: A string tuple containing the extensions to be found</c>
<c>*    e.g. ['png','tif',jpg'] or others</c>
<c>* If Extensions is set to 'default' or the empty string '',</c>
<c>*    all image suffixes supported by HALCON are used.</c>
<c>* Options: as in the operator list_files, except that the 'files'</c>
<c>*    option is always used. Note that the 'directories' option</c>
<c>*    has no effect but increases runtime, because only files are</c>
<c>*    returned.</c>
<c>* </c>
<c>* Output parameter:</c>
<c>* ImageFiles: A tuple of all found image file names</c>
<c>* </c>
<l>if (Extensions == [] or Extensions == '' or Extensions == 'default')</l>
<l>    Extensions := ['ima','tif','tiff','gif','bmp','jpg','jpeg','jp2','jxr','png','pcx','ras','xwd','pbm','pnm','pgm','ppm']</l>
<c>    * </c>
<l>endif</l>
<l>ImageFiles := []</l>
<c>* Loop through all given image directories.</c>
<l>for ImageDirectoryIndex := 0 to |ImageDirectory|-1 by 1</l>
<l>    ImageFilesTmp := []</l>
<l>    CurrentImageDirectory := ImageDirectory[ImageDirectoryIndex]</l>
<l>    if (CurrentImageDirectory == '')</l>
<l>        CurrentImageDirectory := '.'</l>
<l>    endif</l>
<l>    get_system ('image_dir', HalconImages)</l>
<l>    get_system ('operating_system', OS)</l>
<l>    if (OS{0:2} == 'Win')</l>
<l>        HalconImages := split(HalconImages,';')</l>
<l>    else</l>
<l>        HalconImages := split(HalconImages,':')</l>
<l>    endif</l>
<l>    Directories := CurrentImageDirectory</l>
<l>    for Index := 0 to |HalconImages| - 1 by 1</l>
<l>        Directories := [Directories,HalconImages[Index] + '/' + CurrentImageDirectory]</l>
<l>    endfor</l>
<l>    tuple_strlen (Directories, Length)</l>
<l>    tuple_gen_const (|Length|, false, NetworkDrive)</l>
<l>    if (OS{0:2} == 'Win')</l>
<l>        for Index := 0 to |Length| - 1 by 1</l>
<l>            if (strlen(Directories[Index]) &gt; 1)</l>
<l>                tuple_str_first_n (Directories[Index], 1, Substring)</l>
<l>                if (Substring == '//' or Substring == '\\\\')</l>
<l>                    NetworkDrive[Index] := true</l>
<l>                endif</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>    ImageFilesTmp := []</l>
<l>    for Index := 0 to |Directories| - 1 by 1</l>
<l>        file_exists (Directories[Index], FileExists)</l>
<l>        if (FileExists)</l>
<l>            list_files (Directories[Index], ['files',Options], AllFiles)</l>
<l>            ImageFilesTmp := []</l>
<l>            for i := 0 to |Extensions| - 1 by 1</l>
<l>                tuple_regexp_select (AllFiles, ['.*' + Extensions[i] + '$','ignore_case'], Selection)</l>
<l>                ImageFilesTmp := [ImageFilesTmp,Selection]</l>
<l>            endfor</l>
<l>            tuple_regexp_replace (ImageFilesTmp, ['\\\\','replace_all'], '/', ImageFilesTmp)</l>
<l>            if (NetworkDrive[Index])</l>
<l>                tuple_regexp_replace (ImageFilesTmp, ['//','replace_all'], '/', ImageFilesTmp)</l>
<l>                ImageFilesTmp := '/' + ImageFilesTmp</l>
<l>            else</l>
<l>                tuple_regexp_replace (ImageFilesTmp, ['//','replace_all'], '/', ImageFilesTmp)</l>
<l>            endif</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * Concatenate the output image paths.</c>
<l>    ImageFiles := [ImageFiles, ImageFilesTmp]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="list_image_files">
<abstract lang="en_US">This procedure returns all files in a given directory ImageDirectory with one of the suffixes specified in Extensions.

It is possible to use a tuple with multiple directories as input ImageDirectory. If a local directory is not found, the directory is searched under %HALCONIMAGES%/ImageDirectory. If %HALCONIMAGES% is not set, %HALCONROOT%/images is used instead.
If Extensions is set to 'default' or the empty string '', all image suffixes supported by HALCON are used.
The parameter Options is used as in the operator list_files (see list_files for details), except that the 'files' option is always used. Note that the 'directories' option has no effect but increases runtime, because only files are returned.</abstract>
<alternatives>
<item>list_files</item>
</alternatives>
<chapters>
<item>File</item>
</chapters>
<chapters lang="de_DE">
<item>Datei</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>File</item>
<item>Misc</item>
</chapters>
<example lang="en_US">list_image_files ('.',[] ,[] , ImageFiles)
for Index := 1 to |ImageFiles|  by 1
    read_image (Image,ImageFiles[Index-1])
*     do something
endfor</example>
<keywords lang="de_DE">
<item>Bilddateien auflisten</item>
</keywords>
<keywords lang="en_US">
<item>list image files</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>list_files</item>
</predecessor>
<see_also>
<item>list_files</item>
</see_also>
<short>Get all image files under the given path</short>
<short lang="de_DE">Get all image files under the given path</short>
<short lang="en_US">Get all image files under the given path</short>
<successor>
<item>read_image</item>
</successor>
<parameters>
<parameter id="Extensions">
<default_type>string</default_type>
<default_value>'default'</default_value>
<description lang="en_US">A string tuple containing the extensions to be found e.g. ['png','tif',jpg'] or others</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'ima'</item>
<item>'bmp'</item>
<item>'jpg'</item>
<item>'png'</item>
<item>'tiff'</item>
<item>'tif'</item>
<item>'gif'</item>
<item>'jpeg'</item>
<item>'pcx'</item>
<item>'pgm'</item>
<item>'ppm'</item>
<item>'pbm'</item>
<item>'xwd'</item>
<item>'pnm'</item>
</values>
</parameter>
<parameter id="ImageDirectory">
<default_type>string</default_type>
<description lang="en_US">The image directory</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="en_US">A tuple of all found image file names</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.read</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Options">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Processing options</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'recursive'</item>
<item>'follow_links'</item>
<item>'max_depth 5'</item>
</values>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="max_line_width" access="local">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Lines" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MaxWidth" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>MaxWidth := 0</l>
<l>for Index := 0 to |Lines| - 1 by 1</l>
<l>    get_string_extents (WindowHandle, Lines[Index], Ascent, Descent, LineWidth, LineHeight)</l>
<l>    MaxWidth := max([LineWidth,MaxWidth])</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="max_line_width">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Get string extends of several lines.</short>
<parameters>
<parameter id="Lines"/>
<parameter id="MaxWidth"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="obtain_3d_pose_of_match_moving_cam">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ModelInBasePose" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure obtains the 3D pose from the model to the base of</c>
<c>* the robot.</c>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (HandEyeCalibData, 'ToolInCamPose', ToolInCamPose)</l>
<l>read_message_tuple (Poses, 'PlaneInModelPose', PlaneInModelPose)</l>
<l>read_message_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage != 'no_rectification')</l>
<l>    read_message_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>endif</l>
<l>read_message_tuple (RectificationData, 'MatchingPlaneRectifiedPartInCamPose', MatchingPlaneRectifiedPartInCamPose)</l>
<c>*</c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (MatchingPlaneRectifiedPartInCamPose, 'Rp+T', 'gba', 'point', MatchingPlaneRectifiedPartInCamPose)</l>
<l>convert_pose_type (PlaneInModelPose, 'Rp+T', 'gba', 'point', PlaneInModelPose)</l>
<l>convert_pose_type (ToolInBasePose, 'Rp+T', 'gba', 'point', ToolInBasePose)</l>
<l>convert_pose_type (ToolInCamPose, 'Rp+T', 'gba', 'point', ToolInCamPose)</l>
<l>if (|Row| == 1)</l>
<l>    vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, HomMat2DObject)</l>
<c>    * Col = x, Row = y.</c>
<l>    if (RectifyImage = 'no_rectification')</l>
<l>        affine_trans_pixel (HomMat2DObject, 0, 0, RowObject, ColObject)</l>
<l>        image_points_to_world_plane (CamParam, MatchingPlaneRectifiedPartInCamPose, RowObject, ColObject, 'm', PXM, PYM)</l>
<l>        HomMat3DObject := [HomMat2DObject[4], HomMat2DObject[3], 0, PXM, HomMat2DObject[1], HomMat2DObject[0], 0, PYM, 0, 0, 1, 0]</l>
<l>        hom_mat3d_to_pose (HomMat3DObject, ModelToMatchInPlanePose)</l>
<l>        pose_compose (ModelToMatchInPlanePose, PlaneInModelPose, ModelInPlanePose)</l>
<l>        pose_compose (MatchingPlaneRectifiedPartInCamPose, ModelInPlanePose, ModelInCamPose)</l>
<l>    elseif (RectifyImage = 'only_rectify' or RectifyImage = 'align_and_rectify')</l>
<l>        HomMat3DObject := [HomMat2DObject[4], HomMat2DObject[3], 0, HomMat2DObject[5]*ScaleRectification, HomMat2DObject[1], HomMat2DObject[0], 0, HomMat2DObject[2]*ScaleRectification, 0, 0, 1, 0]</l>
<l>        hom_mat3d_to_pose (HomMat3DObject, ModelToMatchInPlanePartRectPose)</l>
<l>        pose_compose (ModelToMatchInPlanePartRectPose, PlaneInModelPose, ModelInMatchingPlaneRectifiedPartPose)</l>
<l>        pose_compose (MatchingPlaneRectifiedPartInCamPose, ModelInMatchingPlaneRectifiedPartPose, ModelInCamPose)</l>
<l>    else</l>
<l>        throw ('Please set the parameter RectifyImage correctly')</l>
<l>    endif</l>
<l>    pose_invert (ToolInBasePose, BaseInToolPose)</l>
<l>    pose_compose (ToolInCamPose, BaseInToolPose, BaseInCamPose)</l>
<l>    pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>    pose_compose (CamInBasePose, ModelInCamPose, ModelInBasePose)</l>
<c>    *</c>
<l>    convert_pose_type (ModelInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, ModelInBasePose)</l>
<l>else</l>
<l>    throw ('Exactly one match should be given as input')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="obtain_3d_pose_of_match_moving_cam">
<abstract lang="en_US">This procedure obtains the pose of the matched model in the robot's base coordinate system to enable grasping it later.

The input parameters Row, Column, and Angle are those of the matched model.

The input message HandEyeCalibData contains the camera parameters CamParam and ToolInCamPose. The input message Poses contains the PlaneInModelPose.

The input message RectificationData contains the RectifyImage which is the rectification option with the possible values 'no_rectification', 'only_rectify', and 'align_and_rectify' as explained in the procedure prepare_poses_and_rectification_data_moving_cam. Moreover, RectificationData contains MatchingPlaneRectifiedPartInCamPose. RectificationData also contains ScaleRectification if image rectification is set by the user. 

The output parameter ModelInBasePose is the pose of the matched model in the robot's base coordinate system.</abstract>
<chapters lang="de_DE">
<item>Transformationen</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Transformations</item>
<item>Misc</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>rectify_image_and_compute_matching_plane_moving_cam</item>
</predecessor>
<short lang="en_US">Obtain the pose of the matched model in the base coordinate system.</short>
<successor>
<item>calculate_tool_in_base_robot_path_poses</item>
</successor>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="en_US">Angle of the matched model.</description>
<multivalue>false</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<description lang="en_US">Column of the matched model.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain: CamParam and ToolInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelInBasePose">
<default_type>real</default_type>
<description lang="en_US">Pose of the model in the robot's base coordinate system.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[]</item>
</values>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain PlaneInModelPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain: RectifyImage, MatchingPlaneRectifiedPartInCamPose, and (if rectification is set) ScaleRectification.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row of the matched model.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<description lang="en_US">Current pose of the robot.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="obtain_3d_pose_of_match_stationary_cam">
<interface>
<ic>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ModelInBasePose" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure obtains the 3D pose from the model to the base of</c>
<c>* the robot.</c>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (HandEyeCalibData, 'BaseInCamPose', BaseInCamPose)</l>
<l>read_message_tuple (Poses, 'PlaneInModelPose', PlaneInModelPose)</l>
<l>read_message_tuple (Poses, 'MatchingPlaneInCamPose', MatchingPlaneInCamPose)</l>
<l>read_message_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage == 'true')</l>
<l>    read_message_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>endif</l>
<c>*</c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (PlaneInModelPose, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (MatchingPlaneInCamPose, 'Rp+T', 'gba', 'point', MatchingPlaneInCamPose)</l>
<l>convert_pose_type (PlaneInModelPose, 'Rp+T', 'gba', 'point', PlaneInModelPose)</l>
<l>if (|Row| = 1 and |Column| = 1 and |Angle| = 1)</l>
<l>    vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, HomMat2DObject)</l>
<c>    * col = x, row = y</c>
<l>    if (RectifyImage = 'false')</l>
<l>        affine_trans_pixel (HomMat2DObject, 0, 0, RowObject, ColObject)</l>
<l>        image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, RowObject, ColObject, 'm', PXM, PYM)</l>
<l>        HomMat3DObject := [HomMat2DObject[4], HomMat2DObject[3], 0, PXM, HomMat2DObject[1], HomMat2DObject[0], 0, PYM, 0, 0, 1, 0]</l>
<l>        hom_mat3d_to_pose (HomMat3DObject, ModelToMatchInPlanePose)</l>
<l>        pose_compose (ModelToMatchInPlanePose, PlaneInModelPose, ModelInPlanePose)</l>
<l>        pose_compose (MatchingPlaneInCamPose, ModelInPlanePose, ModelInCamPose)</l>
<l>    elseif (RectifyImage = 'true')</l>
<l>        HomMat3DObject := [HomMat2DObject[4], HomMat2DObject[3], 0, HomMat2DObject[5]*ScaleRectification, HomMat2DObject[1], HomMat2DObject[0], 0, HomMat2DObject[2]*ScaleRectification, 0, 0, 1, 0]</l>
<l>        hom_mat3d_to_pose (HomMat3DObject, ModelToMatchInPlanePartRectPose)</l>
<l>        pose_compose (ModelToMatchInPlanePartRectPose, PlaneInModelPose, ModelInPlanePartRectPose)</l>
<l>        pose_compose (MatchingPlaneInCamPose, ModelInPlanePartRectPose, ModelInCamPose)</l>
<l>    else</l>
<l>        throw ('Please set the parameter RectifyImage correctly')</l>
<l>    endif</l>
<l>    pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>    pose_compose (CamInBasePose, ModelInCamPose, ModelInBasePose)</l>
<c>    *</c>
<l>    convert_pose_type (ModelInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, ModelInBasePose)</l>
<l>else</l>
<l>    throw ('Exactly one match should be given as input')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="obtain_3d_pose_of_match_stationary_cam">
<abstract lang="en_US">This procedure obtains the pose of the matched model in the robot's base coordinate system to enable grasping it later, in a stationary camera setup.

The input parameters Row, Column, and Angle are those of the matched model.

The input message HandEyeCalibData must contain the camera parameters CamParam and the pose BaseInCamPose.

The input message Poses must contain the poses PlaneInModelPose and MatchingPlaneInCamPose.

The input message RectificationData must contain the parameter RectifyImage ('true', 'false'), and, if the image is to be rectified, the parameter ScaleRectification.

The output parameter ModelInBasePose is the pose of the matched model in the robot's base coordinate system.</abstract>
<alternatives>
<item>obtain_3d_pose_of_match_moving_cam</item>
</alternatives>
<chapters lang="de_DE">
<item>Transformationen</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Transformations</item>
<item>Misc</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>prepare_poses_and_rectification_data_stationary_cam</item>
</predecessor>
<short lang="en_US">Obtain the pose of the matched model in the base coordinate system in a stationary camera setup.</short>
<successor>
<item>calculate_tool_in_base_robot_path_poses</item>
</successor>
<parameters>
<parameter id="Angle">
<default_type>real</default_type>
<description lang="en_US">Rotation angle of the found match of the model.</description>
<multivalue>false</multivalue>
<sem_type>angle.rad</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Column">
<default_type>real</default_type>
<description lang="en_US">Column coordinate of the found match of the model.</description>
<multivalue>false</multivalue>
<sem_type>point.x</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain: CamParam and BaseInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ModelInBasePose">
<default_type>real</default_type>
<description lang="en_US">Pose of the matched model in the robot's base coordinate system.</description>
<multivalue>false</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
<values>
<item>[]</item>
</values>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain: PlaneInModelPose and MatchingPlaneInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain: RectifyImage and ScaleRectification.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Row">
<default_type>real</default_type>
<description lang="en_US">Row coordinate of the found match of the model.</description>
<multivalue>false</multivalue>
<sem_type>point.y</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="open_new_window" access="local">
<interface>
<oc>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandleGraphics" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>wait_seconds (0.1)</l>
<l>dev_get_window (WindowHandle)</l>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>dev_open_window_fit_size (0, Width+8, Width, Height, 600, -1, WindowHandleGraphics)</l>
<l>set_display_font (WindowHandleGraphics, 14, 'mono', 'true', 'false')</l>
<l>set_part_style (WindowHandleGraphics, 2)</l>
<l>return ()</l>
</body>
<docu id="open_new_window">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Fenster</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Window</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Open a new window next to an existing one.</short>
<parameters>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHandleGraphics">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="parse_filename">
<interface>
<ic>
<par name="FileName" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="BaseName" base_type="ctrl" dimension="0"/>
<par name="Extension" base_type="ctrl" dimension="0"/>
<par name="Directory" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure gets a filename (with full path) as input</c>
<c>* and returns the directory path, the base filename and the extension</c>
<c>* in three different strings.</c>
<c>* </c>
<c>* In the output path the path separators will be replaced</c>
<c>* by '/' in all cases.</c>
<c>* </c>
<c>* The procedure shows the possibilities of regular expressions in HALCON.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* FileName: The input filename</c>
<c>* </c>
<c>* Output parameters:</c>
<c>* BaseName: The filename without directory description and file extension</c>
<c>* Extension: The file extension</c>
<c>* Directory: The directory path</c>
<c>* </c>
<c>* Example:</c>
<c>* basename('C:/images/part_01.png',...) returns</c>
<c>* BaseName = 'part_01'</c>
<c>* Extension = 'png'</c>
<c>* Directory = 'C:\\images\\' (on Windows systems)</c>
<c>* </c>
<c>* Explanation of the regular expressions:</c>
<c>* </c>
<c>* '([^\\\\/]*?)(?:\\.[^.]*)?$':</c>
<c>* To start at the end, the '$' matches the end of the string,</c>
<c>* so it is best to read the expression from right to left.</c>
<c>* The part in brackets (?:\\.[^.}*) denotes a non-capturing group.</c>
<c>* That means, that this part is matched, but not captured</c>
<c>* in contrast to the first bracketed group ([^\\\\/], see below.)</c>
<c>* \\.[^.]* matches a dot '.' followed by as many non-dots as possible.</c>
<c>* So (?:\\.[^.]*)? matches the file extension, if any.</c>
<c>* The '?' at the end assures, that even if no extension exists,</c>
<c>* a correct match is returned.</c>
<c>* The first part in brackets ([^\\\\/]*?) is a capture group,</c>
<c>* which means, that if a match is found, only the part in</c>
<c>* brackets is returned as a result.</c>
<c>* Because both HDevelop strings and regular expressions need a '\\'</c>
<c>* to describe a backslash, inside regular expressions within HDevelop</c>
<c>* a backslash has to be written as '\\\\'.</c>
<c>* [^\\\\/] matches any character but a slash or backslash ('\\' in HDevelop)</c>
<c>* [^\\\\/]*? matches a string od 0..n characters (except '/' or '\\')</c>
<c>* where the '?' after the '*' switches the greediness off,</c>
<c>* that means, that the shortest possible match is returned.</c>
<c>* This option is necessary to cut off the extension</c>
<c>* but only if (?:\\.[^.]*)? is able to match one.</c>
<c>* To summarize, the regular expression matches that part of</c>
<c>* the input string, that follows after the last '/' or '\\' and</c>
<c>* cuts off the extension (if any) after the last '.'.</c>
<c>* </c>
<c>* '\\.([^.]*)$':</c>
<c>* This matches everything after the last '.' of the input string.</c>
<c>* Because ([^.]) is a capturing group,</c>
<c>* only the part after the dot is returned.</c>
<c>* </c>
<c>* '.*[\\\\/]':</c>
<c>* This matches the longest substring with a '/' or a '\\' at the end.</c>
<c>* </c>
<l>tuple_regexp_match (FileName, '.*[\\\\/]', DirectoryTmp)</l>
<l>tuple_substr (FileName, strlen(DirectoryTmp), strlen(FileName) - 1, Substring)</l>
<l>tuple_regexp_match (Substring, '([^\\\\/]*?)(?:\\.[^.]*)?$', BaseName)</l>
<l>tuple_regexp_match (Substring, '\\.([^.]*)$', Extension)</l>
<c>* </c>
<c>* </c>
<c>* Finally all found backslashes ('\\') are converted</c>
<c>* to a slash to get consistent paths</c>
<l>tuple_regexp_replace (DirectoryTmp, ['\\\\','replace_all'], '/', Directory)</l>
<l>return ()</l>
</body>
<docu id="parse_filename">
<abstract lang="en_US">This procedure gets a filename (with full path) as input and returns the directory path (Directory), the base filename (BaseName) and the extension (Extension) in three different strings.</abstract>
<alternatives>
<item>tuple_regexp_select</item>
<item>tuple_regexp_match</item>
<item>tuple_regexp_match</item>
</alternatives>
<attention lang="en_US">In case of hidden files of the form '.name' (e.g. '.profile' etc.), an empty BaseName and Extension=name are returned.</attention>
<chapters>
<item>File</item>
</chapters>
<chapters lang="de_DE">
<item>Datei</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>File</item>
<item>Misc</item>
</chapters>
<example lang="en_US">FullFileNames:=['C:/images/image_01.png','C:/images/image_02.png','C:/training_image.png']
parse_filename (FullFileName, BaseName, Extension, Directory)
tuple_regexp_select(BaseName,'training',TrainingImages)</example>
<keywords lang="de_DE">
<item>Dateiname parsen</item>
</keywords>
<keywords lang="en_US">
<item>parse file name</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>list_files</item>
<item>list_image_files</item>
</predecessor>
<short>This procedure gets a filename (with full path) as input and returns the directory path, the base filename and the extension in three different strings.</short>
<short lang="de_DE">Parse a filename into directory, base filename, and extension</short>
<short lang="en_US">Parse a filename into directory, base filename, and extension</short>
<successor>
<item>tuple_regexp_select</item>
</successor>
<parameters>
<parameter id="BaseName">
<default_type>string</default_type>
<description lang="en_US">The filename without directory description and file extension</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Directory">
<default_type>string</default_type>
<description lang="en_US">The directory path</description>
<mixed_type>false</mixed_type>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Extension">
<default_type>string</default_type>
<description lang="en_US">The file extension</description>
<mixed_type>false</mixed_type>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="FileName">
<default_type>string</default_type>
<description lang="en_US">The input filename</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="plot_dl_classifier_training_progress">
<interface>
<ic>
<par name="TrainingErrors" base_type="ctrl" dimension="0"/>
<par name="ValidationErrors" base_type="ctrl" dimension="0"/>
<par name="LearningRates" base_type="ctrl" dimension="0"/>
<par name="Iterations" base_type="ctrl" dimension="0"/>
<par name="MaxIteration" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure plots the tuples training error and </c>
<c>* validation error with the y-axis on the left side, </c>
<c>* and the learning rate with the y-axis on the right side, </c>
<c>* versus the iterations over batches on the x-axis. </c>
<c>* The maximum number of iterations should be give by MaxIteration, </c>
<c>* to scale the x-axis appropriately. </c>
<c>* The plot is displayed in the graphics window given by WindowHandle.</c>
<c>*</c>
<c>* The procedure expects the input tuples TrainingError, ValidationError, </c>
<c>* LearningRate, and Iteration with their values sorted in chronological order,</c>
<c>* the current value in each case as last element.</c>
<c>*</c>
<c>* Check input parameters.</c>
<l>if (MaxIteration == [])</l>
<l>    MaxIteration := max(Iterations)</l>
<l>elseif (is_number(MaxIteration) != 1)</l>
<l>    throw ('MaxIteration must be a number or an empty tuple.')</l>
<l>endif</l>
<l>TrainingErrorPercent := TrainingErrors * 100</l>
<l>ValidationErrorPercent := ValidationErrors * 100</l>
<c>*</c>
<c>* Set the colors of the axes, plots and texts. </c>
<l>AxesColor := 'white'</l>
<l>TrainingErrorColor := 'magenta'</l>
<l>ValidationErrorColor := 'gold'</l>
<l>LearningRateColor := 'dark turquoise'</l>
<c>*</c>
<c>* Create functions from the input tuples.</c>
<l>create_funct_1d_pairs (Iterations, TrainingErrorPercent, TrainingErrorFunction)</l>
<l>create_funct_1d_pairs (Iterations, ValidationErrorPercent, ValidationErrorFunction)</l>
<l>create_funct_1d_pairs (Iterations, LearningRates, LearningRateFunction)</l>
<c>*</c>
<c>* Assemble generic parameters for the plots.</c>
<l>GenParamName := ['axis_location_x', 'end_x', 'ticks_x', 'start_y', 'margin_top', 'margin_right']</l>
<l>GenParamValue := ['origin', MaxIteration, MaxIteration/5, 0, 70, 100]</l>
<l>EndYError := max([TrainingErrorPercent, ValidationErrorPercent, 0.1])</l>
<c>* Round the maximum value of the left Y-axis </c>
<c>* to an integer or a real value with one decimal.</c>
<l>if (EndYError &gt;= 1.0)</l>
<l>    EndYError := int(ceil(EndYError))</l>
<l>else</l>
<l>    EndYError := ceil(EndYError*10.0) / 10.0</l>
<l>endif</l>
<l>EndYLearningRate := max(LearningRates)</l>
<c>*</c>
<c>* Disable flushing the graphics window temporarily</c>
<c>* to avoid flickering.</c>
<l>get_window_param (WindowHandle, 'flush', Flush)</l>
<l>set_window_param (WindowHandle, 'flush', 'false')</l>
<l>dev_clear_window ()</l>
<c>*</c>
<c>* Display plots.</c>
<l>plot_funct_1d (WindowHandle, TrainingErrorFunction, [], 'Error [%]', TrainingErrorColor, [GenParamName, 'axes_color', 'end_y', 'ticks_y'], [GenParamValue, AxesColor, EndYError, EndYError/5])</l>
<l>plot_funct_1d (WindowHandle, ValidationErrorFunction, [], [], ValidationErrorColor, [GenParamName, 'axes_color', 'end_y'], [GenParamValue, 'none', EndYError])</l>
<l>plot_funct_1d (WindowHandle, LearningRateFunction, [], 'Learning rate', LearningRateColor, [GenParamName, 'axes_color', 'axis_location_y', 'end_y', 'ticks_y', 'format_y', 'style'], [GenParamValue, AxesColor, 'right', EndYLearningRate, EndYLearningRate/5, '.1e', 'step'])</l>
<c>*</c>
<c>* Display current values in appropriate colors.</c>
<l>Text := 'Training error: ' + TrainingErrorPercent[|TrainingErrorPercent|-1] $ '.1f'</l>
<l>Text[1] := 'Validation error: ' + ValidationErrorPercent[|ValidationErrorPercent|-1] $ '.1f'</l>
<l>dev_disp_text (Text + ' %', 'window', 'top', 'left', [TrainingErrorColor, ValidationErrorColor], 'box', 'false')</l>
<l>Text := 'Learning rate: ' + LearningRates[|LearningRates|-1] $ '.1e'</l>
<l>dev_disp_text (Text, 'window', 'top', 'right', LearningRateColor, 'box', 'false')</l>
<l>Text := 'Iteration: ' + Iterations[|Iterations|-1]</l>
<l>dev_disp_text (Text, 'window', 'bottom', 'center', 'white', 'box', 'false')</l>
<c>*</c>
<c>* Flush the buffer and re-enable flushing.</c>
<l>flush_buffer (WindowHandle)</l>
<l>set_window_param (WindowHandle, 'flush', Flush)</l>
<l>return ()</l>
</body>
<docu id="plot_dl_classifier_training_progress">
<abstract lang="de_DE">plot_dl_classifier_training_progress plottet die Trainingsfehler TrainingErrors und die Validierungsfehler ValidationErrors mit der Y-Achse auf der linken Seite, die Lernraten LearningRates mit der Y-Achse auf der rechten Seite, gegen die Iterationen Iterations auf der x-Achse. Die maximale Anzahl an Iterationen über Batches sollte mit MaxIteration spezifiziert werden, damit die X-Achse richtig skaliert wird. Wenn in MaxIteration ein leeres Tupel übergeben wird, wird das Maximum von Iterations als maximaler X-Wert genutzt. Error steht typischweise für den Top-1 Fehler. Der Plot wird in dem Grafikfenster dargestellt, das mit WindowHandle spezifiziert wird.

Die Werte der Eingabetupel TrainingErrors, ValidationErrors, LearningRates und Iterations sollten chronologisch sortiert sein, mit dem aktuellen Wert jeweils am Endes des Tupels. Um alle Werte des Trainings zu plotten, und nicht nur die aktuellen, ist es nötig, die Werte nach und nach zu akkumulieren, z.B. über Konkatenation.

Für weitere Informationen, wie diese Graphen zu interpretieren sind, verweisen wir auf die Operator-Referenz zum Kapitel 'Deep Learning'.

</abstract>
<abstract lang="en_US">plot_dl_classifier_training_progress plots the training errors and validation errors with the y-axis on the left side, and the learning rates with the y-axis on the right side, versus the iterations on the x-axis. The maximum number of iterations over batches should be give by MaxIteration, to scale the x-axis appropriately. If MaxIteration is an empty tuple, the maximum of Iterations is used as maximum x-value instead. Error typically stands for the top-1 error. The plot is displayed in the graphics window given by WindowHandle.

The procedure expects the input tuples TrainingErrors, ValidationErrors, LearningRates, and Iterations with their values sorted in chronological order, the current value in each case as last element. To plot the all the values of the actual classifier training and not only the current ones, you will have to accumulate them, e.g., by concatenation. 

To interpret these plots, please have a look at the operator reference, chapter 'Deep Learning'.


</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Klassifikation</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<example lang="de_DE">for Epoche := 0 to AnzahlEpochen-1 by 1
    for I := 0 to |TrainingBilder|-1 by BatchGroesse
        AktuelleIteration := int(Epoche * ceil(|TrainingBilder|/BatchGroesse) + I / BatchGroesse + 1)
        if (Iteration % 20 == 0)
            * Ausgabe von evaluate_dl_classifier_traing_progress:
            TrainingsFehler := [TrainingsFehler, AktuellerTrainingsFehler]
            ValidierungsFehler := [ValidierungsFehler, AktuellerValidierungsFehler]
            get_dl_classifier_param(DLClassifierHandle, 'learning_rate', AktuelleLernrate)
            Lernrate := [Lernrate, AktuelleLernrate]
            Iteration := [Iteration, AktuelleIteration]
            *
            plot_dl_classifier_training_progress (TrainingsFehler, ValidierungsFehler, Lernrate, \
                                                  Iteration, ceil(|TrainingBilder|/BatchGroesse) * AnzahlEpochen), \
                                                  WindowHandle)
        endif
    endfor
endfor</example>
<example lang="en_US">for Epoch := 0 to NumEpochs-1 by 1
    for I := 0 to |TrainingImages|-1 by BatchSize
        CurrentIteration := int(Epoch * ceil(|TrainingImages|/BatchSize) + I / BatchSize + 1)
        if (Iteration % 20 == 0)
            * Output from evaluate_dl_classifier_traing_progress:
            TrainingError := [TrainingError, CurrentTrainingError]
            ValidationError := [ValidationError, CurrentValidationError]
            get_dl_classifier_param(DLClassifierHandle, 'learning_rate', CurrentLearningRate)
            LearningRate := [LearningRate,CurrentLearningRate]
            Iteration := [Iteration, CurrentIteration]
            *
            plot_dl_classifier_training_progress (TrainingError, ValidationError, LearningRate, \
                                                  Iterations, int(ceil(NumTrainingImages/BatchSize) * NumEpochs), \
                                                  WindowHandle)
        endif
    endfor
endfor</example>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>evaluate_dl_classifier</item>
</predecessor>
<short lang="de_DE">Plotten des Trainingsfehlers, Validierungsfehlers und der Lernrate während des Trainings des Deep Learning Klassifikators.</short>
<short lang="en_US">Plot the training error, validation error and learning rate during deep learning classifier training.</short>
<parameters>
<parameter id="Iterations">
<default_type>integer</default_type>
<description lang="de_DE">Tupel, das die gesammelten Iterationen enthält.</description>
<description lang="en_US">Tuple containing the concatenated iterations.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="LearningRates">
<default_type>real</default_type>
<description lang="de_DE">Tupel, das die gesammelten Lernraten enthält.</description>
<description lang="en_US">Tuple containing the concatenated learning rates.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="MaxIteration">
<default_type>integer</default_type>
<default_value>[]</default_value>
<description lang="de_DE">Maximale Anzahl an Iterationen.</description>
<description lang="en_US">Maximum number of iterations.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TrainingErrors">
<default_type>real</default_type>
<description lang="de_DE">Tupel, das die gesammelten Trainingsfehler enthält.</description>
<description lang="en_US">Tuple containing the concatenated training errors.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="ValidationErrors">
<default_type>real</default_type>
<description lang="de_DE">Tupel, das die gesammelten Validierungsfehler enthält.</description>
<description lang="en_US">Tuple containing the concatenated validation errors.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="de_DE">Handle des Grafikfensters.</description>
<description lang="en_US">Handle of the graphics window.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="plot_funct_1d">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Function" base_type="ctrl" dimension="0"/>
<par name="XLabel" base_type="ctrl" dimension="0"/>
<par name="YLabel" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure plots a function in a coordinate system.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* </c>
<c>* Function: 1D function</c>
<c>* </c>
<c>* XLabel: X-axis label</c>
<c>* </c>
<c>* XLabel: Y-axis label</c>
<c>* </c>
<c>* Color: Color of the plotted function</c>
<c>*        If [] is given, the currently set display color is used.</c>
<c>*        If 'none is given, the function is not plotted, but only</c>
<c>*        the coordinate axes as specified.</c>
<c>* </c>
<c>* GenParamName:  Generic parameters to control the presentation</c>
<c>*                The parameters are evaluated from left to right.</c>
<c>* </c>
<c>*                Possible Values:</c>
<c>*    'axes_color': coordinate system color</c>
<c>*                  Default: 'white'</c>
<c>*                  If 'none' is given, no coordinate system is shown.</c>
<c>*    'style': Graph style</c>
<c>*             Possible values: 'line' (default), 'cross', 'step', 'filled'</c>
<c>*    'clip': Clip graph to coordinate system area</c>
<c>*            Possible values: 'yes' (default), 'no'</c>
<c>*    'ticks': Control display of ticks on the axes</c>
<c>*             If 'min_max_origin' is given (default), ticks are shown</c>
<c>*             at the minimum and maximum values of the axes and at the</c>
<c>*             intercept point of x- and y-axis.</c>
<c>*             If 'none' is given, no ticks are shown.</c>
<c>*             If any number != 0 is given, it is interpreted as distance</c>
<c>*             between the ticks.</c>
<c>*    'ticks_x': Control display of ticks on x-axis only</c>
<c>*    'ticks_y': Control display of ticks on y-axis only</c>
<c>*    'format_x': Format of the values next to the ticks of the x-axis </c>
<c>*                (see tuple_string for more details).</c>
<c>*    'format_y': Format of the values next to the ticks of the y-axis</c>
<c>*                (see tuple_string for more details).</c>
<c>*    'grid': Control display of grid lines within the coordinate system</c>
<c>*            If 'min_max_origin' is given (default), grid lines are shown</c>
<c>*            at the minimum and maximum values of the axes.</c>
<c>*            If 'none' is given, no grid lines are shown.</c>
<c>*            If any number != 0 is given, it is interpreted as distance</c>
<c>*            between the grid lines.</c>
<c>*    'grid_x': Control display of grid lines for the x-axis only</c>
<c>*    'grid_y': Control display of grid lines for the y-axis only</c>
<c>*    'grid_color': Color of the grid (default: 'dim gray')</c>
<c>*    'margin': The distance in pixels of the coordinate system area</c>
<c>*              to all four window borders.</c>
<c>*    'margin_left': The distance in pixels of the coordinate system area</c>
<c>*                   to the left window border.</c>
<c>*    'margin_right': The distance in pixels of the coordinate system area</c>
<c>*                    to the right window border.</c>
<c>*    'margin_top': The distance in pixels of the coordinate system area</c>
<c>*                  to the upper window border.</c>
<c>*    'margin_bottom': The distance in pixels of the coordinate system area</c>
<c>*                     to the lower window border.</c>
<c>*    'start_x': Lowest x value of the x-axis</c>
<c>*               Default: min(XValues)</c>
<c>*    'end_x': Highest x value of the x-axis</c>
<c>*             Default: max(XValues)</c>
<c>*    'start_y': Lowest y value of the y-axis</c>
<c>*               Default: min(YValues)</c>
<c>*    'end_y': Highest y value of the y-axis</c>
<c>*             Default: max(YValues)</c>
<c>*    'axis_location_x': Either 'bottom', 'origin', or 'top' </c>
<c>*                to position the x-axis conveniently, </c>
<c>*                or the Y coordinate of the intercept point of x- and y-axis.</c>
<c>*                Default: 'bottom'</c>
<c>*                (Used to be called 'origin_y')</c>
<c>*    'axis_location_y': Either 'left', 'origin', or 'right' </c>
<c>*                to position the y-axis conveniently, </c>
<c>*                or the X coordinate of the intercept point of x- and y-axis.</c>
<c>*                Default: 'left'</c>
<c>*                (Used to be called 'origin_x')</c>
<c>* </c>
<c>* GenParamValue: Values of the generic parameters of GenericParamName</c>
<c>* </c>
<c>* </c>
<l>funct_1d_to_pairs (Function, XValues, YValues)</l>
<l>plot_tuple (WindowHandle, XValues, YValues, XLabel, YLabel, Color, GenParamName, GenParamValue)</l>
<l>return ()</l>
</body>
<docu id="plot_funct_1d">
<abstract lang="en_US">This procedure plots the function Function into the graphic window given in WindowHandle.
The axes of the coordinate system are labeled with XLabel and YLabel.
The appearance of the output can further be adapted using generic parameters given in GenericParamName and GenericParamValue.

In particular, following parameters can be set:

Function: A 1D function.

 XLabel: X-axis label.

 XLabel: Y-axis label.

 Color: Color of the plotted function.

        If [] is given, the currently set display color is used.
        If 'none' is given, the function is not plotted, but only
        the coordinate axes as specified.

 GenParamName: Generic parameters to control the presentation.

                Possible Values:

    'axes_color': coordinate system color.
                  Default: 'white'
                  If 'none' is given, no coordinate system is shown. 

    'style': Graph style.
             Possible values: 'line' (default), 'cross', 'step', 'filled'

    'clip': Clip graph to coordinate system area.
            Possible values: 'no' (default), 'yes''

    'ticks': Control display of ticks on the axes.
             If 'min_max_origin' is given (default), ticks are shown 
             at the minimum and maximum values of the axes and at the
             intercept point of x- and y-axis.
             If 'none' is given, no ticks are shown.
             If any number != 0 is given, it is interpreted as distance
             between the ticks.

    'ticks_x': Control display of ticks on x-axis only.

    'ticks_y': Control display of ticks on x-axis only.

    'format_x': Format of the values next to the ticks of the x-axis 
                (see tuple_string for more details).

    'format_y': Format of the values next to the ticks of the y-axis
                (see tuple_string for more details).

    'grid': Control display of grid lines within the coordinate system.
            If 'min_max_origin' is given (default), grid lines are shown 
            at the minimum and maximum values of the axes.
            If 'none' is given, no grid lines are shown.
            If any number != 0 is given, it is interpreted as distance
            between the grid lines.

    'grid_x': Control display of grid lines for the x-axis only.

    'grid_y': Control display of grid lines for the y-axis only.

    'grid_color': Color of the grid (default: 'dim gray').

    'margin': The distance in pixels of the coordinate system area
              to all four window borders.

    'margin_left': The distance in pixels of the coordinate system area
                   to the left window border.

    'margin_right': The distance in pixels of the coordinate system area
                    to the right window border.

    'margin_top': The distance in pixels of the coordinate system area
                    to the upper window border.

    'margin_bottom'': The distance in pixels of the coordinate system area
                    to the lower window border.

    'start_x': Lowest x value of the x-axis.
               Default: min(XValues)

    'end_x': Highest x value of the x-axis.
             Default: max(XValues)

    'start_y': Lowest y value of the y-axis.
               Default: min(YValues)

    'end_y': Highest y value of the y-axis.
             Default: max(YValues)

    'axis_location_x': Either 'bottom', 'origin', or 'top' to position the x-axis conveniently, or the Y coordinate of the intercept point of x- and y-axis.
                Default: 'bottom'
                (Used to be called 'origin_y')

    'axis_location_y': Either 'left', 'origin', or 'right' to position the y-axis conveniently, or the X coordinate of the intercept point of x- and y-axis.
                Default: 'left'
                (Used to be called 'origin_x')

 GenParamValue: Values of the generic parameters of GenericParamNames.</abstract>
<alternatives>
<item>plot_tuple</item>
</alternatives>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
X := [-rad(180): 0.01: rad(180)]
Y := sin(X)
create_funct_1d_pairs (X, Y, Function)
invert_funct_1d (Function, InverseFunction)
GenParamName := []
GenParamValue := []
plot_funct_1d (WindowHandle, InverseFunction, 'x', 'sin^-1(x)', 'red', GenParamName, GenParamValue)
</example>
<keywords lang="en_US">
<item>plot</item>
<item>function</item>
<item>display</item>
<item>graph</item>
<item>curve</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>create_funct_1d_pairs</item>
<item>create_funct_1d_array</item>
<item>compose_funct_1d</item>
</predecessor>
<short lang="en_US"> This procedure plots tuples representing functions or curves in a coordinate system.</short>
<parameters>
<parameter id="Color">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Color of the function plot.</description>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'yellow'</item>
<item>'white'</item>
<item>'black'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'blue'</item>
<item>'orange'</item>
</values>
</parameter>
<parameter id="Function">
<description lang="en_US">Function to be plotted</description>
<mixed_type>false</mixed_type>
<sem_type>function_1d</sem_type>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of generic parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'axes_color'</item>
<item>'style'</item>
<item>'clip'</item>
<item>'ticks'</item>
<item>'ticks_x'</item>
<item>'ticks_y'</item>
<item>'grid'</item>
<item>'grid_x'</item>
<item>'grid_y'</item>
<item>'grid_color'</item>
<item>'margin'</item>
<item>'margin_left'</item>
<item>'margin_right'</item>
<item>'margin_top'</item>
<item>'margin_bottom'</item>
<item>'start_x'</item>
<item>'end_x'</item>
<item>'start_y'</item>
<item>'end_y'</item>
<item>'origin_y'</item>
<item>'origin_x'</item>
<item>'position_y'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Generic parameter values.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window handle in which the plot should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="XLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the x-axis.</description>
</parameter>
<parameter id="YLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the y-axis.</description>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="plot_tuple">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="XValues" base_type="ctrl" dimension="0"/>
<par name="YValues" base_type="ctrl" dimension="0"/>
<par name="XLabel" base_type="ctrl" dimension="0"/>
<par name="YLabel" base_type="ctrl" dimension="0"/>
<par name="Color" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure plots tuples representing functions</c>
<c>* or curves in a coordinate system.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* </c>
<c>* XValues: X values of the function to be plotted</c>
<c>*          If XValues is set to [], it is internally set to 0,1,2,...,|YValues|-1.</c>
<c>*          If XValues is a tuple of strings, the values are taken as categories.</c>
<c>* </c>
<c>* YValues: Y values of the function(s) to be plotted</c>
<c>*          If YValues is set to [], it is internally set to 0,1,2,...,|XValues|-1.</c>
<c>*          The number of y values must be equal to the number of x values</c>
<c>*          or an integral multiple. In the latter case,</c>
<c>*          multiple functions are plotted, that share the same x values.</c>
<c>* </c>
<c>* XLabel: X-axis label</c>
<c>* </c>
<c>* XLabel: Y-axis label</c>
<c>* </c>
<c>* Color: Color of the plotted function</c>
<c>*        If [] is given, the currently set display color is used.</c>
<c>*        If 'none is given, the function is not plotted, but only</c>
<c>*        the coordinate axes as specified.</c>
<c>*        If more than one color is given, multiple functions</c>
<c>*        can be displayed in different colors.</c>
<c>* </c>
<c>* GenParamName:  Generic parameters to control the presentation</c>
<c>*                Possible Values:</c>
<c>*    'axes_color': coordinate system color</c>
<c>*                  Default: 'white'</c>
<c>*                  If 'none' is given, no coordinate system is shown.</c>
<c>*    'style': Graph style</c>
<c>*             Possible values: 'line' (default), 'cross', 'stair', 'filled'</c>
<c>*    'clip': Clip graph to coordinate system area</c>
<c>*            Possible values: 'yes', 'no' (default)</c>
<c>*    'ticks': Control display of ticks on the axes</c>
<c>*             If 'min_max_origin' is given (default), ticks are shown</c>
<c>*             at the minimum and maximum values of the axes and at the</c>
<c>*             intercept point of x- and y-axis.</c>
<c>*             If 'none' is given, no ticks are shown.</c>
<c>*             If any number != 0 is given, it is interpreted as distance</c>
<c>*             between the ticks.</c>
<c>*    'ticks_x': Control display of ticks on x-axis only</c>
<c>*    'ticks_y': Control display of ticks on y-axis only</c>
<c>*    'format_x': Format of the values next to the ticks of the x-axis </c>
<c>*                (see tuple_string for more details).</c>
<c>*    'format_y': Format of the values next to the ticks of the y-axis</c>
<c>*                (see tuple_string for more details).</c>
<c>*    'grid': Control display of grid lines within the coordinate system</c>
<c>*            If 'min_max_origin' is given (default), grid lines are shown</c>
<c>*            at the minimum and maximum values of the axes.</c>
<c>*            If 'none' is given, no grid lines are shown.</c>
<c>*            If any number != 0 is given, it is interpreted as distance</c>
<c>*            between the grid lines.</c>
<c>*    'grid_x': Control display of grid lines for the x-axis only</c>
<c>*    'grid_y': Control display of grid lines for the y-axis only</c>
<c>*    'grid_color': Color of the grid (default: 'dim gray')</c>
<c>*    'margin': The distance in pixels of the coordinate system area</c>
<c>*              to all four window borders.</c>
<c>*    'margin_left': The distance in pixels of the coordinate system area</c>
<c>*                   to the left window border.</c>
<c>*    'margin_right': The distance in pixels of the coordinate system area</c>
<c>*                    to the right window border.</c>
<c>*    'margin_top': The distance in pixels of the coordinate system area</c>
<c>*                  to the upper window border.</c>
<c>*    'margin_bottom': The distance in pixels of the coordinate system area</c>
<c>*                     to the lower window border.</c>
<c>*    'start_x': Lowest x value of the x-axis</c>
<c>*               Default: min(XValues)</c>
<c>*    'end_x': Highest x value of the x-axis</c>
<c>*             Default: max(XValues)</c>
<c>*    'start_y': Lowest y value of the y-axis</c>
<c>*               Default: min(YValues)</c>
<c>*    'end_y': Highest y value of the y-axis</c>
<c>*             Default: max(YValues)</c>
<c>*    'axis_location_x': Either 'bottom', 'origin', or 'top' </c>
<c>*                to position the x-axis conveniently, </c>
<c>*                or the Y coordinate of the intercept point of x- and y-axis.</c>
<c>*                Default: 'bottom'</c>
<c>*                (Used to be called 'origin_y')</c>
<c>*    'axis_location_y': Either 'left', 'origin', or 'right' </c>
<c>*                to position the y-axis conveniently, </c>
<c>*                or the X coordinate of the intercept point of x- and y-axis.</c>
<c>*                Default: 'left'</c>
<c>*                (Used to be called 'origin_x')</c>
<c>* </c>
<c>* GenParamValue: Values of the generic parameters of GenericParamName</c>
<c>* </c>
<c>* </c>
<c>* Store current display settings</c>
<l>dev_get_window (PreviousWindowHandle)</l>
<l>dev_set_window (WindowHandle)</l>
<l>get_system ('clip_region', ClipRegion)</l>
<l>get_window_extents (WindowHandle, Row, Column, Width, Height)</l>
<l>get_part (WindowHandle, PartRow1, PartColumn1, PartRow2, PartColumn2)</l>
<l>get_rgb (WindowHandle, Red, Green, Blue)</l>
<l>get_draw (WindowHandle, DrawMode)</l>
<l>get_line_style (WindowHandle, OriginStyle)</l>
<c>* </c>
<c>* Set display parameters</c>
<l>set_line_style (WindowHandle, [])</l>
<l>set_system ('clip_region', 'false')</l>
<l>dev_set_part (0, 0, Height - 1, Width - 1)</l>
<c>* </c>
<c>* Check input coordinates</c>
<c>* </c>
<l>if (XValues == [] and YValues == [])</l>
<c>    * Neither XValues nor YValues are given:</c>
<c>    * Set axes to interval [0,1]</c>
<l>    XAxisEndValue := 1</l>
<l>    YAxisEndValue := 1</l>
<l>    XAxisStartValue := 0</l>
<l>    YAxisStartValue := 0</l>
<l>    XValuesAreStrings := false</l>
<l>else</l>
<l>    if (XValues == [])</l>
<c>        * XValues are omitted:</c>
<c>        * Set equidistant XValues</c>
<l>        XValues := [0:|YValues| - 1]</l>
<l>        XValuesAreStrings := false</l>
<l>    elseif (YValues == [])</l>
<c>        * YValues are omitted:</c>
<c>        * Set equidistant YValues</c>
<l>        YValues := [0:|XValues| - 1]</l>
<l>    endif</l>
<l>    if (|YValues| % |XValues| != 0)</l>
<c>        * Number of YValues does not match number of XValues</c>
<l>        throw ('Number of YValues is no multiple of the number of XValues!')</l>
<l>        return ()</l>
<l>    endif</l>
<l>    XValuesAreStrings := is_string_elem(XValues)</l>
<l>    XValuesAreStrings := sum(XValuesAreStrings) == |XValuesAreStrings|</l>
<l>    if (XValuesAreStrings)</l>
<c>        * XValues are given as strings:</c>
<c>        * Show XValues as ticks</c>
<l>        XTickValues := XValues</l>
<l>        XTicks := 1</l>
<c>        * Set x-axis dimensions</c>
<l>        XValues := [1:|XValues|]</l>
<l>    endif</l>
<c>    * Set default x-axis dimensions</c>
<l>    if (|XValues| &gt; 1)</l>
<l>        XAxisStartValue := min(XValues)</l>
<l>        XAxisEndValue := max(XValues)</l>
<l>    else</l>
<l>        XAxisEndValue := XValues[0] + 0.5</l>
<l>        XAxisStartValue := XValues[0] - 0.5</l>
<l>    endif</l>
<l>endif</l>
<c>* Set default y-axis dimensions</c>
<l>if (|YValues| &gt; 1)</l>
<l>    YAxisStartValue := min(YValues)</l>
<l>    YAxisEndValue := max(YValues)</l>
<l>elseif (|YValues| == 1)</l>
<l>    YAxisStartValue := YValues[0] - 0.5</l>
<l>    YAxisEndValue := YValues[0] + 0.5</l>
<l>else</l>
<l>    YAxisStartValue := 0</l>
<l>    YAxisEndValue := 1</l>
<l>endif</l>
<c>* Set default interception point of x- and y- axis</c>
<l>YAxisPosition := XAxisStartValue</l>
<l>XAxisPosition := YAxisStartValue</l>
<c>* </c>
<c>* Set more defaults</c>
<l>LeftBorder := Width * 0.1</l>
<l>RightBorder := Width * 0.1</l>
<l>UpperBorder := Height * 0.1</l>
<l>LowerBorder := Height * 0.1</l>
<l>AxesColor := 'white'</l>
<l>Style := 'line'</l>
<l>Clip := 'no'</l>
<l>XTicks := 'min_max_origin'</l>
<l>YTicks := 'min_max_origin'</l>
<l>XGrid := 'none'</l>
<l>YGrid := 'none'</l>
<l>GridColor := 'dim gray'</l>
<l>YPosition := 'left'</l>
<l>FormatX := 'default'</l>
<l>FormatY := 'default'</l>
<c>* </c>
<c>* Parse generic parameters</c>
<c>* </c>
<l>NumGenParamNames := |GenParamName|</l>
<l>NumGenParamValues := |GenParamValue|</l>
<l>if (NumGenParamNames != NumGenParamValues)</l>
<l>    throw ('Number of generic parameter names does not match generic parameter values!')</l>
<l>    return ()</l>
<l>endif</l>
<c>* </c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<c>    * </c>
<c>    * Set 'axes_color'</c>
<l>    if (GenParamName[GenParamIndex] == 'axes_color')</l>
<l>        AxesColor := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'style'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'style')</l>
<l>        Style := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'clip'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'clip')</l>
<l>        Clip := GenParamValue[GenParamIndex]</l>
<l>        if (Clip != 'yes' and Clip != 'no')</l>
<l>            throw ('Unsupported clipping option: \'' + Clip + '\'')</l>
<l>        endif</l>
<c>        * </c>
<c>        * Set 'ticks'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'ticks')</l>
<l>        XTicks := GenParamValue[GenParamIndex]</l>
<l>        YTicks := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'ticks_x'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'ticks_x')</l>
<l>        XTicks := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'ticks_y'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'ticks_y')</l>
<l>        YTicks := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'grid'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'grid')</l>
<l>        XGrid := GenParamValue[GenParamIndex]</l>
<l>        YGrid := GenParamValue[GenParamIndex]</l>
<l>        XGridTicks := XTicks</l>
<c>        * </c>
<c>        * Set 'grid_x'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'grid_x')</l>
<l>        XGrid := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'grid_y'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'grid_y')</l>
<l>        YGrid := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'grid_color'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'grid_color')</l>
<l>        GridColor := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'start_x'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'start_x')</l>
<l>        XAxisStartValue := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'end_x'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'end_x')</l>
<l>        XAxisEndValue := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'start_y'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'start_y')</l>
<l>        YAxisStartValue := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'end_y'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'end_y')</l>
<l>        YAxisEndValue := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'axis_location_y' (old name 'origin_x')</c>
<l>    elseif (GenParamName[GenParamIndex] == 'axis_location_y' or GenParamName[GenParamIndex] == 'origin_x')</l>
<l>        YAxisPosition := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'axis_location_x' (old name: 'origin_y')</c>
<l>    elseif (GenParamName[GenParamIndex] == 'axis_location_x' or GenParamName[GenParamIndex] == 'origin_y')</l>
<l>        XAxisPosition := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin')</l>
<l>        LeftBorder := GenParamValue[GenParamIndex]</l>
<l>        RightBorder := GenParamValue[GenParamIndex]</l>
<l>        UpperBorder := GenParamValue[GenParamIndex]</l>
<l>        LowerBorder := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_left'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin_left')</l>
<l>        LeftBorder := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_right'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin_right')</l>
<l>        RightBorder := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_top'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin_top')</l>
<l>        UpperBorder := GenParamValue[GenParamIndex]</l>
<c>        * </c>
<c>        * Set 'margin_bottom'</c>
<l>    elseif (GenParamName[GenParamIndex] == 'margin_bottom')</l>
<l>        LowerBorder := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'format_x')</l>
<l>        FormatX := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'format_y')</l>
<l>        FormatY := GenParamValue[GenParamIndex] </l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* </c>
<c>* Check consistency of start and end values</c>
<c>* of the axes.</c>
<l>if (XAxisStartValue &gt; XAxisEndValue)</l>
<l>    throw ('Value for \'start_x\' is greater than value for \'end_x\'')</l>
<l>endif</l>
<l>if (YAxisStartValue &gt; YAxisEndValue)</l>
<l>    throw ('Value for \'start_y\' is greater than value for \'end_y\'')</l>
<l>endif</l>
<c>* </c>
<c>* Set the position of the y-axis.</c>
<l>if (is_string(YAxisPosition) == 1)</l>
<l>    if (YAxisPosition == 'left')</l>
<l>        YAxisPosition := XAxisStartValue</l>
<l>    elseif (YAxisPosition == 'right')</l>
<l>        YAxisPosition := XAxisEndValue</l>
<l>    elseif (YAxisPosition == 'origin')</l>
<l>        YAxisPosition := 0</l>
<l>    else</l>
<l>        throw ('Unsupported axis_location_y: \'' + YAxisPosition + '\'')</l>
<l>    endif</l>
<l>endif</l>
<c>* Set the position of the ticks on the y-axis</c>
<c>* depending of the location of the y-axis.</c>
<l>if (mean([XAxisStartValue, XAxisEndValue]) &gt; YAxisPosition)</l>
<l>    YTickDirection := 'right'</l>
<l>else</l>
<l>    YTickDirection := 'left'</l>
<l>endif</l>
<c>* </c>
<c>* Set the position of the x-axis.</c>
<l>if (is_string(XAxisPosition) == 1)</l>
<l>    if (XAxisPosition == 'bottom')</l>
<l>        XAxisPosition := YAxisStartValue</l>
<l>    elseif (XAxisPosition == 'top')</l>
<l>        XAxisPosition := YAxisEndValue</l>
<l>    elseif (XAxisPosition == 'origin')</l>
<l>        XAxisPosition := 0</l>
<l>    else</l>
<l>        throw ('Unsupported axis_location_x: \'' + XAxisPosition + '\'')</l>
<l>    endif</l>
<l>endif</l>
<c>* Set the position of the ticks on the y-axis</c>
<c>* depending of the location of the y-axis.</c>
<l>if (mean([YAxisStartValue, YAxisEndValue]) &gt; XAxisPosition)</l>
<l>    XTickDirection := 'up'</l>
<l>else</l>
<l>    XTickDirection := 'down'</l>
<l>endif</l>
<c>* </c>
<c>* Calculate basic pixel coordinates and scale factors</c>
<c>* </c>
<l>XAxisWidthPx := Width - LeftBorder - RightBorder</l>
<l>XAxisWidth := XAxisEndValue - XAxisStartValue</l>
<l>if (XAxisWidth == 0)</l>
<l>    XAxisStartValue := XAxisStartValue - 0.5</l>
<l>    XAxisEndValue := XAxisEndValue + 0.5</l>
<l>    XAxisWidth := 1</l>
<l>endif</l>
<l>XScaleFactor := XAxisWidthPx / real(XAxisWidth)</l>
<l>YAxisHeightPx := Height - LowerBorder - UpperBorder</l>
<l>YAxisHeight := YAxisEndValue - YAxisStartValue</l>
<l>if (YAxisHeight == 0)</l>
<l>    YAxisStartValue := YAxisStartValue - 0.5</l>
<l>    YAxisEndValue := YAxisEndValue + 0.5</l>
<l>    YAxisHeight := 1</l>
<l>endif</l>
<l>YScaleFactor := YAxisHeightPx / real(YAxisHeight)</l>
<l>YAxisOffsetPx := (YAxisPosition - XAxisStartValue) * XScaleFactor</l>
<l>XAxisOffsetPx := (XAxisPosition - YAxisStartValue) * YScaleFactor</l>
<c>* </c>
<c>* Display grid lines</c>
<c>* </c>
<l>if (GridColor != 'none')</l>
<l>    DotStyle := [5,7]</l>
<l>    set_line_style (WindowHandle, DotStyle)</l>
<l>    dev_set_color (GridColor)</l>
<c>    * </c>
<c>    * Display x grid lines</c>
<l>    if (XGrid != 'none')</l>
<l>        if (XGrid == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' grid line coordinates</c>
<l>            if (YAxisPosition == XAxisStartValue)</l>
<l>                XGridValues := [XAxisStartValue,XAxisEndValue]</l>
<l>            else</l>
<l>                XGridValues := [XAxisStartValue,YAxisPosition,XAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant grid line coordinates</c>
<l>            XGridStart := ceil(XAxisStartValue / XGrid) * XGrid</l>
<l>            XGridValues := [XGridStart:XGrid:XAxisEndValue]</l>
<l>        endif</l>
<l>        XCoord := (XGridValues - XAxisStartValue) * XScaleFactor</l>
<c>        * Generate and display grid lines</c>
<l>        for IndexGrid := 0 to |XGridValues| - 1 by 1</l>
<l>            gen_contour_polygon_xld (ContourXGrid, [Height - LowerBorder,UpperBorder], [LeftBorder + XCoord[IndexGrid],LeftBorder + XCoord[IndexGrid]])</l>
<l>            dev_display (ContourXGrid)</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * </c>
<c>    * Display y grid lines</c>
<l>    if (YGrid != 'none')</l>
<l>        if (YGrid == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' grid line coordinates</c>
<l>            if (XAxisPosition == YAxisStartValue)</l>
<l>                YGridValues := [YAxisStartValue,YAxisEndValue]</l>
<l>            else</l>
<l>                YGridValues := [YAxisStartValue,XAxisPosition,YAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant grid line coordinates</c>
<l>            YGridStart := ceil(YAxisStartValue / YGrid) * YGrid</l>
<l>            YGridValues := [YGridStart:YGrid:YAxisEndValue]</l>
<l>        endif</l>
<l>        YCoord := (YGridValues - YAxisStartValue) * YScaleFactor</l>
<c>        * Generate and display grid lines</c>
<l>        for IndexGrid := 0 to |YGridValues| - 1 by 1</l>
<l>            gen_contour_polygon_xld (ContourYGrid, [Height - LowerBorder - YCoord[IndexGrid],Height - LowerBorder - YCoord[IndexGrid]], [LeftBorder,Width - RightBorder])</l>
<l>            dev_display (ContourYGrid)</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<l>set_line_style (WindowHandle, [])</l>
<c>* </c>
<c>* </c>
<c>* Display the coordinate system axes</c>
<l>if (AxesColor != 'none')</l>
<c>    * Display axes</c>
<l>    dev_set_color (AxesColor)</l>
<l>    gen_arrow_contour_xld (XArrow, Height - LowerBorder - XAxisOffsetPx, LeftBorder, Height - LowerBorder - XAxisOffsetPx, Width - RightBorder, 0, 0)</l>
<l>    dev_display (XArrow)</l>
<l>    gen_arrow_contour_xld (YArrow, Height - LowerBorder, LeftBorder + YAxisOffsetPx, UpperBorder, LeftBorder + YAxisOffsetPx, 0, 0)</l>
<l>    dev_display (YArrow)</l>
<c>    * Display labels</c>
<l>    get_string_extents (WindowHandle, XLabel, Ascent, Descent, TextWidthXLabel, TextHeightXLabel)</l>
<l>    get_string_extents (WindowHandle, YLabel, Ascent, Descent, TextWidthYLabel, TextHeightYLabel)</l>
<l>    if (YTickDirection == 'right')</l>
<l>        if (XTickDirection == 'up')</l>
<l>            dev_disp_text (XLabel, 'image', Height - LowerBorder - TextHeightXLabel - 3, Width - RightBorder - TextWidthXLabel - 3, AxesColor, 'box', 'false')</l>
<l>            dev_disp_text (' ' + YLabel, 'image', UpperBorder, LeftBorder + 3 + YAxisOffsetPx, AxesColor, 'box', 'false')</l>
<l>        else</l>
<l>            dev_disp_text (XLabel, 'image', Height - LowerBorder + 3 - XAxisOffsetPx, Width - RightBorder - TextWidthXLabel - 3, AxesColor, 'box', 'false')</l>
<l>            dev_disp_text (' ' + YLabel, 'image', Height - LowerBorder - TextHeightXLabel - 3, LeftBorder + 3 + YAxisOffsetPx, AxesColor, 'box', 'false')</l>
<l>        endif</l>
<l>    else</l>
<l>        if (XTickDirection == 'up')</l>
<l>            dev_disp_text (XLabel, 'image', Height - LowerBorder - 2*TextHeightXLabel + 3, LeftBorder - 3, AxesColor, 'box', 'false')</l>
<l>            dev_disp_text (' ' + YLabel, 'image', UpperBorder, Width - RightBorder - TextWidthYLabel - 13, AxesColor, 'box', 'false')</l>
<l>        else</l>
<l>            dev_disp_text (XLabel, 'image', Height - LowerBorder + 3 - XAxisOffsetPx, LeftBorder - 3, AxesColor, 'box', 'false')</l>
<l>            dev_disp_text (' ' + YLabel, 'image', Height - LowerBorder - TextHeightXLabel - 3, Width - RightBorder - 2*TextWidthYLabel - 3, AxesColor, 'box', 'false')</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Display ticks</c>
<c>* </c>
<l>if (AxesColor != 'none')</l>
<l>    dev_set_color (AxesColor)</l>
<l>    if (XTicks != 'none')</l>
<c>        * </c>
<c>        * Display x ticks</c>
<l>        if (XValuesAreStrings)</l>
<c>            * Display string XValues as categories</c>
<l>            XTicks := |XValues| / |XTickValues|</l>
<l>            XCoord := (XValues - XAxisStartValue) * XScaleFactor</l>
<l>        else</l>
<c>            * Display tick values</c>
<l>            if (XTicks == 'min_max_origin')</l>
<c>                * Calculate 'min_max_origin' tick coordinates</c>
<l>                if (YAxisPosition == XAxisStartValue)</l>
<l>                    XTickValues := [XAxisStartValue,XAxisEndValue]</l>
<l>                else</l>
<l>                    XTickValues := [XAxisStartValue,YAxisPosition,XAxisEndValue]</l>
<l>                endif</l>
<l>            else</l>
<c>                * Calculate equidistant tick coordinates</c>
<l>                XTickStart := ceil(XAxisStartValue / XTicks) * XTicks</l>
<l>                XTickValues := [XTickStart:XTicks:XAxisEndValue]</l>
<l>            endif</l>
<l>            XCoord := (XTickValues - XAxisStartValue) * XScaleFactor</l>
<c>            * Remove ticks that are smaller than the x-axis start.</c>
<l>            Indices := find(XCoord [&lt;] XAxisStartValue, 1)</l>
<l>            XCoord := remove (XCoord, Indices)</l>
<l>            XTickValues := remove (XTickValues, Indices)</l>
<c>            *  </c>
<l>            if (FormatX == 'default')</l>
<l>                TypeTicks := type(XTicks)</l>
<l>                if (TypeTicks == H_TYPE_STRING)</l>
<c>                    * String ('min_max_origin')</c>
<c>                    * Format depends on actual values</c>
<l>                    TypeTicks := type(XTickValues)</l>
<l>                endif</l>
<l>                if (TypeTicks == H_TYPE_INT)</l>
<c>                    * Round to integer</c>
<l>                    XTickValues := int(XTickValues)</l>
<l>                else</l>
<c>                    * Use floating point numbers</c>
<l>                    XTickValues := XTickValues$'.2f'</l>
<l>                endif</l>
<l>            else</l>
<l>                XTickValues := XTickValues$FormatX</l>
<l>            endif</l>
<l>        endif</l>
<c>        * Generate and display ticks</c>
<l>        for IndexTicks := 0 to |XTickValues| - 1 by 1</l>
<l>            get_string_extents (WindowHandle, XTickValues[IndexTicks], Ascent1, Descent1, TextWidthXTicks, TextHeightXTicks)</l>
<l>            if (XTickDirection == 'up')</l>
<l>                gen_contour_polygon_xld (ContourXTick, [Height - LowerBorder - XAxisOffsetPx,Height - LowerBorder - XAxisOffsetPx - 5], [LeftBorder + XCoord[IndexTicks],LeftBorder + XCoord[IndexTicks]])</l>
<l>                dev_disp_text (XTickValues[IndexTicks], 'image', Height - LowerBorder + 2 - XAxisOffsetPx, LeftBorder + XCoord[IndexTicks], AxesColor, 'box', 'false')</l>
<l>            else</l>
<l>                gen_contour_polygon_xld (ContourXTick, [Height - LowerBorder - XAxisOffsetPx + 5,Height - LowerBorder - XAxisOffsetPx], [LeftBorder + XCoord[IndexTicks],LeftBorder + XCoord[IndexTicks]])</l>
<l>                dev_disp_text (XTickValues[IndexTicks], 'image', Height- LowerBorder - 2*TextHeightXTicks - XAxisOffsetPx, LeftBorder + XCoord[IndexTicks], AxesColor, 'box', 'false')</l>
<l>            endif</l>
<l>            dev_display (ContourXTick)</l>
<l>        endfor</l>
<l>    endif</l>
<c>    * </c>
<l>    if (YTicks != 'none')</l>
<c>        * </c>
<c>        * Display y ticks</c>
<l>        if (YTicks == 'min_max_origin')</l>
<c>            * Calculate 'min_max_origin' tick coordinates</c>
<l>            if (XAxisPosition == YAxisStartValue)</l>
<l>                YTickValues := [YAxisStartValue,YAxisEndValue]</l>
<l>            else</l>
<l>                YTickValues := [YAxisStartValue,XAxisPosition,YAxisEndValue]</l>
<l>            endif</l>
<l>        else</l>
<c>            * Calculate equidistant tick coordinates</c>
<l>            YTickStart := ceil(YAxisStartValue / YTicks) * YTicks</l>
<l>            YTickValues := [YTickStart:YTicks:YAxisEndValue]</l>
<l>        endif</l>
<l>        YCoord := (YTickValues - YAxisStartValue) * YScaleFactor</l>
<c>        * Remove ticks that are smaller than the y-axis start.</c>
<l>        Indices := find(YCoord [&lt;] YAxisStartValue, 1)</l>
<l>        YCoord := remove (YCoord, Indices)</l>
<l>        YTickValues := remove (YTickValues, Indices)</l>
<c>        *</c>
<l>        if (FormatY == 'default')</l>
<l>            TypeTicks := type(YTicks)</l>
<l>            if (TypeTicks == H_TYPE_STRING)</l>
<c>                * String ('min_max_origin')</c>
<c>                * Format depends on actual values</c>
<l>                TypeTicks := type(YTickValues)</l>
<l>            endif</l>
<l>            if (TypeTicks == H_TYPE_INT)</l>
<c>                * Round to integer</c>
<l>                YTickValues := int(YTickValues)</l>
<l>            else</l>
<c>                * Use floating point numbers</c>
<l>                YTickValues := YTickValues$'.2f'</l>
<l>            endif</l>
<l>        else</l>
<l>            YTickValues := YTickValues$FormatY</l>
<l>        endif</l>
<c>        * Generate and display ticks</c>
<l>        for IndexTicks := 0 to |YTickValues| - 1 by 1</l>
<l>            get_string_extents (WindowHandle, YTickValues[IndexTicks], Ascent1, Descent1, TextWidthYTicks, TextHeightYTicks)</l>
<l>            if (YTickDirection == 'right')</l>
<l>                gen_contour_polygon_xld (ContourYTick, [Height - LowerBorder - YCoord[IndexTicks],Height - LowerBorder - YCoord[IndexTicks]], [LeftBorder + YAxisOffsetPx,LeftBorder + YAxisOffsetPx + 5])</l>
<l>                dev_disp_text (YTickValues[IndexTicks], 'image', Height - LowerBorder - TextHeightYTicks + 3 - YCoord[IndexTicks], LeftBorder - TextWidthYTicks - 2 + YAxisOffsetPx, AxesColor, 'box', 'false')</l>
<l>            else</l>
<l>                gen_contour_polygon_xld (ContourYTick, [Height - LowerBorder - YCoord[IndexTicks],Height - LowerBorder - YCoord[IndexTicks]], [LeftBorder + YAxisOffsetPx-5,LeftBorder + YAxisOffsetPx])</l>
<l>                dev_disp_text (YTickValues[IndexTicks], 'image', Height - LowerBorder - TextHeightYTicks + 3 - YCoord[IndexTicks], LeftBorder +  2 + YAxisOffsetPx, AxesColor, 'box', 'false')</l>
<l>            endif</l>
<l>            dev_display (ContourYTick)</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* Display function plot</c>
<c>* </c>
<l>if (Color != 'none')</l>
<l>    if (XValues != [] and YValues != [])</l>
<l>        Num := |YValues| / |XValues|</l>
<c>        * </c>
<c>        * Iterate over all functions to be displayed</c>
<l>        for I := 0 to Num - 1 by 1</l>
<c>            * Select y values for current function</c>
<l>            YSelected := YValues[I * |XValues|:(I + 1) * |XValues| - 1]</l>
<c>            * Set color</c>
<l>            if (Color == [])</l>
<l>                set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>            else</l>
<l>                dev_set_color (Color[I % |Color|])</l>
<l>            endif</l>
<c>            * </c>
<c>            * Display in different styles</c>
<c>            * </c>
<l>            if (Style == 'line' or Style == [])</l>
<c>                * Line</c>
<l>                gen_contour_polygon_xld (Contour, Height - LowerBorder - YSelected * YScaleFactor + YAxisStartValue * YScaleFactor, XValues * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor)</l>
<c>                * Clip, if necessary</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_contours_xld (Contour, Contour, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Contour)</l>
<l>            elseif (Style == 'cross')</l>
<c>                * Cross</c>
<l>                gen_cross_contour_xld (Cross, Height - LowerBorder - YSelected * YScaleFactor + YAxisStartValue * YScaleFactor, XValues * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor, 6, 0.785398)</l>
<c>                * Clip, if necessary</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_contours_xld (Cross, Cross, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Cross)</l>
<l>            elseif (Style == 'filled')</l>
<c>                * Filled</c>
<l>                Y1Selected := [0 + XAxisPosition,YSelected,0 + XAxisPosition]</l>
<l>                X1Selected := [min(XValues),XValues,max(XValues)]</l>
<l>                dev_set_draw ('fill')</l>
<l>                gen_region_polygon_filled (Filled, Height - LowerBorder - Y1Selected * YScaleFactor + YAxisStartValue * YScaleFactor, X1Selected * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor)</l>
<c>                * Clip, if necessary</c>
<l>                if (Clip == 'yes')</l>
<l>                    clip_region (Filled, Filled, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Filled)</l>
<l>            elseif (Style == 'step')</l>
<l>                gen_empty_obj (Stair)</l>
<l>                for Index := 0 to |XValues|-2 by 1</l>
<l>                    Row1 := Height - LowerBorder - YSelected[Index] * YScaleFactor + YAxisStartValue * YScaleFactor</l>
<l>                    Row2 := Height - LowerBorder - YSelected[Index+1] * YScaleFactor + YAxisStartValue * YScaleFactor</l>
<l>                    Col1 := XValues[Index] * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor</l>
<l>                    Col2 := XValues[Index+1] * XScaleFactor + LeftBorder - XAxisStartValue * XScaleFactor</l>
<l>                    gen_contour_polygon_xld (StairTmp,[Row1, Row1, Row2],[Col1, Col2, Col2])</l>
<l>                    concat_obj (Stair, StairTmp, Stair)</l>
<l>                endfor</l>
<l>                union_adjacent_contours_xld (Stair, Stair, 0.1, 0.1, 'attr_keep')</l>
<l>                if (Clip == 'yes')</l>
<l>                    clip_region (Stair, Stair, UpperBorder, LeftBorder, Height - LowerBorder, Width - RightBorder)</l>
<l>                endif</l>
<l>                dev_display (Stair)</l>
<l>            else</l>
<l>                throw ('Unsupported style: ' + Style)</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endif</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<c>* Reset original display settings</c>
<l>dev_set_part (PartRow1, PartColumn1, PartRow2, PartColumn2)</l>
<l>dev_set_window (PreviousWindowHandle)</l>
<l>set_rgb (WindowHandle, Red, Green, Blue)</l>
<l>dev_set_draw (DrawMode)</l>
<l>set_line_style (WindowHandle, OriginStyle)</l>
<l>set_system ('clip_region', ClipRegion)</l>
<l>return ()</l>
</body>
<docu id="plot_tuple">
<abstract lang="en_US">This procedure plots the functions or curves represented by the coordinates in XValues and YValues into the graphic window given in WindowHandle.
The axes of the coordinate system are labeled with XLabel and YLabel.
The appearance of the output can further be adapted using generic parameters given in GenericParamName and GenericParamValue.

In particular, following parameters can be set:

XValues: X values of the function to be plotted.

          If XValues is set to [], it is internally set to 0,1,2,...,|YValues|-1.
          If XValues is a tuple of strings, the values are taken as categories.

 YValues: Y values of the function(s) to be plotted.

          If YValues is set to [], it is internally set to 0,1,2,...,|XValues|-1.
          The number of y values must be equal to the number of x values
          or an integral multiple. In the latter case,
          multiple functions are plotted, that share the same x values.

 XLabel: X-axis label.

 XLabel: Y-axis label.

 Color: Color of the plotted function.

        If [] is given, the currently set display color is used.
        If 'none' is given, the function is not plotted, but only
        the coordinate axes as specified.
        If more than one color is given, multiple functions 
        can be displayed in different colors.

 GenParamName: Generic parameters to control the presentation.

                Possible Values:

    'axes_color': coordinate system color.
                  Default: 'white'
                  If 'none' is given, no coordinate system is shown. 

    'style': Graph style.
             Possible values: 'line' (default), 'cross', 'stair', 'filled'

    'clip': Clip graph to coordinate system area.
            Possible values: 'no' (default), 'yes''

    'ticks': Control display of ticks on the axes.
             If 'min_max_origin' is given (default), ticks are shown 
             at the minimum and maximum values of the axes and at the
             intercept point of x- and y-axis.
             If 'none' is given, no ticks are shown.
             If any number != 0 is given, it is interpreted as distance
             between the ticks.

    'ticks_x': Control display of ticks on x-axis only.

    'ticks_y': Control display of ticks on x-axis only.

    'format_x': Format of the values next to the ticks of the x-axis 
                (see tuple_string for more details).

    'format_y': Format of the values next to the ticks of the y-axis
                (see tuple_string for more details).

    'grid': Control display of grid lines within the coordinate system.
            If 'min_max_origin' is given (default), grid lines are shown 
            at the minimum and maximum values of the axes.
            If 'none' is given, no grid lines are shown.
            If any number != 0 is given, it is interpreted as distance
            between the grid lines.

    'grid_x': Control display of grid lines for the x-axis only.

    'grid_y': Control display of grid lines for the y-axis only.

    'grid_color': Color of the grid (default: 'dim gray').

    'margin': The distance in pixels of the coordinate system area
              to all four window borders.

    'margin_left': The distance in pixels of the coordinate system area
                   to the left window border.

    'margin_right': The distance in pixels of the coordinate system area
                    to the right window border.

    'margin_top': The distance in pixels of the coordinate system area
                    to the upper window border.

    'margin_bottom'': The distance in pixels of the coordinate system area
                    to the lower window border.

    'start_x': Lowest x value of the x-axis.
               Default: min(XValues)

    'end_x': Highest x value of the x-axis.
             Default: max(XValues)

    'start_y': Lowest y value of the y-axis.
               Default: min(YValues)

    'end_y': Highest y value of the y-axis.
             Default: max(YValues)

    'axis_location_x': Either 'bottom', 'origin', or 'top' to position the x-axis conveniently, or the Y coordinate of the intercept point of x- and y-axis.
                Default: 'bottom'
                (Used to be called 'origin_y')

    'axis_location_y': Either 'left', 'origin', or 'right' to position the y-axis conveniently, or the X coordinate of the intercept point of x- and y-axis.
                Default: 'left'
                (Used to be called 'origin_x')

 GenParamValue: Values of the generic parameters of GenericParamName.</abstract>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">dev_open_window (0, 0, 512, 512, 'black', WindowHandle)
X := [-rad(180): 0.01: rad(180)]
Y1 := sin(X)
Y2 := (X * X) * 0.2 - 1
XLabel := 'x'
YLabel := 'y'
Color := ['medium slate blue', 'yellow']
GenParamName := []
GenParamValue := []
plot_tuple (WindowHandle, X, [Y1, Y2], XLabel, YLabel, Color, GenParamName, GenParamValue)
</example>
<keywords lang="en_US">
<item>plot</item>
<item>tuple</item>
<item>function</item>
<item>display</item>
<item>graph</item>
<item>curve</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>funct_1d_to_pairs</item>
</predecessor>
<short lang="en_US"> This procedure plots tuples representing functions or curves in a coordinate system.</short>
<parameters>
<parameter id="Color">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Color of the function plot.</description>
<multivalue>optional</multivalue>
<sem_type>color</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'red'</item>
<item>'green'</item>
<item>'yellow'</item>
<item>'white'</item>
<item>'black'</item>
<item>'cyan'</item>
<item>'magenta'</item>
<item>'blue'</item>
<item>'orange'</item>
</values>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of generic parameters.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'axes_color'</item>
<item>'style'</item>
<item>'clip'</item>
<item>'ticks'</item>
<item>'ticks_x'</item>
<item>'ticks_y'</item>
<item>'grid'</item>
<item>'grid_x'</item>
<item>'grid_y'</item>
<item>'grid_color'</item>
<item>'margin'</item>
<item>'margin_left'</item>
<item>'margin_right'</item>
<item>'margin_top'</item>
<item>'margin_bottom'</item>
<item>'start_x'</item>
<item>'end_x'</item>
<item>'start_y'</item>
<item>'end_y'</item>
<item>'origin_y'</item>
<item>'origin_x'</item>
<item>'position_y'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Generic parameter values.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window handle in which the plot should be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="XLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the x-axis.</description>
</parameter>
<parameter id="XValues">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">X values of the function to be plotted.</description>
<multivalue>optional</multivalue>
<sem_type>coordinates.x</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="YLabel">
<default_value>[]</default_value>
<description lang="en_US">Label of the y-axis.</description>
</parameter>
<parameter id="YValues">
<default_type>real</default_type>
<description lang="en_US">Y values of the function to be plotted.</description>
<multivalue>optional</multivalue>
<sem_type>coordinates.y</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="prepare_poses_and_rectification_data_moving_cam">
<interface>
<ic>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="ObjectHeight" base_type="ctrl" dimension="0"/>
<par name="RectifyImage" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Prepare the needed poses to match and grasp, and compute the rectification map.</c>
<c>*</c>
<c>* RectifyImage Parameter can have one of the following 3 values:</c>
<c>* 'no_rectification', 'align_and_rectify', or 'only_rectify'</c>
<c>*</c>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (HandEyeCalibData, 'ToolInCamPose', ToolInCamPose)</l>
<l>read_message_tuple (HandEyeCalibData, 'PlaneInBasePose0', PlaneInBasePose0)</l>
<c>*</c>
<c>* Check input</c>
<l>if (ObjectHeight &lt; 0.0)</l>
<l>    throw ('The parameter ObjectHeight cannot be negative')</l>
<l>endif</l>
<l>if (CamParam[0] == 'line_scan')</l>
<l>    throw ('Line-scan cameras are not supported')</l>
<l>endif</l>
<c>*</c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (ToolInBasePose, 'Rp+T', 'gba', 'point', ToolInBasePose)</l>
<l>convert_pose_type (ToolInCamPose, 'Rp+T', 'gba', 'point', ToolInCamPose)</l>
<l>convert_pose_type (PlaneInBasePose0, 'Rp+T', 'gba', 'point', PlaneInBasePose0)</l>
<c>*</c>
<c>* Create the plane for matching and adapt the PlaneInBasePose0 such</c>
<c>* that the z-axis of the plane points away from the reference camera,</c>
<c>* and x/y coordinates are aligned with the current image, i.e.</c>
<c>* PlaneInCamPose0 has Rot_z=0.</c>
<l>pose_invert (ToolInBasePose, BaseInToolPose)</l>
<l>pose_compose (ToolInCamPose, BaseInToolPose, BaseInCamPose)</l>
<l>pose_compose (BaseInCamPose, PlaneInBasePose0, PlaneInCamPose0)</l>
<c>* The z-axis of the plane should point away from the camera.</c>
<l>PlaneInCamPose0Rot := PlaneInCamPose0</l>
<l>PlaneInCamPose0Rot[0:2] := [0,0,0]</l>
<l>pose_to_hom_mat3d (PlaneInCamPose0Rot, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, 0, 0, 1, Qx, Qy, CosAngleBetweenZAxis)</l>
<l>if (CosAngleBetweenZAxis &lt; 0)</l>
<l>    create_pose (0, 0, 0, 180, 0, 0, 'Rp+T', 'gba', 'point', SwitchZDirection)</l>
<l>    pose_compose (PlaneInCamPose0, SwitchZDirection, PlaneInCamPose1)</l>
<l>    PlaneInCamPose0 := PlaneInCamPose1</l>
<l>endif</l>
<c>* Align with the current image.</c>
<l>PlaneInCamPose := PlaneInCamPose0</l>
<l>PlaneInCamPose[5] := 0.0</l>
<c>* Adapt the PlaneInBasePose.</c>
<l>pose_invert (BaseInCamPose, CamInBasePose)</l>
<l>pose_compose (CamInBasePose, PlaneInCamPose, PlaneInBasePose)</l>
<c>*</c>
<c>* Create the plane for matching.</c>
<l>create_pose (0, 0, -ObjectHeight, 0, 0, 0, 'Rp+T', 'gba', 'point', MatchingPlaneInPlanePose)</l>
<l>pose_compose (PlaneInBasePose, MatchingPlaneInPlanePose, MatchingPlaneInBasePose)</l>
<l>pose_compose (PlaneInCamPose, MatchingPlaneInPlanePose, MatchingPlaneInCamPose)</l>
<c>*</c>
<l>if (RectifyImage = 'no_rectification')</l>
<l>    MatchingPlaneRectifiedPartInCamPose := MatchingPlaneInCamPose</l>
<l>    ScaleRectification := []</l>
<l>elseif (RectifyImage == 'only_rectify' or RectifyImage == 'align_and_rectify')</l>
<c>    * Determine the scale such that the mapped image has at least</c>
<c>    * the same resolution as the current image.</c>
<l>    get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>    get_cam_par_data (CamParam, 'image_height', Height)</l>
<l>    gen_grid_region (RegionGrid, 20, 20, 'points', Width, Height)</l>
<l>    get_region_points (RegionGrid, Rows, Columns)</l>
<l>    gen_circle_contour_xld (ContCircle, Rows, Columns, gen_tuple_const(|Rows|,1.0), 0, 6.28318, 'positive', 0.1)</l>
<l>    contour_to_world_plane_xld (ContCircle, ContCircleWorldPlane, CamParam, MatchingPlaneInCamPose, 'm')</l>
<l>    fit_ellipse_contour_xld (ContCircleWorldPlane, 'fitzgibbon', -1, 0, 0, 200, 3, 2, Row, Column, Phi, Radius1, Radius2, StartPhi, EndPhi, PointOrder)</l>
<l>    ScaleRectification := min(Radius2)</l>
<c>    *</c>
<c>    * Rectify the current image and create the shape model.</c>
<c>    *</c>
<c>    * The image dimensions should cover the entire original field </c>
<c>    * of view in the current rectification.</c>
<c>    * Look at border of the current image in the world plane.</c>
<l>    get_system ('clip_region', ClipRegion)</l>
<l>    set_system ('clip_region', 'false')</l>
<l>    gen_rectangle1 (ImageArea, 0, 0, Height - 1, Width - 1)</l>
<l>    boundary (ImageArea, RegionBorder, 'outer')</l>
<l>    set_system ('clip_region', ClipRegion)</l>
<l>    get_region_points (RegionBorder, BorderRows, BorderColumns)</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, BorderRows, BorderColumns, 'm', BorderX, BorderY)</l>
<c>    * Adapt parameters.</c>
<l>    create_pose (min(BorderX), min(BorderY), 0, 0, 0, 0, 'Rp+T', 'gba', 'point', MatchingPlaneRectifiedPartInMatchingPlanePose)</l>
<l>    pose_compose (MatchingPlaneInCamPose, MatchingPlaneRectifiedPartInMatchingPlanePose, MatchingPlaneRectifiedPartInCamPose)</l>
<l>    WidthRect := int((max(BorderX) - min(BorderX)) / ScaleRectification + 0.5)</l>
<l>    HeightRect := int((max(BorderY) - min(BorderY)) / ScaleRectification + 0.5)</l>
<c>    * </c>
<c>    * Create a map for repeated use.</c>
<l>    gen_image_to_world_plane_map (RectificationMap, CamParam, MatchingPlaneInCamPose, Width, Height, WidthRect, HeightRect, ScaleRectification, 'bilinear')</l>
<l>else</l>
<l>    throw('Please set the parameter RectifyImage correctly')</l>
<l>endif</l>
<c>* Convert to output pose type.</c>
<l>convert_pose_type (PlaneInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, PlaneInCamPose)</l>
<l>convert_pose_type (CamInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, CamInBasePose)</l>
<l>convert_pose_type (PlaneInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, PlaneInBasePose)</l>
<l>convert_pose_type (MatchingPlaneInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneInCamPose)</l>
<l>convert_pose_type (MatchingPlaneInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneInBasePose)</l>
<l>convert_pose_type (MatchingPlaneRectifiedPartInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneRectifiedPartInCamPose)</l>
<c>*</c>
<l>create_pose (0, 0, ObjectHeight, 180, 0, 0, 'Rp+T', 'gba', 'point', ModelInPlanePose)</l>
<c>* Remember the transformation.</c>
<l>pose_invert (ModelInPlanePose, PlaneInModelPose)</l>
<c>*</c>
<c>* Create message for Poses.</c>
<l>create_message (Poses)</l>
<l>set_message_tuple (Poses, 'PlaneInCamPose', PlaneInCamPose)</l>
<l>set_message_tuple (Poses, 'CamInBasePose', CamInBasePose)</l>
<l>set_message_tuple (Poses, 'PlaneInBasePose', PlaneInBasePose)</l>
<l>set_message_tuple (Poses, 'MatchingPlaneInCamPose', MatchingPlaneInCamPose)</l>
<l>set_message_tuple (Poses, 'MatchingPlaneInBasePose', MatchingPlaneInBasePose)</l>
<l>set_message_tuple (Poses, 'PlaneInModelPose', PlaneInModelPose)</l>
<c>*</c>
<c>* Create message for rectification data.</c>
<l>create_message (RectificationData)</l>
<l>set_message_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage != 'no_rectification')</l>
<l>    set_message_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>    set_message_obj (RectificationMap, RectificationData, 'RectificationMap')</l>
<l>endif</l>
<l>set_message_tuple (RectificationData, 'MatchingPlaneRectifiedPartInCamPose', MatchingPlaneRectifiedPartInCamPose)</l>
<l>return ()</l>
</body>
<docu id="prepare_poses_and_rectification_data_moving_cam">
<abstract lang="en_US">This procedure prepares the model needed to later match an object and grasp it in 3D, in a moving camera setup.

The input parameter ToolInBasePose describes the current pose of the robot tool. 

The input message HandEyeCalibData must contain the poses ToolInCamPose and PlaneInBasePose0 as well as the camera parameters CamParam. Please refer to the example calibrate_hand_eye_scara_moving_cam.hdev for more details.

In ObjectHeight, the height of the object to be matched is passed.
 
The parameter RectifyImage can have on of three values: 'no_rectification', 'only_rectify', or 'align_and_rectify'. This parameter is then stored in the output message RectificationData.

The output message Poses contains the following data: 
- The pose PlaneInCamPose is the pose where x and y coordinates are aligned with the current image and the z-axis of the plane points away from the reference camera. 
- The pose PlaneInBasePose is the respective adaptation of PlaneInBasePose0.
- The pose PlaneInModelPose contains the pose of the plane with respect to the model.
- The pose CamInBasePose contains the pose of the camera in the base coordinate system.
- The matching plane is defined as the actual plane translated in the negative z-direction (towards the camera) by the object's height as given by ObjectHeight.The poses MatchingPlaneInCamPose and MatchingPlaneInBasePose are calculated accordingly.

The output message RectificationData contains the following data:
- The above-mentioned parameter RectifyImage.
- The parameters ScaleRectification is the rectification scale as explained in the documentation of the image_to_world_plane operator. 
- The pose MatchingPlaneRectifiedPartInCamPose is the world pose in the camera coordinate system which is used to align the image as explained in image_to_world_plane operator.
- The RectificationMap that can be used with map_image.</abstract>
<alternatives>
<item>prepare_poses_and_rectification_data_stationary_cam</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>set_message_tuple</item>
</predecessor>
<short lang="en_US">Prepares the model to match and grasp.</short>
<successor>
<item>get_message_tuple</item>
<item>get_message_obj</item>
<item>map_image</item>
<item>create_shape_model</item>
<item>rectify_image_and_compute_matching_plane_moving_cam</item>
<item>obtain_3d_pose_of_match_moving_cam</item>
</successor>
<parameters>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain: ToolInCamPose, PlaneInBasePose0, and CamParam.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ObjectHeight">
<default_type>real</default_type>
<description lang="en_US">Height of the object to be matched.</description>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Message that contains the poses PlaneInCamPose, PlaneInBasePose, PlaneInModelPose, CamInBasePose, MatchingPlaneInCamPose, and MatchingPlaneInBasePose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Message that contains RectifyImage, ScaleRectification, MatchingPlaneRectifiedPartInCamPose, and RectificationMap.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectifyImage">
<default_type>string</default_type>
<default_value>'only_rectify'</default_value>
<description lang="en_US">Only when the camera is perpendicular to your image plane with constant distance (might reduce runtime): 'no_rectification'
Align the images according to the matching training image and rectify: 'align_and_rectify'
Only rectify: 'only_rectify'</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'no_rectification'</item>
<item>'align_and_rectify'</item>
<item>'only_rectify'</item>
</values>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Pose of the tool in the base coordinate system.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="prepare_poses_and_rectification_data_stationary_cam">
<interface>
<ic>
<par name="ObjectHeight" base_type="ctrl" dimension="0"/>
<par name="RectifyImage" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Prepare the needed poses to match and grasp, and compute the rectification</c>
<c>* map in case rectification is set by the user.</c>
<c>*</c>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (HandEyeCalibData, 'PlaneInCamPose0', PlaneInCamPose0)</l>
<c>*</c>
<c>* Check input</c>
<l>if (ObjectHeight &lt; 0.0)</l>
<l>    throw ('The parameter ObjectHeight cannot be negative')</l>
<l>endif</l>
<l>if (CamParam[0] == 'line_scan')</l>
<l>    throw ('Line-scan cameras are not supported')</l>
<l>endif</l>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (PlaneInCamPose0, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (PlaneInCamPose0, 'Rp+T', 'gba', 'point', PlaneInCamPose0)</l>
<c>* The z-axis of the plane should point away from the camera.</c>
<l>PlaneInCamPose0Rot := PlaneInCamPose0</l>
<l>PlaneInCamPose0Rot[0:2] := [0,0,0]</l>
<l>pose_to_hom_mat3d (PlaneInCamPose0Rot, HomMat3D)</l>
<l>affine_trans_point_3d (HomMat3D, 0, 0, 1, Qx, Qy, CosAngleBetweenZAxis)</l>
<l>if (CosAngleBetweenZAxis&lt;0)</l>
<l>    create_pose (0, 0, 0, 180, 0, 0, 'Rp+T', 'gba', 'point', SwitchZDirection)</l>
<l>    pose_compose (PlaneInCamPose0, SwitchZDirection, PlaneInCamPose0)</l>
<l>endif</l>
<c>* Align with the current image.</c>
<l>PlaneInCamPose := PlaneInCamPose0</l>
<l>PlaneInCamPose[5] := 0.0</l>
<c>* </c>
<c>* Create the plane for matching.</c>
<l>create_pose (0, 0, -ObjectHeight, 0, 0, 0, 'Rp+T', 'gba', 'point', MatchingPlaneInPlanePose)</l>
<l>pose_compose (PlaneInCamPose, MatchingPlaneInPlanePose, MatchingPlaneInCamPose)</l>
<c>* </c>
<l>if (RectifyImage = 'false')</l>
<l>    ScaleRectification := []</l>
<l>elseif (RectifyImage = 'true')</l>
<c>    * Determine the scale such that the mapped image has at least the same</c>
<c>    * resolution as the current image.</c>
<l>    get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>    get_cam_par_data (CamParam, 'image_height', Height)</l>
<l>    gen_grid_region (RegionGrid, 20, 20, 'points', Width, Height)</l>
<l>    get_region_points (RegionGrid, Rows, Columns)</l>
<l>    gen_circle_contour_xld (ContCircle, Rows, Columns, gen_tuple_const(|Rows|,1.0), 0, 6.28318, 'positive', 0.1)</l>
<l>    contour_to_world_plane_xld (ContCircle, ContCircleWorldPlane, CamParam, MatchingPlaneInCamPose, 'm')</l>
<l>    fit_ellipse_contour_xld (ContCircleWorldPlane, 'fitzgibbon', -1, 0, 0, 200, 3, 2, Row, Column, Phi, Radius1, Radius2, StartPhi, EndPhi, PointOrder)</l>
<l>    ScaleRectification := min(Radius2)</l>
<c>    * </c>
<c>    * Rectify the current image and create the shape model.</c>
<c>    * </c>
<c>    * The image dimensions should cover the entire original field of view</c>
<c>    * in the current rectification.</c>
<c>    * Look at border of the current image in the world plane.</c>
<l>    get_system ('clip_region', ClipRegion)</l>
<l>    set_system ('clip_region', 'false')</l>
<l>    gen_rectangle1 (ImageArea, 0, 0, Height - 1, Width - 1)</l>
<l>    boundary (ImageArea, RegionBorder, 'outer')</l>
<l>    set_system ('clip_region', ClipRegion)</l>
<l>    get_region_points (RegionBorder, BorderRows, BorderColumns)</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, BorderRows, BorderColumns, 'm', BorderX, BorderY)</l>
<c>    * Adapt parameters.</c>
<l>    create_pose (min(BorderX), min(BorderY), 0, 0, 0, 0, 'Rp+T', 'gba', 'point', PoseOffset)</l>
<l>    pose_compose (MatchingPlaneInCamPose, PoseOffset, MatchingPlaneInCamPose)</l>
<l>    WidthRect := int((max(BorderX) - min(BorderX)) / ScaleRectification + 0.5)</l>
<l>    HeightRect := int((max(BorderY) - min(BorderY)) / ScaleRectification + 0.5)</l>
<c>    * </c>
<c>    * Create a map for repeated use.</c>
<l>    gen_image_to_world_plane_map (RectificationMap, CamParam, MatchingPlaneInCamPose, Width, Height, WidthRect, HeightRect, ScaleRectification, 'bilinear')</l>
<l>else</l>
<l>    throw ('Please set the parameter RectifyImage correctly')</l>
<l>endif</l>
<c>* Convert to output pose type.</c>
<l>convert_pose_type (PlaneInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, PlaneInCamPose)</l>
<l>convert_pose_type (MatchingPlaneInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneInCamPose)</l>
<c>*</c>
<l>create_pose (0, 0, ObjectHeight, 180, 0, 0, 'Rp+T', 'gba', 'point', ModelInPlanePose)</l>
<c>* Remember the transformation.</c>
<l>pose_invert (ModelInPlanePose, PlaneInModelPose)</l>
<c>*</c>
<c>* Create message for Poses.</c>
<l>create_message (Poses)</l>
<l>set_message_tuple (Poses, 'PlaneInModelPose', PlaneInModelPose)</l>
<l>set_message_tuple (Poses, 'MatchingPlaneInCamPose', MatchingPlaneInCamPose)</l>
<l>set_message_tuple (Poses, 'PlaneInCamPose', PlaneInCamPose)</l>
<c>*</c>
<c>* Create message for rectification data.</c>
<l>create_message (RectificationData)</l>
<l>set_message_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage == 'true')</l>
<l>    set_message_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>    set_message_obj (RectificationMap, RectificationData, 'RectificationMap')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="prepare_poses_and_rectification_data_stationary_cam">
<abstract lang="en_US">The procedure prepare_poses_and_rectification_data_stationary_cam prepares the model needed to later match an object and grasp it in 3D, in a stationary camera setup. 

In ObjectHeight, the height of the object to be matched is passed.

The parameter RectifyImage specifies whether the input image is to be rectified of not. To improve the 2D matching, it is recommended to set it 'true'. This parameter is then stored in the output message RectificationData.

The input message HandEyeCalibrationData contains the pose PlaneInCamPose0 and the camera parameters CamParam, which can be both found through hand-eye calibration in a moving camera setup. Please refer to the example calibrate_hand_eye_stationary_cam_approx.hdev for more details.

The output message Poses contains the following data: 
- The output pose PlaneInCamPose is the pose where x and y coordinates are aligned with the current image and the z-axis of the plane points away from the reference camera.
- The pose PlaneInModelPose contains the pose of the plane with respect to the model.
- The matching plane is defined as the actual plane translated in the negative z-direction (towards the camera) by the object's height as given by ObjectHeight.The pose MatchingPlaneInCamPose is calculated accordingly.

The output message RectificationData contains the following data:
- The above-mentioned parameter RectifyImage.
- The parameters ScaleRectification is the rectification scale as explained in the documentation of the image_to_world_plane operator. 
- The rectification map that can be used with map_image.</abstract>
<alternatives>
<item>prepare_poses_and_rectification_data_moving_cam</item>
</alternatives>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>set_message_tuple</item>
</predecessor>
<short lang="en_US">Prepares the model to match and grasp in a stationary camera setup.</short>
<successor>
<item>get_message_tuple</item>
<item>get_message_obj</item>
<item>map_image</item>
<item>create_shape_model</item>
</successor>
<parameters>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain CamParam and PlaneInCamPose0.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ObjectHeight">
<default_type>real</default_type>
<description lang="en_US">Height of the object to be matched.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Message that contains: PlaneInModelPose, MatchingPlaneInCamPose, and PlaneInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Message that contains: RectifyImage, ScaleRectification, and RectificationMap.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectifyImage">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">Specify whether to rectify the image or not. Set it to 'false' only if the camera is orthogonal to your image plane with constant distance. This might reduce runtime.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="preprocess_dl_classifier_images">
<interface>
<io>
<par name="Images" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImagesPreprocessed" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="DLClassifierHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure preprocesses the provided images given by Image </c>
<c>* so that they can be handled by </c>
<c>* train_dl_classifier_batch and apply_dl_classifier_batch. </c>
<c>* Note that depending on the images, </c>
<c>* additional preprocessing steps might be beneficial. </c>
<c>*</c>
<c>* Set defaults.</c>
<l>ContrastNormalization := 'false'</l>
<l>DomainHandling := 'full_domain'</l>
<c>* Set generic parameters.</c>
<l>for GenParamIndex := 0 to |GenParamName| - 1 by 1</l>
<l>    if (GenParamName[GenParamIndex] == 'contrast_normalization')</l>
<c>        * Set 'contrast_normalization'</c>
<l>        ContrastNormalization := GenParamValue[GenParamIndex]</l>
<l>    elseif (GenParamName[GenParamIndex] == 'domain_handling')</l>
<c>        * Set 'domain_handling'</c>
<l>        DomainHandling := GenParamValue[GenParamIndex]</l>
<l>    else</l>
<l>        throw ('Unknown generic parameter: \'' + GenParamName[GenParamIndex] + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<c>*</c>
<c>* Get the network's image requirements </c>
<c>* from the handle of the classifier</c>
<c>* and use them as preprocessing parameters. </c>
<c>* </c>
<c>* Expected input image size:</c>
<l>get_dl_classifier_param (DLClassifierHandle, 'image_width', ImageWidth)</l>
<l>get_dl_classifier_param (DLClassifierHandle, 'image_height', ImageHeight)</l>
<c>* Expected gray value range:</c>
<l>get_dl_classifier_param (DLClassifierHandle, 'image_range_min', ImageRangeMin)</l>
<l>get_dl_classifier_param (DLClassifierHandle, 'image_range_max', ImageRangeMax)</l>
<c>* Expected number of channels: </c>
<l>get_dl_classifier_param (DLClassifierHandle, 'image_num_channels', ImageNumChannels)</l>
<c>*</c>
<c>* Preprocess the images.</c>
<c>*</c>
<l>if (DomainHandling == 'full_domain')</l>
<l>    full_domain (Images, Images)</l>
<l>elseif (DomainHandling == 'crop_domain')</l>
<l>    crop_domain (Images, Images)</l>
<l>else</l>
<l>    throw ('Unsupported parameter value for \'domain_handling\'')</l>
<l>endif</l>
<c>*</c>
<c>* Zoom images only if they have a different size than the specified size</c>
<l>get_image_size (Images, ImageWidthInput, ImageHeightInput)</l>
<l>EqualWidth := ImageWidth [==] ImageWidthInput</l>
<l>EqualHeight := ImageHeight [==] ImageHeightInput</l>
<l>if (min(EqualWidth) == 0 or min(EqualHeight) == 0)</l>
<l>    zoom_image_size (Images, Images, ImageWidth, ImageHeight, 'constant')</l>
<l>endif</l>
<l>if (ContrastNormalization == 'true')</l>
<c>    * Scale the gray values to [0-255]. </c>
<c>    * Note that this converts the image to 'byte'.</c>
<l>    scale_image_max (Images, Images)</l>
<l>elseif (ContrastNormalization != 'false')</l>
<l>    throw ('Unsupported parameter value for \'contrast_normalization\'')</l>
<l>endif</l>
<c>* Check the type of the input images.</c>
<c>* If the type is not 'byte', </c>
<c>* the gray value scaling does not work correctly.</c>
<l>get_image_type (Images, Type)</l>
<l>tuple_regexp_test (Type, 'byte|real', NumMatches)</l>
<l>count_obj (Images, NumImages)</l>
<l>if (NumMatches != NumImages)</l>
<l>    throw ('Please provide only images of type \'byte\' or \'real\'.')</l>
<l>endif</l>
<l>EqualByte := Type [==] 'byte'</l>
<l>if (max(EqualByte) == 1)</l>
<l>    if (min(EqualByte) == 0)</l>
<l>        throw (['Passing mixed type images is not supported.'])</l>
<l>    endif</l>
<c>    * Convert the image type from byte to real,</c>
<c>    * because the classifier expects 'real' images.</c>
<l>    convert_image_type (Images, Images, 'real')</l>
<c>    * Scale/Shift the gray values from [0-255] to the expected range.</c>
<l>    RescaleRange := (ImageRangeMax - ImageRangeMin ) / 255.0</l>
<l>    scale_image (Images, Images, RescaleRange, ImageRangeMin)</l>
<l>else</l>
<c>    * For real images it is assumed that the range is already correct</c>
<l>endif</l>
<c></c>
<c>* Check the number of channels.</c>
<l>count_obj (Images, NumImages)</l>
<l>for ImageIndex := 1 to NumImages by 1</l>
<l>    select_obj (Images, ObjectSelected, ImageIndex)</l>
<l>    count_channels (ObjectSelected, NumChannels)</l>
<l>    if (NumChannels != ImageNumChannels)</l>
<l>        if (NumChannels == 1 and ImageNumChannels == 3)</l>
<c>            * If the image is a grayscale image, </c>
<c>            * convert it to an image with three channels.</c>
<l>            compose3(ObjectSelected, ObjectSelected, ObjectSelected, ThreeChannelImage)</l>
<l>            replace_obj (Images, ThreeChannelImage, Images, ImageIndex)</l>
<l>        else</l>
<l>            throw ('Number of channels not supported. Please provide a grayscale or an RGB image.')</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>ImagesPreprocessed := Images</l>
<l>return ()</l>
</body>
<docu id="preprocess_dl_classifier_images">
<abstract lang="de_DE">Diese Prozedur verarbeitet die in Image übergebenen Bilder so vor, dass sie mit train_dl_classifier_batch und apply_dl_classifier_batch verarbeitet werden können. Dabei ist zu beachten, dass je nach Bilder weitere Vorverarbeitungsschritte notwendig sein können. Wenn zusätzliche Vorverarbeitungsschritte implementiert werden, können auch neue generische Parameter hinzugefügt werden, die mit GenParamName and GenParamValue übergeben werden. Die vorverarbeiteten Bilder werden in ImagePreprocessed zurückgegeben. Die Anforderungen des Netzwerkes an die Bilder werden aus DLClassifierHandle ausgelesen. 

Das Neuronale Netzwerk hat bestimmte Anforderungen an die Bilder. In dieser Prozedur werden entsprechend die Bildbreite und -höhe und der Grauwertbereich der Bilder angepasst. Es ist zu beachten, dass alle Eingabebilder vom Typ 'byte' sein müssen, um zu garantieren, dass die Grauwerte im Intervall [0, 255] sind, damit die Skalierung des Grauwertbereichs richtig funktioniert. Wenn der generische Parameter 'contrast_normalization' auf 'true' gesetzt wird, können hingegen auch Bilder, die nicht den Typ 'byte' haben, benutzt werden. Zusätzlich wird in der Prozedur die Anzahl der Kanäle überprüft und gegebenenfalls angepasst. Außerdem wird der Typ der Ausgabebilder auf 'real' geändert.

Es ist notwendig, dass alle Bilder, die mit train_dl_classifier_batch und apply_dl_classifier_batch verarbeitet werden, so vorliegen, wie sie von dieser Prozedur zurückgegeben werden. Für das Training können dafür zum Beispiel vor dem Training alle Bilder mit dieser Prozedur vorverarbeitet und abgespeichert werden, oder aber die Bilder jedes Batches werden während dem Training einzeln vorverarbeitet. 

Die folgenden generischen Parameter werden unterstützt:

  * 'domain_handling': Standardmäßig ist dieser Parameter auf 'full_domain' gesetzt. Mit dieser Einstellung werden reduzierte Domänen der Eingabebilder ignoriert und die kompletten Bilder werden verarbeitet. Wenn der Parameter auf 'crop_domain' gesetzt wird, werden die Domänen, die vorher zum Beispiel mit reduce_domain spezifiziert wurden, dazu genutzt, um das Bild auszuschneiden. 

  * 'contrast_normalization': Abhängig von den Bildern kann es für die Klassifikation von Vorteil sein, eine Kontrastnormalisierung durchzuführen, z.B. für OCR. Wenn 'contrast_normalization' auf 'true' gesetzt wird, werden die Grauwerte jedes Bildes auf den maximalen Bereich skaliert. Bei dieser Skalierung wird außerdem der Typ der Bilder vorübergehend auf 'byte' geändert. Damit ist es möglich, auch Eingabebilder, die nicht als 'byte'-Bild vorliegen, vorzuverarbeiten. Der Standardwert ist 'false'. 

Es wird empfohlen, die Ausgabebilder dieser Prozedur zu analysieren, ob sie für ein erfolgreiches Training des Klassifikators erfolgversprechend sind. Wenn zum Beispiel nach der Größenanpassung der Bilder die zu erkennenden Defekte nicht mehr erkennbar sind, muss ein besserer Bildausschnitt gewählt werden, in dem die Defekte besser erkennbar sind.

</abstract>
<abstract lang="en_US">This procedure preprocesses the provided images given by Images so that they can be handled by train_dl_classifier_batch and apply_dl_classifier_batch. Note that depending on the data set, additional preprocessing steps might be beneficial. The preprocessed images are returned in ImagePreprocessed. The network's image requirements are provided by the DLClassifierHandle.

The deep-learning-based classifier has certain requirements on the images. In this procedure, the width, height and gray value range of each image is adapted accordingly. 

It is required that all images passed to train_dl_classifier_batch and apply_dl_classifier_batch are provided as returned by this procedure. For the training, for example, you can do this step at the beginning of your program for all images, or alternatively for each batch that is trained separately. 

The following values for GenParamName are available:

  * 'domain_handling': By default, it is set to 'full_domain'. Thus, reduced domains of images are ignored and the complete image is preprocessed. You can set it to 'crop_domain' to use the domains that were specified before with, for example, reduce_domain, to crop the images. 

  * 'contrast_normalization': Depending on the images, it can be beneficial for the deep classification to apply a contrast normalization. If 'contrast_normalization' is set to 'true', the gray values of every image are scaled to the maximum value range. During this scaling, the image is converted temporarily to a 'byte' image. Therefore, it is possible to input non-'byte' images as well if this parameter is set to 'true'. The default is 'false'. 

It is recommended to check the output images of this procedure to verify that they are suitable for a successful training of a classifier. For example, if after zooming defects on the images are no longer discernible, you have to choose a better image segment, where the defects are more prominent in the image.

</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Klassifikation</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="de_DE">Vorverarbeiten der Bilder für Training und Inferenz der Deep Learning Klassifikation.</short>
<short lang="en_US">Preprocess images for deep-learning-based classification training and inference.</short>
<parameters>
<parameter id="DLClassifierHandle">
<default_type>integer</default_type>
<description lang="de_DE">Handle des Deep Learning-basierten Klassifikators.</description>
<description lang="en_US">Handle of the deep-learning-based classifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>dl_classifier</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="de_DE">Name des generischen Parameters.</description>
<description lang="en_US">Name of the generic parameter.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.name</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'contrast_normalization'</item>
<item>'domain_handling'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="de_DE">Wert des generischen Parameters.</description>
<description lang="en_US">Value of the generic parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'true'</item>
<item>'false'</item>
<item>'full_domain'</item>
<item>'crop_domain'</item>
</values>
</parameter>
<parameter id="Images">
<description lang="de_DE">Bilder, die vorverarbeitet werden.</description>
<description lang="en_US">Images that are preprocessed.</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="ImagesPreprocessed">
<description lang="de_DE">Vorverarbeitete Bilder.</description>
<description lang="en_US">Preprocessed images.</description>
<multichannel>true</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="project_point_on_trackball" access="local">
<interface>
<ic>
<par name="X" base_type="ctrl" dimension="0"/>
<par name="Y" base_type="ctrl" dimension="0"/>
<par name="VirtualTrackball" base_type="ctrl" dimension="0"/>
<par name="TrackballSize" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="V" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>if (VirtualTrackball == 'shoemake')</l>
<c>    * Virtual Trackball according to Shoemake</c>
<l>    R := sqrt(X * X + Y * Y)</l>
<l>    if (R &lt;= TrackballSize)</l>
<l>        XP := X</l>
<l>        YP := Y</l>
<l>        ZP := sqrt(TrackballSize * TrackballSize - R * R)</l>
<l>    else</l>
<l>        XP := X * TrackballSize / R</l>
<l>        YP := Y * TrackballSize / R</l>
<l>        ZP := 0</l>
<l>    endif</l>
<l>else</l>
<c>    * Virtual Trackball according to Bell</c>
<l>    R := sqrt(X * X + Y * Y)</l>
<l>    if (R &lt;= TrackballSize * 0.70710678)</l>
<l>        XP := X</l>
<l>        YP := Y</l>
<l>        ZP := sqrt(TrackballSize * TrackballSize - R * R)</l>
<l>    else</l>
<l>        XP := X</l>
<l>        YP := Y</l>
<l>        ZP := 0.6 * TrackballSize * TrackballSize / R</l>
<l>    endif</l>
<l>endif</l>
<l>V := [XP,YP,ZP]</l>
<l>return ()</l>
</body>
<docu id="project_point_on_trackball">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Project an image point onto the trackball</short>
<parameters>
<parameter id="TrackballSize"/>
<parameter id="V"/>
<parameter id="VirtualTrackball"/>
<parameter id="X"/>
<parameter id="Y"/>
</parameters>
</docu>
</procedure>
<procedure name="query_feature_group_names">
<interface>
<oc>
<par name="GroupNames" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Return all available feature groups</c>
<c>* </c>
<l>gen_dummy_objects (Region, Image)</l>
<l>get_features (Region, Image, '', 'get_groups', GroupNames)</l>
<l>GroupNames := uniq(sort(GroupNames))</l>
<l>GroupNames := [GroupNames,'all']</l>
<l>return ()</l>
</body>
<docu id="query_feature_group_names">
<abstract lang="en_US">List all available feature group names.

For more information about the usage of the get_feature_set library, see documentation of calculate_features.</abstract>
<alternatives>
<item>query_feature_names_by_group</item>
</alternatives>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>classification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>calculate_features</item>
<item>get_custom_features</item>
</see_also>
<short lang="en_US">List all available feature group names.</short>
<successor>
<item>get_feature_names</item>
</successor>
<parameters>
<parameter id="GroupNames">
<default_type>string</default_type>
<description lang="en_US">All available feature group names.</description>
<mixed_type>false</mixed_type>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="query_feature_names_by_group">
<interface>
<ic>
<par name="GroupNames" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="FeatureNames" base_type="ctrl" dimension="0"/>
<par name="Groups" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Return a table (consisting of two tuples)</c>
<c>* of all features and the groups they belong to.</c>
<c>* </c>
<l>FeatureNames := []</l>
<l>Groups := []</l>
<l>gen_dummy_objects (Region, Image)</l>
<l>for I := 0 to |GroupNames| - 1 by 1</l>
<l>    get_features (Region, Image, GroupNames[I], 'get_names', Names)</l>
<l>    FeatureNames := [FeatureNames,Names]</l>
<l>    Groups := [Groups,gen_tuple_const(|Names|,GroupNames[I])]</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="query_feature_names_by_group">
<abstract lang="en_US">query_feature_names_by_group returns the tuple FeatureNames, which contains a list of feature names that belong to the feature groups given in GroupNames, and the tuple Groups which contains the respective group names.
I.e., for any given index I, the feature FeatureNames[I] belongs to the group Groups[I].

Note, that groups normally consist of multiple features, and features may belong to multiple groups. Therfore feature names and group names will occur multiple times.
The feature names are sorted by groups, i.e., the resulting tuples may look like this, where 'name1' and 'name3' belong to the groups 1 and 2, and 'name2' only belongs to "GROUP1'.

FeatureNames == ['name1','name2','name3','name1','name3']
Groups == ['GROUP1','GROUP1','GROUP1','GROUP2','GROUP2']

For more information about the usage of the get_feature_set library, see documentation of calculate_features.

</abstract>
<alternatives>
<item>query_feature_group_names</item>
</alternatives>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>calssification</item>
<item>features</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>get_feature_names</item>
<item>calculate_features</item>
<item>get_custom_features</item>
</see_also>
<short lang="en_US">Returns a table of feature names sorted by groups.</short>
<successor>
<item>get_feature_names</item>
</successor>
<parameters>
<parameter id="FeatureNames">
<default_type>string</default_type>
<description lang="en_US">Feature names.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="GroupNames">
<default_type>string</default_type>
<description lang="en_US">Feature group names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Groups">
<default_type>string</default_type>
<description lang="en_US">Group names corresponding to the features in FeatureNames.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="read_dl_classifier_data_set">
<interface>
<ic>
<par name="ImageDirectory" base_type="ctrl" dimension="0"/>
<par name="LabelSource" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="LabelIndices" base_type="ctrl" dimension="0"/>
<par name="UniqueClasses" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedures lists all ImageFiles </c>
<c>* located in ImageDirectory and its subdirectories, </c>
<c>* and returns the label of each image in GroundTruthLabels. </c>
<c>* LabelSource determines how the ground truth labels are extracted. </c>
<c>* Additionally, indices are assigned to the labels,</c>
<c>* which can be used for the training instead </c>
<c>* of the string labels, which is more time efficient.</c>
<c>* The order of indices corresponds with the returned </c>
<c>* unique Classes.</c>
<c>*</c>
<c>* Check the parameter ImageDirectory.</c>
<l>if (not is_string(ImageDirectory))</l>
<l>    throw ('ImageDirectory ' + ImageDirectory + 'is not a string.')</l>
<l>endif</l>
<c>*</c>
<c>* List all images in the provided directory </c>
<c>* and its subdirectories ('recursive').</c>
<l>list_image_files (ImageDirectory, ['hobj', 'ima', 'bmp', 'jpg', 'png', 'tiff', 'tif', 'gif', 'jpeg', 'pcx', 'pgm', 'ppm', 'pbm', 'xwd', 'pnm'], ['recursive', 'follow_links'], ImageFiles)</l>
<l>if (|ImageFiles| == 0)</l>
<l>    throw (['Error: Could not find any image files in folder: "'+ImageDirectory+'"'])</l>
<l>endif</l>
<c>*</c>
<c>* Get the ground truth labels.</c>
<c>* Note that when configuring your own LabelSource mode,</c>
<c>* you might find the procedure parse_filename helpful.</c>
<l>if (LabelSource == 'last_folder')</l>
<c>    * The last folder name containing the image</c>
<c>    * is used as label.</c>
<l>    tuple_regexp_match (ImageFiles, '.*/([^/]+)/[^/]*$', GroundTruthLabels)</l>
<l>elseif (LabelSource == 'file_name')</l>
<c>    * The file name of each image is used as label.</c>
<l>    tuple_regexp_match (ImageFiles, '.*/([^/]+)[.][^/]*$', GroundTruthLabels)</l>
<l>elseif (LabelSource == 'file_name_remove_index')</l>
<c>    * The file name of each image is used as label.</c>
<c>    * All consecutive digits and underscores </c>
<c>    * at the end of the file name are removed. </c>
<l>    tuple_regexp_match (ImageFiles, '.*/([^/]+)[.][^/]*$', LabelsTmp)</l>
<l>    tuple_regexp_replace (LabelsTmp, '[0-9_]*$', '', GroundTruthLabels)</l>
<l>elseif (LabelSource == [])</l>
<l>    GroundTruthLabels := []</l>
<l>else</l>
<l>    throw ('LabelSource not supported.')</l>
<l>endif</l>
<c>* Get the unique elements of Labels, </c>
<c>* which represent the classes.</c>
<l>UniqueClasses := uniq(sort(GroundTruthLabels))</l>
<c>* Assign indices to the labels.</c>
<l>LabelIndices := GroundTruthLabels</l>
<l>for ClassIndex := 0 to |UniqueClasses|-1 by 1</l>
<l>    LabelIndices[find(LabelIndices, UniqueClasses[ClassIndex])] := ClassIndex</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="read_dl_classifier_data_set">
<abstract lang="de_DE">read_dl_classifier_data_set listet alle Bilder, die in ImageDirectory und dessen Unterordnern liegen, in ImageFiles auf. Zusätzlich wird zu jedem Bild ein Label in GroundTruthLabels zurückgegeben. LabelSource legt fest, wie die GroundTruthLabels extrahiert werden. Außerdem werden den Labels Indizes zugewiesen, und das Resultat in LabelIndices zurückgegeben. Diese Indizes können statt der 'String'-Labels für das Training verwendet werden, was zeiteffizienter ist. Die Reihenfolge der Indizes entspricht der Reihenfolge der einmaligen Klassen, die ebenso zurückgegeben werden. 

Die Bilder werden mit der Prozedur list_image_files eingelesen. Dabei ist zu beachten, dass auch Unterordner und Verknüpfungen durchsucht werden. Mehr Informationen zu dieser Prozedur, auch zu den standardmäßig benutzten Suchpfaden, können in ihrer Dokumentation nachgelesen werden.

Als LabelSource werden drei Modi unterstützt: Wenn 'last_folder' ausgewählt ist, wird jeweils der Name des letzten Ordners als Label interpretiert. Mit 'file_name' wird der jeweilige Name der Bilder als Label genutzt. Mit 'file_name_remove_index' werden zusätzlich alle aufeinanderfolgenden Ziffern und Unterstriche, die am Ende des Dateinamen stehen (z.B. '01', '_20180101'), entfernt. Falls Sie einen eigenen Modus für LabelSource hinzufügen wollen, könnte die Prozedur parse_filename hilfreich sein.
</abstract>
<abstract lang="en_US">read_dl_classifier_data_set lists all ImageFiles located in ImageDirectory and its subdirectories, and returns the ground truth label of each image in GroundTruthLabels. LabelSource determines how the GroundTruthLabels are extracted. Additionally, indices are assigned to the labels, and the result is returned in LabelIndices. These indices can be used for the training instead of the string labels, which is more time efficient. The order of indices corresponds with the returned UniqueClasses.

The images are listed using the procedure list_image_files. Note that subfolders and links are included as well. For more information on the used default directories, please have a look at its documentation.

For LabelSource, three modes are supported: For 'last_folder', the last folder name containing the image is used as label. For 'file_name', the file name of each image is used as label. For 'file_name_remove_index', all consecutive digits and underscores at the end of the file name (e.g., '01', '_20180101') are removed. If you want to configure your own LabelSource mode, you might find the procedure parse_filename helpful.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Klassifikation</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="de_DE">Lesen des Datensatzes, der die Bilder und ihre vom Benutzer vergebenen Labels enthält.</short>
<short lang="en_US">Read the data set containing the images and their respective ground truth labels. </short>
<parameters>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="de_DE">Die vom Benutzer vergebenen Labels der Bilder.</description>
<description lang="en_US">Ground truth labels of the images.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageDirectory">
<default_type>string</default_type>
<description lang="de_DE">Das Bildverzeichnis.</description>
<description lang="en_US">The image directory.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="de_DE">Tuple mit den Bildpfaden.</description>
<description lang="en_US">Tuple of the image paths. </description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="LabelIndices">
<default_type>integer</default_type>
<description lang="de_DE">Die Labels, repräsentiert durch Indizes.</description>
<description lang="en_US">The labels represented by indices.</description>
<multivalue>optional</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="LabelSource">
<default_type>string</default_type>
<default_value>'last_folder'</default_value>
<description lang="de_DE">Der Modus, wie die vom Benutzer vergebenen Labels extrahiert werden.</description>
<description lang="en_US">The mode how the ground truth labels are extracted.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'last_folder'</item>
<item>'file_name'</item>
<item>'file_name_remove_index'</item>
</values>
</parameter>
<parameter id="UniqueClasses">
<default_type>string</default_type>
<description lang="de_DE">Die einmaligen Klassen.</description>
<description lang="en_US">The unique classes.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="read_message_obj">
<interface>
<oo>
<par name="ObjectData" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="MessageHandle" base_type="ctrl" dimension="0"/>
<par name="Key" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>try</l>
<l>    get_message_obj (ObjectData, MessageHandle, Key)</l>
<l>catch (Exception)</l>
<l>    throw ('The key ' + Key + ' is missing from the message ' + MessageHandle)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="read_message_obj">
<chapters lang="en_US">
<item>System</item>
<item>Multithreading</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Key"/>
<parameter id="MessageHandle"/>
<parameter id="ObjectData"/>
</parameters>
</docu>
</procedure>
<procedure name="read_message_tuple">
<interface>
<ic>
<par name="MessageHandle" base_type="ctrl" dimension="0"/>
<par name="Key" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TupleData" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>try</l>
<l>    get_message_tuple (MessageHandle, Key, TupleData)</l>
<l>catch (Exception)</l>
<l>    throw ('The key ' + Key + ' is missing from the message ' + MessageHandle)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="read_message_tuple">
<chapters lang="en_US">
<item>System</item>
<item>Multithreading</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<parameters>
<parameter id="Key">
<default_type>string</default_type>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="MessageHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="TupleData">
<default_type>string</default_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="rectify_image_and_compute_matching_plane_moving_cam">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageRectified" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ToolInBasePose" base_type="ctrl" dimension="0"/>
<par name="HandEyeCalibData" base_type="ctrl" dimension="0"/>
<par name="Poses" base_type="ctrl" dimension="0"/>
<par name="RectificationData" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure finds the pose of the matching part on the plane</c>
<c>* in the camera coordinate system. Rectification is applied if it</c>
<c>* is set by the user.</c>
<c>*</c>
<l>read_message_tuple (HandEyeCalibData, 'CamParam', CamParam)</l>
<l>read_message_tuple (HandEyeCalibData, 'ToolInCamPose', ToolInCamPose)</l>
<l>read_message_tuple (RectificationData, 'RectifyImage', RectifyImage)</l>
<l>if (RectifyImage == 'only_rectify' or RectifyImage == 'align_and_rectify')</l>
<l>    read_message_tuple (RectificationData, 'ScaleRectification', ScaleRectification)</l>
<l>endif</l>
<l>read_message_tuple (Poses, 'MatchingPlaneInBasePose', MatchingPlaneInBasePose)</l>
<c>*</c>
<c>* Keep track of the pose type used by the robot.</c>
<l>get_pose_type (ToolInBasePose, OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<c>* Convert to default pose type.</c>
<l>convert_pose_type (ToolInBasePose, 'Rp+T', 'gba', 'point', ToolInBasePose)</l>
<l>convert_pose_type (ToolInCamPose, 'Rp+T', 'gba', 'point', ToolInCamPose)</l>
<l>convert_pose_type (MatchingPlaneInBasePose, 'Rp+T', 'gba', 'point', MatchingPlaneInBasePose)</l>
<c>*</c>
<l>pose_invert (ToolInBasePose, BaseInToolPose)</l>
<l>pose_compose (ToolInCamPose, BaseInToolPose, BaseInCamPose)</l>
<l>pose_compose (BaseInCamPose, MatchingPlaneInBasePose, MatchingPlaneInCamPose)</l>
<c>*</c>
<l>if (RectifyImage == 'no_rectification')</l>
<l>    MatchingPlaneRectifiedPartInCamPose := MatchingPlaneInCamPose</l>
<l>    copy_obj (Image, ImageRectified, 1, 1)</l>
<l>elseif (RectifyImage = 'only_rectify' or RectifyImage = 'align_and_rectify')</l>
<l>    if (RectifyImage = 'only_rectify')</l>
<l>        MatchingPlaneInCamPose[5] := 0.0</l>
<l>    endif</l>
<c>    * The image dimensions should cover the entire original</c>
<c>    * field of view in the current rectification. Look at the</c>
<c>    * border of the current image in the world plane.</c>
<l>    get_cam_par_data (CamParam, 'image_width', Width)</l>
<l>    get_cam_par_data (CamParam, 'image_height', Height)</l>
<l>    get_system ('clip_region', ClipRegion)</l>
<l>    set_system ('clip_region', 'false')</l>
<l>    gen_rectangle1 (ImageArea, 0, 0, Height - 1, Width - 1)</l>
<l>    boundary (ImageArea, RegionBorder, 'outer')</l>
<l>    set_system ('clip_region', ClipRegion)</l>
<l>    get_region_points (RegionBorder, BorderRows, BorderColumns)</l>
<l>    image_points_to_world_plane (CamParam, MatchingPlaneInCamPose, BorderRows, BorderColumns, 'm', BorderX, BorderY)</l>
<c>    * Adapt parameters.</c>
<l>    create_pose (min(BorderX), min(BorderY), 0, 0, 0, 0, 'Rp+T', 'gba', 'point', MatchingPlaneRectifiedPartInMatchingPlanePose)</l>
<l>    pose_compose (MatchingPlaneInCamPose, MatchingPlaneRectifiedPartInMatchingPlanePose, MatchingPlaneRectifiedPartInCamPose)   </l>
<l>    WidthRect := int((max(BorderX) - min(BorderX)) / ScaleRectification + 0.5)</l>
<l>    HeightRect := int((max(BorderY) - min(BorderY)) / ScaleRectification + 0.5)</l>
<c>    *</c>
<l>    image_to_world_plane (Image, ImageRectified, CamParam, MatchingPlaneRectifiedPartInCamPose, WidthRect, HeightRect, ScaleRectification, 'bilinear')</l>
<l>else</l>
<l>    throw ('Please set the parameter RectifyImage correctly')</l>
<l>endif</l>
<l>convert_pose_type (MatchingPlaneRectifiedPartInCamPose, OrderOfTransform, OrderOfRotation, ViewOfTransform, MatchingPlaneRectifiedPartInCamPose)</l>
<l>set_message_tuple (RectificationData, 'MatchingPlaneRectifiedPartInCamPose', MatchingPlaneRectifiedPartInCamPose)</l>
<l>return ()</l>
</body>
<docu id="rectify_image_and_compute_matching_plane_moving_cam">
<abstract lang="en_US">This procedure prepares the input image in the online phase of robot picking by applying rectification if set by the user. Moreover, the pose of the matching part of the plane in the camera coordinate system is computed.

The input parameter Image is the current image containing potentially the object to be picked. Additionally, the pose ToolInBasePose specifies the current pose of the robot. 

The input message HandEyeCalibData must contain the camera parameters CamParam and the pose ToolInCamPose. The input message RectificationData must contain the parameter RectifyImage, and, if RectifyImage is 'only_rectify' or 'align_and_rectify', the parameter ScaleRectification. The input message Poses must contain the pose MatchingPlaneInBasePose. 

The output parameter ImageRectified is the rectified image, if rectification is set. Additionally, the current MatchingPlaneRectifiedPartInCamPose is added to the message RectificationData.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Hand-Auge</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Hand-Eye</item>
</chapters>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>prepare_poses_and_rectification_data_moving_cam</item>
</predecessor>
<short lang="en_US">Prepare the input image for matching and compute the needed pose.</short>
<successor>
<item>obtain_3d_pose_of_match_moving_cam</item>
</successor>
<parameters>
<parameter id="HandEyeCalibData">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain: ToolInCamPose and CamParam.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Image">
<description lang="en_US">Input image of the object to be matched.</description>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="ImageRectified">
<description lang="en_US">Rectified Image.</description>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
</parameter>
<parameter id="Poses">
<default_type>integer</default_type>
<description lang="en_US">Message that should contain MatchingPlaneInBasePose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="RectificationData">
<default_type>integer</default_type>
<description lang="en_US">Message that contains MatchingPlaneRectifiedPartInCamPose.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>message</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ToolInBasePose">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Current pose of the robot.</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="remove_dir_recursively">
<interface>
<ic>
<par name="DirName" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Recursively delete all subdirectories.</c>
<l>list_files (DirName, 'directories', Dirs)</l>
<l>for I := 0 to |Dirs|-1 by 1</l>
<l>    remove_dir_recursively (Dirs[I])</l>
<l>endfor</l>
<c>* Delete all files.</c>
<l>list_files (DirName, 'files', Files)</l>
<l>for I := 0 to |Files|-1 by 1</l>
<l>    delete_file (Files[I])</l>
<l>endfor</l>
<c>* Remove empty directory.</c>
<l>remove_dir (DirName)</l>
<l>return ()</l>
</body>
<docu id="remove_dir_recursively">
<abstract lang="en_US">This procedure removes a directory recursively. I.e., different to remove_dir, remove_dir_recursively also deletes contained files and subdirectories. </abstract>
<chapters lang="en_US">
<item>File</item>
<item>Misc</item>
</chapters>
<keywords lang="en_US">
<item>remove directory</item>
<item>remove file</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>remove_dir</item>
<item>delete_file</item>
</see_also>
<short lang="en_US">This procedure removes a directory recursively.</short>
<parameters>
<parameter id="DirName">
<default_type>string</default_type>
<description lang="en_US">Path to the folder which is removed recursively.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="scale_image_range">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageScaled" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Min" base_type="ctrl" dimension="0"/>
<par name="Max" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Convenience procedure to scale the gray values of the</c>
<c>* input image Image from the interval [Min,Max]</c>
<c>* to the interval [0,255] (default).</c>
<c>* Gray values &lt; 0 or &gt; 255 (after scaling) are clipped.</c>
<c>* </c>
<c>* If the image shall be scaled to an interval different from [0,255],</c>
<c>* this can be achieved by passing tuples with 2 values [From, To]</c>
<c>* as Min and Max.</c>
<c>* Example:</c>
<c>* scale_image_range(Image:ImageScaled:[100,50],[200,250])</c>
<c>* maps the gray values of Image from the interval [100,200] to [50,250].</c>
<c>* All other gray values will be clipped.</c>
<c>* </c>
<c>* input parameters:</c>
<c>* Image: the input image</c>
<c>* Min: the minimum gray value which will be mapped to 0</c>
<c>*      If a tuple with two values is given, the first value will</c>
<c>*      be mapped to the second value.</c>
<c>* Max: The maximum gray value which will be mapped to 255</c>
<c>*      If a tuple with two values is given, the first value will</c>
<c>*      be mapped to the second value.</c>
<c>* </c>
<c>* Output parameter:</c>
<c>* ImageScale: the resulting scaled image.</c>
<c>* </c>
<l>if (|Min| == 2)</l>
<l>    LowerLimit := Min[1]</l>
<l>    Min := Min[0]</l>
<l>else</l>
<l>    LowerLimit := 0.0</l>
<l>endif</l>
<l>if (|Max| == 2)</l>
<l>    UpperLimit := Max[1]</l>
<l>    Max := Max[0]</l>
<l>else</l>
<l>    UpperLimit := 255.0</l>
<l>endif</l>
<c>* </c>
<c>* Calculate scaling parameters.</c>
<l>Mult := real(UpperLimit - LowerLimit) / (Max - Min)</l>
<l>Add := -Mult * Min + LowerLimit</l>
<c>* </c>
<c>* Scale image.</c>
<l>scale_image (Image, Image, Mult, Add)</l>
<c>* </c>
<c>* Clip gray values if necessary.</c>
<c>* This must be done for each image and channel separately.</c>
<l>gen_empty_obj (ImageScaled)</l>
<l>count_obj (Image, NumImages)</l>
<l>for ImageIndex := 1 to NumImages by 1</l>
<l>    select_obj (Image, ImageSelected, ImageIndex)</l>
<l>    count_channels (ImageSelected, Channels)</l>
<l>    for ChannelIndex := 1 to Channels by 1</l>
<l>        access_channel (ImageSelected, SelectedChannel, ChannelIndex)</l>
<l>        min_max_gray (SelectedChannel, SelectedChannel, 0, MinGray, MaxGray, Range)</l>
<l>        threshold (SelectedChannel, LowerRegion, min([MinGray,LowerLimit]), LowerLimit)</l>
<l>        threshold (SelectedChannel, UpperRegion, UpperLimit, max([UpperLimit,MaxGray]))</l>
<l>        paint_region (LowerRegion, SelectedChannel, SelectedChannel, LowerLimit, 'fill')</l>
<l>        paint_region (UpperRegion, SelectedChannel, SelectedChannel, UpperLimit, 'fill')</l>
<l>        if (ChannelIndex == 1)</l>
<l>            copy_obj (SelectedChannel, ImageSelectedScaled, 1, 1)</l>
<l>        else</l>
<l>            append_channel (ImageSelectedScaled, SelectedChannel, ImageSelectedScaled)</l>
<l>        endif</l>
<l>    endfor</l>
<l>    concat_obj (ImageScaled, ImageSelectedScaled, ImageScaled)</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="scale_image_range">
<abstract lang="en_US">Convenience procedure to scale the gray values of the input image Image from the interval [Min,Max] to the interval [0,255] (default).
Gray values &lt; 0 or &gt; 255 (after scaling) are clipped.
If the image shall be scaled to an interval different from [0,255], this can be achieved by passing tuples with 2 values [From, To] as Min and Max.
Example:
scale_image_range (Image, ImageScaled, [100,50], [200,250])
maps the gray values of Image from the interval [100,200] to [50,250].
All other gray values will be clipped.
</abstract>
<alternatives>
<item>scale_image</item>
<item>scale_image_max</item>
</alternatives>
<chapters>
<item>Filters</item>
<item>Arithmetic</item>
</chapters>
<chapters lang="de_DE">
<item>Filter</item>
<item>Arithmetik</item>
</chapters>
<chapters lang="en_US">
<item>Filters</item>
<item>Arithmetic</item>
</chapters>
<example lang="en_US">read_image (Image, 'fabrik')
scale_image_range (Image, ImageScaled, [100,50], [200,250])</example>
<keywords lang="de_DE">
<item>Grauwerte skalieren</item>
</keywords>
<keywords lang="en_US">
<item>scale gray values</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>scale_image</item>
<item>scale_image_max</item>
</see_also>
<short>Scale the gray values of an image from the interval [Min,Max] to [0,255]</short>
<short lang="de_DE">Scale the gray values of an image from the interval [Min,Max] to [0,255]</short>
<short lang="en_US">Scale the gray values of an image from the interval [Min,Max] to [0,255]</short>
<parameters>
<parameter id="Image">
<description lang="en_US">The input image to be scaled</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
</type_list>
</parameter>
<parameter id="ImageScaled">
<description lang="en_US">The scaled output image</description>
<multichannel>optional</multichannel>
<multivalue>optional</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>int1</item>
<item>int2</item>
<item>uint2</item>
<item>int4</item>
<item>int8</item>
<item>real</item>
<item>cyclic</item>
<item>direction</item>
<item>complex</item>
</type_list>
</parameter>
<parameter id="Max">
<default_type>integer</default_type>
<default_value>200</default_value>
<description lang="en_US">The maximum gray value which will be mapped to 255. If a tuple with two values is given, the first value will be mapped to the second value.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Min">
<default_type>integer</default_type>
<default_value>100</default_value>
<description lang="en_US">The minimum gray value which will be mapped to 0. If a tuple with two values is given, the first value will be mapped to the second value.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="select_mask_obj">
<interface>
<io>
<par name="Objects" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="SelectedObjects" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Mask" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* select_mask_obj selects one or more single elements of the object array</c>
<c>* Objects and returns them in SelectedObjects.</c>
<c>* The elements of Mask determine if the corresponding elements of Objects are selected.</c>
<c>* If the value is greater than 0, the corresponding element is selected.</c>
<c>* </c>
<c>* Check number of elements</c>
<l>count_obj (Objects, Number)</l>
<l>if (Number != |Mask|)</l>
<l>    throw ('Number of elements in Objects and Mask do not match.')</l>
<l>endif</l>
<c>* </c>
<c>* Check type of mask elements</c>
<l>AllNumbers := sum(is_real_elem(Mask)) + sum(is_int_elem(Mask)) == |Mask|</l>
<l>if (not AllNumbers and Mask != [])</l>
<l>    throw ('Invalid type: Elements of Mask must be integer or real numbers.')</l>
<l>endif</l>
<c>* </c>
<c>* Use select_mask for tuples to generate a list of object indices.</c>
<l>Indices := select_mask([1:|Mask|],Mask)</l>
<l>select_obj (Objects, SelectedObjects, Indices)</l>
<l>return ()</l>
</body>
<docu id="select_mask_obj">
<abstract lang="en_US">select_mask_obj selects elements of the object array Objects based on the elements in Mask and returns them in SelectedObjects. For all elements of Mask that are greater than 0, the corresponding element of Objects is returned in SelectedObjects. Objects and Mask must have the same number of elements. Mask may only contain integer or float values.</abstract>
<alternatives>
<item>tuple_select_mask</item>
<item>select_obj</item>
<item>select_shape</item>
<item>select_shape_xld</item>
<item>select_contours_xld</item>
<item>select_region_point</item>
<item>select_xld_point</item>
</alternatives>
<chapters lang="de_DE">
<item>Objekt</item>
<item>Manipulation</item>
</chapters>
<chapters lang="en_US">
<item>Object</item>
<item>Manipulation</item>
</chapters>
<example lang="en_US">read_image (Image, 'tooth_rim')
edges_sub_pix (Image, Edges, 'canny', 1, 20, 40)
test_closed_xld (Edges, IsClosed)
* Select closed contours.
select_mask_obj (Edges, ClosedContours, IsClosed)
* Select open contours.
select_mask_obj (Edges, OpenContours, not IsClosed)
</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>test_closed_xld</item>
<item>test_equal_obj</item>
<item>test_equal_region</item>
<item>test_region_point</item>
<item>test_self_intersection_xld</item>
<item>test_subset_region</item>
<item>test_xld_point</item>
<item>tuple_greater_elem</item>
<item>tuple_greater_equal_elem</item>
<item>tuple_equal_elem</item>
<item>tuple_is_int_elem</item>
<item>tuple_is_real_elem</item>
<item>tuple_is_string_elem</item>
<item>tuple_less_elem</item>
<item>tuple_less_equal_elem</item>
<item>tuple_not_equal_elem</item>
</predecessor>
<short lang="en_US">Select elements from object arrays using a mask.</short>
<parameters>
<parameter id="Mask">
<default_type>integer</default_type>
<description lang="en_US">&gt; 0 specifies the elements to select.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Objects">
<description lang="en_US">Input object array.</description>
<multivalue>optional</multivalue>
<sem_type>object</sem_type>
</parameter>
<parameter id="SelectedObjects">
<description lang="en_US">Selected objects.</description>
<multivalue>optional</multivalue>
<sem_type>object</sem_type>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="select_percentage_dl_classifier_data">
<interface>
<ic>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="SelectPercentage" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageFilesOut" base_type="ctrl" dimension="0"/>
<par name="LabelsOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure selects SelectPercentage percentages </c>
<c>* of the input data set ImageFiles and GroundTruthLabels and returns</c>
<c>* the result in ImageFilesOut and LabelsOut. </c>
<c>* The original ratio of class sizes is kept </c>
<c>* when applying this percentage.</c>
<c>*</c>
<c>* Check the input parameters.</c>
<l>if (|ImageFiles| &lt; 1)</l>
<l>    throw ('ImageFiles must not be empty.')</l>
<l>endif</l>
<l>if (|ImageFiles| != |GroundTruthLabels|)</l>
<l>    throw ('Please provide a label for every image.')</l>
<l>endif</l>
<l>if (SelectPercentage &lt; 0 or SelectPercentage &gt; 100)</l>
<l>    throw ('UsedPercentage must be between 0 and 100.')</l>
<l>endif</l>
<l>UniqueClasses := uniq(sort(GroundTruthLabels))</l>
<c>* </c>
<c>* Select the user-defined percentage of every class.</c>
<l>if (SelectPercentage == 100)</l>
<l>    ImageFilesOut := ImageFiles</l>
<l>    LabelsOut := GroundTruthLabels</l>
<l>else</l>
<l>    Ratio := SelectPercentage * 0.01</l>
<l>    ImageFilesOut := []</l>
<l>    LabelsOut := []</l>
<l>    for ClassIndex := 0 to |UniqueClasses|-1 by 1</l>
<c>        * For each class, find the images with this label.</c>
<l>        Label := UniqueClasses[ClassIndex]</l>
<l>        LabelIndices := find(GroundTruthLabels, Label)</l>
<l>        ImageFilesLabel := ImageFiles[LabelIndices]</l>
<c>        * Shuffle the images with this label.</c>
<l>        tuple_shuffle (ImageFilesLabel, ImageFilesLabel)</l>
<c>        * Select images from the class according to the given percentage.</c>
<l>        IndexEnd := max2(0,int(floor(|ImageFilesLabel|* Ratio))-1)</l>
<l>        ImageFilesOut := [ImageFilesOut, ImageFilesLabel[0:IndexEnd]]</l>
<l>        LabelsOut := [LabelsOut, gen_tuple_const (IndexEnd+1, Label)]</l>
<l>    endfor</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="select_percentage_dl_classifier_data">
<abstract lang="de_DE">Diese Prozedur wählt den Prozentsatz SelectPercentage des Eingabe-Datensatzes ImageFiles und GroundTruthLabels (vom Benutzer vergebene Label der Bilder) aus und gibt das Ergebnis in ImageFilesOut und LabelsOut zurück.

Diese Prozedur kann zum Beispiel benutzt werden, um die Menge an Daten zu reduzieren, bevor die Prozeduren apply_dl_classifier_batchwise und evaluate_dl_classifier angewendet werden. Dadurch kann die Laufzeit reduziert werden.

UsedPercentage gibt an, wie viel Prozent der gegebenen Daten für die Evaluation verwendet werden sollen. Entsprechend muss UsedPercentage zwischen 0 und 100 liegen. Das ursprüngliche Verhältnis der Klassengrößen wird möglichst beibehalten, wenn die Datenmenge entsprechend UsedPercentage angepasst wird. Die tatsächlich erreichte Prozentzahl kann jedoch abweichen, je nach Anzahl Bilder und Anzahl Bilder pro Klasse.</abstract>
<abstract lang="en_US">This procedure selects SelectPercentage percentages of the input data set ImageFiles and GroundTruthLabels and returns the result in ImageFilesOut and LabelsOut. 

This procedure can for example be used to reduce the amount of data before applying the procedure apply_dl_classifier_batchwise and evaluate_dl_classifier. Thus, the run-time can be reduced.

UsedPercentage specifies how much of the input data is used for the evaluation, in percent. Therefore, it must be between 0 and 100. The original ratio of class sizes is preferably kept when applying this percentage. The actual percentage that is achieved can differ depending on the number of images and the number of images per class.
</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Klassifikation</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="de_DE">Select a percentage of the given data.</short>
<short lang="en_US">Select a percentage of the given data.</short>
<parameters>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="de_DE">Die vom Benutzer vergebenen Labels der Bilder.</description>
<description lang="en_US">Ground truth labels of the images.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="de_DE">Tuple mit den Bildpfaden.</description>
<description lang="en_US">Tuple of the image paths.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFilesOut">
<default_type>string</default_type>
<description lang="de_DE">Die ausgewählten Bildpfade.</description>
<description lang="en_US">The selected image file paths.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="LabelsOut">
<default_type>string</default_type>
<description lang="de_DE">Die vom Benutzer vergebenen Labels, die zu den Bildern in ImageFilesOut gehören.</description>
<description lang="en_US">The ground truth labels corresponding to the images in ImageFilesOut.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="SelectPercentage">
<default_type>integer</default_type>
<description lang="de_DE">Prozentsatz an Daten, die ausgewählt werden sollen.</description>
<description lang="en_US">Percentage of the given data that should be selected.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>100</value_max>
<value_min>0</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="set_cam_par_data">
<interface>
<ic>
<par name="CameraParamIn" base_type="ctrl" dimension="0"/>
<par name="ParamName" base_type="ctrl" dimension="0"/>
<par name="ParamValue" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraParamOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* set_cam_par_data sets the value of the parameter that</c>
<c>* is given in ParamName in the tuple of camera parameters</c>
<c>* given in CameraParamIn. The modified camera parameters</c>
<c>* are returned in CameraParamOut.</c>
<c>* </c>
<c>* Check for consistent length of input parameters</c>
<l>if (|ParamName| != |ParamValue|)</l>
<l>    throw ('Different number of values in ParamName and ParamValue')</l>
<l>endif</l>
<c>* First, get the parameter names that correspond to the</c>
<c>* elements in the input camera parameter tuple.</c>
<l>get_cam_par_names (CameraParamIn, CameraType, CameraParamNames)</l>
<c>* </c>
<c>* Find the index of the requested camera data and return</c>
<c>* the corresponding value.</c>
<l>CameraParamOut := CameraParamIn</l>
<l>for Index := 0 to |ParamName| - 1 by 1</l>
<l>    ParamNameInd := ParamName[Index]</l>
<l>    I := find(CameraParamNames,ParamNameInd)</l>
<l>    if (I != -1)</l>
<l>        CameraParamOut[I] := ParamValue[Index]</l>
<l>    else</l>
<l>        throw ('Wrong ParamName ' + ParamNameInd)</l>
<l>    endif</l>
<c>    * Check the consistency of focus and telecentricity</c>
<l>    if (ParamNameInd == 'focus')</l>
<l>        IsTelecentric := strstr(CameraType,'telecentric') != -1 and strstr(CameraType,'image_side_telecentric') == -1</l>
<l>        if (IsTelecentric)</l>
<l>            throw ('Focus for telecentric lenses is always 0, and hence, cannot be changed.')</l>
<l>        endif</l>
<l>        if (not IsTelecentric and ParamValue[Index] == 0.0)</l>
<l>            throw ('Focus for non-telecentric lenses must not be 0.')</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="set_cam_par_data">
<abstract lang="en_US">set_cam_par_data sets the value of ParamName in the camera parameter tuple CameraParamIn. The modified camera parameters  are returned in CameraParamOut. The following parameter names can be set: 'focus', 'magnification', 'kappa', 'k1', 'k2', 'k3', 'p1', 'p2', 'image_plane_dist', 'tilt', 'rot', 'sx' ,'sy', 'cx', 'cy', 'vx', 'vy', 'vz', 'image_width', 'image_height'. If the camera type does not support the requested value, an exception is raised.</abstract>
<chapters lang="de_DE">
<item>Kalibrierung</item>
<item>Kameraparameter</item>
</chapters>
<chapters lang="en_US">
<item>Calibration</item>
<item>Camera Parameters</item>
</chapters>
<example lang="en_US">read_cam_par ('campar.dat', CameraParam)
get_cam_par_data (CameraParam, 'sx', Sx) 
get_cam_par_data (CameraParam, 'sy', Sy)
get_cam_par_data (CameraParam, 'cx', Cx) 
get_cam_par_data (CameraParam, 'cy', Cy) 
get_cam_par_data (CameraParam, 'image_width', ImageWidth) 
get_cam_par_data (CameraParam, 'image_height', ImageHeight)
*
set_cam_par_data (CameraParam, 'sx', 2.0*Sx, CameraParam)
set_cam_par_data (CameraParam, 'sy', 2.0*Sy, CameraParam)
set_cam_par_data (CameraParam, 'cx', 0.5*Cx, CameraParam)
set_cam_par_data (CameraParam, 'cy', 0.5*Cy, CameraParam)
set_cam_par_data (CameraParam, 'image_width', 0.5*ImageWidth, CameraParam)
set_cam_par_data (CameraParam, 'image_height', 0.5*ImageHeight, CameraParam)</example>
<keywords lang="de_DE">
<item>Kameraparameter kalibrieren</item>
<item>Kamera-Kalibrierparameter erhalten</item>
<item>Kameramodell</item>
<item>interne Kameraparameter</item>
<item>interne Kameraparameter kalibrieren</item>
<item>kalibrierte interne Kameraparameter erhalten</item>
</keywords>
<keywords lang="en_US">
<item>camera calibration parameters</item>
<item>camera calibration result</item>
<item>calibrate camera parameters</item>
<item>calibrate internal camera parameters</item>
<item>calibrated internal camera parameters</item>
</keywords>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_cam_par</item>
<item>deserialize_cam_par</item>
<item>get_calib_data</item>
<item>get_deformable_model_params</item>
<item>get_sheet_of_light_param</item>
<item>get_shape_model_3d_param</item>
</predecessor>
<see_also>
<item>calibrate_cameras</item>
<item>get_cam_par_data</item>
<item>get_cam_par_names</item>
<item>gen_cam_par_area_scan_division</item>
<item>gen_cam_par_area_scan_polynomial</item>
<item>gen_cam_par_area_scan_tilt_division</item>
<item>gen_cam_par_area_scan_tilt_polynomial</item>
<item>gen_cam_par_area_scan_telecentric_division</item>
<item>gen_cam_par_area_scan_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_bilateral_telecentric_polynomial</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_division</item>
<item>gen_cam_par_area_scan_tilt_object_side_telecentric_polynomial</item>
<item>gen_cam_par_line_scan</item>
</see_also>
<short lang="en_US">Set the value of a specified camera parameter in the camera parameter tuple.</short>
<parameters>
<parameter id="CameraParamIn">
<default_type>real</default_type>
<description lang="en_US">Input camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="CameraParamOut">
<default_type>real</default_type>
<description lang="en_US">Output camera parameter tuple.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>campar</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ParamName">
<default_type>string</default_type>
<default_value>'image_width'</default_value>
<description lang="en_US">Name of the camera parameter for that the value should be set.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'focus'</item>
<item>'magnification'</item>
<item>'kappa'</item>
<item>'k1'</item>
<item>'k2'</item>
<item>'k3'</item>
<item>'p1'</item>
<item>'p2'</item>
<item>'image_plane_dist'</item>
<item>'tilt'</item>
<item>'rot'</item>
<item>'sx'</item>
<item>'sy'</item>
<item>'cx'</item>
<item>'cy'</item>
<item>'image_width'</item>
<item>'image_height'</item>
<item>'vx'</item>
<item>'vy'</item>
<item>'vz'</item>
</value_list>
</parameter>
<parameter id="ParamValue">
<default_type>real</default_type>
<description lang="en_US">Value of the camera parameter.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="set_display_font">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="Size" base_type="ctrl" dimension="0"/>
<par name="Font" base_type="ctrl" dimension="0"/>
<par name="Bold" base_type="ctrl" dimension="0"/>
<par name="Slant" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* This procedure sets the text font of the current window with</c>
<c>* the specified attributes.</c>
<c>* </c>
<c>* Input parameters:</c>
<c>* WindowHandle: The graphics window for which the font will be set</c>
<c>* Size: The font size. If Size=-1, the default of 16 is used.</c>
<c>* Bold: If set to 'true', a bold font is used</c>
<c>* Slant: If set to 'true', a slanted font is used</c>
<c>* </c>
<l>get_system ('operating_system', OS)</l>
<l>dev_get_preferences ('suppress_handled_exceptions_dlg', PreferenceValue)</l>
<l>dev_set_preferences ('suppress_handled_exceptions_dlg', 'true')</l>
<l>if (Size == [] or Size == -1)</l>
<l>    Size := 16</l>
<l>endif</l>
<l>if (OS{0:2} == 'Win')</l>
<c>    * Restore previous behaviour</c>
<l>    Size := int(1.13677 * Size)</l>
<l>else</l>
<l>    Size := int(Size)</l>
<l>endif</l>
<l>if (Font == 'Courier')</l>
<l>    Fonts := ['Courier','Courier 10 Pitch','Courier New','CourierNew',\
              'Liberation Mono']</l>
<l>elseif (Font == 'mono')</l>
<l>    Fonts := ['Consolas','Menlo','Courier','Courier 10 Pitch','FreeMono',\
              'Liberation Mono']</l>
<l>elseif (Font == 'sans')</l>
<l>    Fonts := ['Luxi Sans','DejaVu Sans','FreeSans','Arial', 'Liberation Sans']</l>
<l>elseif (Font == 'serif')</l>
<l>    Fonts := ['Times New Roman','Luxi Serif','DejaVu Serif','FreeSerif',\
              'Utopia','Liberation Serif']</l>
<l>else</l>
<l>    Fonts := Font</l>
<l>endif</l>
<l>Style := ''</l>
<l>if (Bold == 'true')</l>
<l>    Style := Style + 'Bold'</l>
<l>elseif (Bold != 'false')</l>
<l>    Exception := 'Wrong value of control parameter Bold'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<l>if (Slant == 'true')</l>
<l>    Style := Style + 'Italic'</l>
<l>elseif (Slant != 'false')</l>
<l>    Exception := 'Wrong value of control parameter Slant'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<l>if (Style == '')</l>
<l>    Style := 'Normal'</l>
<l>endif</l>
<l>query_font (WindowHandle, AvailableFonts)</l>
<l>Font := ''</l>
<l>for Fdx := 0 to |Fonts| - 1 by 1</l>
<l>    Indices := find(AvailableFonts,Fonts[Fdx])</l>
<l>    if (|Indices| &gt; 0)</l>
<l>        if (Indices[0] &gt;= 0)</l>
<l>            Font := Fonts[Fdx]</l>
<l>            break</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<l>if (Font == '')</l>
<l>    throw ('Wrong value of control parameter Font')</l>
<l>endif</l>
<l>Font := Font + '-' + Style + '-' + Size</l>
<l>set_font (WindowHandle, Font)</l>
<l>dev_set_preferences ('suppress_handled_exceptions_dlg', PreferenceValue)</l>
<l>return ()</l>
</body>
<docu id="set_display_font">
<abstract lang="en_US">This procedure sets the text font of the current window with the specified attributes Size, Bold and Slant. 
As font, the font name or one of the strings 'mono', 'sans', 'serif' can be used.</abstract>
<alternatives>
<item>set_font</item>
</alternatives>
<attention lang="en_US">For 'mono', 'sans', and 'serif', it is assumed that at least one of the following fonts is installed on the system:
'mono': 'Consolas', 'Menlo', 'Courier', 'Courier 10 Pitch', 'FreeMono'
'sans': 'Luxi Sans', 'DejaVu Sans', 'FreeSans', 'Arial'
'serif': 'Times New Roman', 'Luxi Serif', 'DejaVu Serif', 'FreeSerif', 'Utopia'</attention>
<chapters>
<item>Graphics</item>
<item>Text</item>
</chapters>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Text</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Text</item>
</chapters>
<example lang="en_US">dev_open_window_fit_image(Image,0 , 0, 400, 400, WindowHandle)
set_display_font(WindowHandle, 16, 'mono', 'true', 'false')
disp_text (WindowHandle,'Hello World!', 'window', 10, 10, 'black', [], [])
</example>
<keywords lang="de_DE">
<item>Schriftart (Font) setzen</item>
</keywords>
<keywords lang="en_US">
<item>set font</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>dev_open_window</item>
<item>open_window</item>
<item>dev_open_window_fit_image</item>
<item>dev_open_window_fit_size</item>
</predecessor>
<see_also>
<item>set_font</item>
</see_also>
<short>Set font independent of OS</short>
<short lang="de_DE">Set font independent of OS</short>
<short lang="en_US">Set font independent of OS</short>
<successor>
<item>disp_text</item>
<item>disp_continue_message</item>
<item>set_tposition</item>
<item>write_string</item>
</successor>
<parameters>
<parameter id="Bold">
<default_type>string</default_type>
<default_value>'true'</default_value>
<description lang="en_US">If set to 'true', a bold font is used</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="Font">
<default_type>string</default_type>
<default_value>'mono'</default_value>
<description lang="en_US">The font name. Either 'mono', 'sans',  'serif' or a specific font name can be used. 'mono' will be mapped to 'Courier New' on Windows, to 'courier' on Linux, and to 'Menlo' on OS X. 'sans' will be mapped to 'Arial' on Windows and OS X, and to 'helvetica' on Linux. 'serif' will be mapped to 'Times New Roman' on Windows and OS X, and to 'times' on Linux.
</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'mono'</item>
<item>'sans'</item>
<item>'serif'</item>
</values>
</parameter>
<parameter id="Size">
<default_type>integer</default_type>
<default_value>16</default_value>
<description lang="en_US">The font size on Windows systems. If Size=-1, the default of 16 is used.
On Linux systems, ALL values are multiplied with 1.25 and then mapped to [11, 14, 17, 20, 25, 34].</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<values>
<item>[9, 11, 14, 16, 20, 27]</item>
</values>
</parameter>
<parameter id="Slant">
<default_type>string</default_type>
<default_value>'false'</default_value>
<description lang="en_US">If set to 'true', a slanted font is used</description>
<sem_type>attribute.value</sem_type>
<type_list>
<item>string</item>
</type_list>
<value_list>
<item>'true'</item>
<item>'false'</item>
</value_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">The window handle of the window, where the font will be set</description>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="sort_pairs">
<interface>
<ic>
<par name="T1" base_type="ctrl" dimension="0"/>
<par name="T2" base_type="ctrl" dimension="0"/>
<par name="SortMode" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Sorted1" base_type="ctrl" dimension="0"/>
<par name="Sorted2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Sort tuple pairs.</c>
<c>* </c>
<c>* input parameters:</c>
<c>* T1: first tuple</c>
<c>* T2: second tuple</c>
<c>* SortMode: if set to '1', sort by the first tuple,</c>
<c>*    if set to '2', sort by the second tuple</c>
<c>* </c>
<l>if (SortMode == '1' or SortMode == 1)</l>
<l>    tuple_sort_index (T1, Indices1)</l>
<l>    Sorted1 := subset(T1,Indices1)</l>
<l>    Sorted2 := subset(T2,Indices1)</l>
<l>elseif (SortMode == 'column' or SortMode == '2' or SortMode == 2)</l>
<l>    tuple_sort_index (T2, Indices2)</l>
<l>    Sorted1 := subset(T1,Indices2)</l>
<l>    Sorted2 := subset(T2,Indices2)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="sort_pairs">
<abstract lang="en_US">Sort tuple pairs.
This procedure first sorts one of the tuples (which one is specified by the parameter SortMode) in ascending order. The second tuple is then ordered such, that their position in the output tuple is the same as the new position of the value of the first tuple, which had the same index before sorting.
Example:
Tuple1 := [5,4,3,2,1]
Tuple2 := [105,204,303,402,501]
sort_pairs (Tuple1, Tuple2, '1', Sorted1, Sorted2)

returns:
Sorted1 := [1,2,3,4,5]
Sorted2 := [501,402,303,204,105]</abstract>
<alternatives>
<item>tuple_sort</item>
<item>tuple_sort_index</item>
</alternatives>
<attention lang="en_US">Both tuples must have the same length.
If the sorted tuple (T1, if SortMode='1' or T2, if SortMode='2') has more elements than the other, an error will occur. 
If the sorted tuple (T1, if SortMode='1' or T2, if SortMode='2') has less elements than the other, the output tuples will have as many elements as the shorter one of the input tuples.</attention>
<chapters>
<item>Tools</item>
<item>Geometry</item>
</chapters>
<chapters lang="de_DE">
<item>Tools</item>
<item>Geometrie</item>
</chapters>
<chapters lang="en_US">
<item>Tools</item>
<item>Geometry</item>
</chapters>
<example lang="en_US">Tuple1 := [5,4,3,2,1]
Tuple2 := [105,204,303,402,501]
sort_pairs (Tuple1, Tuple2, '1', Sorted1, Sorted2)</example>
<keywords lang="de_DE">
<item>Tupelpaare sortieren</item>
</keywords>
<keywords lang="en_US">
<item>sort tuple pairs</item>
</keywords>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<see_also>
<item>tuple_sort</item>
<item>tuple_sort_index</item>
</see_also>
<short>Sort tuple pairs.</short>
<short lang="de_DE">Sort tuple pairs.</short>
<short lang="en_US">Sort tuple pairs.</short>
<parameters>
<parameter id="SortMode">
<default_type>string</default_type>
<default_value>'1'</default_value>
<description lang="en_US">If set to '1', sort by the first tuple, if set to '2', sort by the second tuple.
</description>
<multivalue>false</multivalue>
<sem_type>attribute.value</sem_type>
<type_list>
<item>integer</item>
<item>string</item>
</type_list>
<values>
<item>'1'</item>
<item>'2'</item>
</values>
</parameter>
<parameter id="Sorted1">
<default_type>integer</default_type>
<description lang="en_US">The first sorted output tuple (corresponding to the input tuple T1)</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="Sorted2">
<default_type>integer</default_type>
<description lang="en_US">The second sorted output tuple (corresponding to the input tuple T2)</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="T1">
<default_type>integer</default_type>
<description lang="en_US">First input tuple of the pair, which shall be sorted.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="T2">
<default_type>integer</default_type>
<description lang="en_US">Second input tuple of the pair, which shall be sorted.</description>
<mixed_type>optional</mixed_type>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="split_dl_classifier_data_set">
<interface>
<ic>
<par name="ImageFiles" base_type="ctrl" dimension="0"/>
<par name="GroundTruthLabels" base_type="ctrl" dimension="0"/>
<par name="TrainingPercent" base_type="ctrl" dimension="0"/>
<par name="ValidationPercent" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="TrainingImages" base_type="ctrl" dimension="0"/>
<par name="TrainingLabels" base_type="ctrl" dimension="0"/>
<par name="ValidationImages" base_type="ctrl" dimension="0"/>
<par name="ValidationLabels" base_type="ctrl" dimension="0"/>
<par name="TestImages" base_type="ctrl" dimension="0"/>
<par name="TestLabels" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure divides the data set (images and ground truth labels)</c>
<c>* into three disjoint subsets: training, validation, and test. </c>
<c>* The number of images and labels in each subset is defined </c>
<c>* by the given percentages TrainingPercent and ValidationPercent. </c>
<c>* Each subset contains randomly distributed data, </c>
<c>* whereby the original ratio of class sizes is kept.</c>
<c>*</c>
<c>* Check the input parameters.</c>
<l>if (|ImageFiles| != |GroundTruthLabels|)</l>
<l>    throw ('Please provide a label for every image file.')</l>
<l>endif</l>
<l>if (TrainingPercent &lt; 0)</l>
<l>    throw ('TrainingPercent must not be smaller than zero.')</l>
<l>endif</l>
<l>if (ValidationPercent &lt; 0)</l>
<l>    throw ('ValidationPercent must not be smaller than zero.')</l>
<l>endif</l>
<l>if (|ImageFiles| &lt; 1)</l>
<l>    throw ('ImageFiles must not be empty.')</l>
<l>endif</l>
<l>if (TrainingPercent + ValidationPercent &gt; 100)</l>
<l>    throw ('The sum of TrainingPercent and ValidationPercent must not be greater than 100.')</l>
<l>endif</l>
<c>*</c>
<c>* Set classes and data ratios.</c>
<l>TrainingRatio := TrainingPercent * 0.01</l>
<l>ValidationRatio := ValidationPercent * 0.01</l>
<c>*</c>
<c>* Prepare output tuples.</c>
<l>TrainingImages := []</l>
<l>TrainingLabels := []</l>
<l>ValidationImages := []</l>
<l>ValidationLabels := []</l>
<l>TestImages := []</l>
<l>TestLabels := []</l>
<c>*</c>
<c>* Loop through all unique classes and add data</c>
<c>* according to the specified percentages. </c>
<l>UniqueClasses := uniq(sort(GroundTruthLabels))</l>
<l>for ClassIndex := 0 to |UniqueClasses|-1 by 1</l>
<c>    * Select all images and ground truth labels with the class.</c>
<l>    Class := UniqueClasses[ClassIndex]</l>
<l>    ClassIndices := find(GroundTruthLabels, Class)</l>
<l>    ImageFilesClass := ImageFiles[ClassIndices]</l>
<l>    LabelsClass := gen_tuple_const (|ImageFilesClass|, Class)</l>
<c>    * Shuffle the images in this class.</c>
<l>    tuple_shuffle (ImageFilesClass, ImageFilesClass)</l>
<c>    * Determine the boundaries of the respective selection.</c>
<l>    IndexTrainingEnd := int(floor(|ImageFilesClass|*TrainingRatio))-1</l>
<l>    IndexValidationEnd := int(floor(|ImageFilesClass|*(ValidationRatio+TrainingRatio)))-1</l>
<c>    * Add the respective images and labels.</c>
<l>    TrainingImages := [TrainingImages, ImageFilesClass[0:IndexTrainingEnd]]</l>
<l>    TrainingLabels := [TrainingLabels, LabelsClass[0:IndexTrainingEnd]]</l>
<l>    ValidationImages := [ValidationImages, ImageFilesClass[IndexTrainingEnd+1 : IndexValidationEnd]]</l>
<l>    ValidationLabels := [ValidationLabels, LabelsClass[IndexTrainingEnd+1 : IndexValidationEnd]]</l>
<l>    TestImages := [TestImages, ImageFilesClass[IndexValidationEnd+1 : |ImageFilesClass|-1]]</l>
<l>    TestLabels := [TestLabels, LabelsClass[IndexValidationEnd+1 : |ImageFilesClass|-1]]</l>
<l>endfor</l>
<c>*</c>
<c>* Shuffle the output.</c>
<l>tuple_shuffle ([0:|TrainingImages|-1], TrainingSequence)</l>
<l>TrainingImages := TrainingImages[TrainingSequence]</l>
<l>TrainingLabels := TrainingLabels[TrainingSequence]</l>
<l>tuple_shuffle ([0:|ValidationImages|-1], ValidationSequence)</l>
<l>ValidationImages := ValidationImages[ValidationSequence]</l>
<l>ValidationLabels := ValidationLabels[ValidationSequence]</l>
<l>tuple_shuffle ([0:|TestImages|-1], TestSequence)</l>
<l>TestImages := TestImages[TestSequence]</l>
<l>TestLabels := TestLabels[TestSequence]</l>
<l>return ()</l>
</body>
<docu id="split_dl_classifier_data_set">
<abstract lang="de_DE">split_dl_classifier_data_set unterteilt den Datensatz (die Eingabebilder und die vom Benutzer vergebenen, dazugehörigen Labels) in drei Teilmengen für das Training, die Validierung und das Testen. Die Anzahl der Bilder pro Teilmenge wird durch die gegebenen Anteile TrainingPercent und ValidationPercent definiert. Jede Teilmenge enthält zufällig verteilte Bilder, wobei das ursprüngliche Verhältnis der Klassengrößen beibehalten wird. 

TrainingPercent und ValidationPercent legen mit jeweils einer Zahl zwischen 0 und 100 fest, wie viele Prozent der Eingabebilder und -labels in die jeweiligen Teilmengen einsortiert werden. Die restlichen Daten bilden den Test-Datensatz. Die Summe der beiden Zahlen darf 100 nicht übersteigen. Dabei ist zu beachten, dass je nach Anzahl der Bilder und der Größe der Klassen diese Vorgaben nur näherungsweise erreicht werden können.</abstract>
<abstract lang="en_US">split_dl_classifier_data_set divides the input data set (input images and ground truth labels) into three different subsets: training, validation, and test set. The number of images in each subset is defined by the given percentages TrainingPercent and ValidationPercent. Each subset contains randomly distributed data, whereby the original ratio of class sizes is kept.

TrainingPercent and ValidationPercent determine the percentage of the respective images and labels in the corresponding subsets, with a number between 0 and 100. The remaining data constitute the test set. The sum of TrainingPercent and ValidationPercent must not be greater than 100. Note that the actual percentages that are achieved can differ depending on the number of images and the number of images per class.

</abstract>
<chapters lang="de_DE">
<item>Deep Learning</item>
<item>Klassifikation</item>
</chapters>
<chapters lang="en_US">
<item>Deep Learning</item>
<item>Classification</item>
</chapters>
<example lang="en_US">read_dl_classifier_data_set ('3d_machine_vision', 'last_folder', ImageFiles, GroundTruthLabels, UniqueClasses)
TrainingPercent := 60
ValidationPercent := 20
split_dl_classifier_data_set (ImageFiles, GroundTruthLabels, TrainingPercent, ValidationPercent, TrainingImages, TrainingLabels, ValidationImages, ValidationLabels, TestImages, TestLabels)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="de_DE">Unterteilen und durchmischen der Bilder und vom Benutzer vergebenen, dazugehörigen Labels in Trainings-, Validierungs- und Test-Teilmengen</short>
<short lang="en_US">Split and shuffle the images and ground truth labels into training, validation and test subsets.</short>
<parameters>
<parameter id="GroundTruthLabels">
<default_type>string</default_type>
<description lang="de_DE">Die vom Benutzer vergebenen Labels der Bilder.</description>
<description lang="en_US">Ground truth labels of the images.</description>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ImageFiles">
<default_type>string</default_type>
<description lang="de_DE">Tuple mit den Bildpfaden.</description>
<description lang="en_US">Tuple of the image paths. </description>
<mixed_type>false</mixed_type>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="TestImages">
<default_type>string</default_type>
<description lang="de_DE">Die Bilder für den Test.</description>
<description lang="en_US">The images for testing.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="TestLabels">
<default_type>string</default_type>
<description lang="de_DE">Die vom Benutzer vergebenen Labels zu den Testbildern.</description>
<description lang="en_US">The ground truth labels of the test images.</description>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="TrainingImages">
<default_type>string</default_type>
<description lang="de_DE">Die Bilder für das Training.</description>
<description lang="en_US">The images for training.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="TrainingLabels">
<default_type>string</default_type>
<description lang="de_DE">Die vom Benutzer vergebenen Labels zu den Trainingsbildern.</description>
<description lang="en_US">The ground truth labels of the training images.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="TrainingPercent">
<default_type>integer</default_type>
<description lang="de_DE">Prozentsatz der Daten, der zum Training verwendet werden soll.</description>
<description lang="en_US">Percentage of the data that should be used for training.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>100</value_max>
<value_min>0.000000000</value_min>
</parameter>
<parameter id="ValidationImages">
<default_type>string</default_type>
<description lang="de_DE">Die Bilder für die Validierung.</description>
<description lang="en_US">The images for validation.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>filename.dir</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ValidationLabels">
<default_type>string</default_type>
<description lang="de_DE">Die vom Benutzer vergebenen Labels zu den Validierungsbildern.</description>
<description lang="en_US">The ground truth labels of the validation images.</description>
<sem_type>string</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
</parameter>
<parameter id="ValidationPercent">
<default_type>integer</default_type>
<description lang="de_DE">Prozentsatz der Daten, der zum Validieren verwendet werden soll.</description>
<description lang="en_US">Percentage of the data that should be used for validation.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
<value_max>100</value_max>
<value_min>0.000000000</value_min>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="structured_light_camera_screen_sync">
<interface>
<oo>
<par name="CameraImages" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="WindowWidth" base_type="ctrl" dimension="0"/>
<par name="WindowHeight" base_type="ctrl" dimension="0"/>
<par name="WaitSeconds" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImagesPerSecond" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure helps to establish a synchonization between</c>
<c>* the screen and the camera in a particular structured light setup.</c>
<c>* An in-sync setup ensures accurate camera images that are captured</c>
<c>* at exactly the right time.</c>
<c>* These camera images show exactly one pattern image</c>
<c>* each, rather than overlapping pattern images. If on the other</c>
<c>* hand the camera and screen are not in sync, the captured camera</c>
<c>* images will show overlap between two pattern images.</c>
<c>*</c>
<c>* Define the number of loops for the acquisition.</c>
<l>NumLoops := 10</l>
<c>* Generate test images:</c>
<c>* Vertical stripe image.</c>
<l>gen_image_const (VerticalStripes, 'byte', WindowWidth, WindowHeight)</l>
<l>get_domain (VerticalStripes, ScreenDomain)</l>
<l>get_region_points (ScreenDomain, ScrRows, ScrColumns)</l>
<l>set_grayval (VerticalStripes, ScrRows, ScrColumns, ((ScrColumns / 80) % 2)*255)</l>
<c>* Horizontal stripe image.</c>
<l>gen_image_const (HorizontalStripes, 'byte', WindowWidth, WindowHeight)</l>
<l>set_grayval (HorizontalStripes, ScrRows, ScrColumns, ((ScrRows / 80) % 2)*255)</l>
<c>*</c>
<l>gen_empty_obj (CameraImages)</l>
<l>count_seconds (Begin)</l>
<l>for Index := 1 to NumLoops by 1</l>
<c>    * Display the vertical stripes image.</c>
<l>    disp_image (VerticalStripes, WindowHandle)</l>
<c>    * Wait the specified time before acquiring the camera image.</c>
<l>    wait_seconds (WaitSeconds)</l>
<l>    grab_image (Image, AcqHandle)</l>
<c>    * Add the acquired vertical image to the output.</c>
<l>    concat_obj (CameraImages, Image, CameraImages)</l>
<c>    *</c>
<c>    * Display the horizontal stripe image.</c>
<l>    disp_image (HorizontalStripes, WindowHandle)</l>
<c>    * Wait the specified time before acquiring the camera image.</c>
<l>    wait_seconds (WaitSeconds)</l>
<l>    grab_image (Image, AcqHandle)</l>
<c>    * Add the acquired horizontal image to the output.</c>
<l>    concat_obj (CameraImages, Image, CameraImages)</l>
<l>endfor</l>
<l>count_seconds (End)</l>
<c>*</c>
<c>* Acquisition time and acquired images per second.</c>
<l>Time := End - Begin</l>
<l>ImagesPerSecond := 2*NumLoops/Time</l>
<c>*</c>
<l>return ()</l>
</body>
<docu id="structured_light_camera_screen_sync">
<abstract lang="en_US">This procedure helps to establish a synchonization between the screen and the camera in a particular structured light setup.

For an explanation of the concept of structured light and its supported applications, see the introduction of chapter Inspection / Structured Light. 

In a structured light setup, achieving a synchronization between the screen and the camera is of particular importance. On the one hand, the fastest possible acquisition is usually needed to speed-up the inspection process. On the other hand, a very fast acquisition might lead to overlapping images that result in a wrong inspection result. In other words, if the screen shows alternating pattern images and the camera is triggered to acquire the image too soon, the screen will still be displaying parts of the old image and the acquired camera image will show an overlap of two pattern images. Accordingly, a short pause is needed to ensure that the pattern image is fully displayed before acquiring the new camera image. This pause is defined here as the input parameter WaitSeconds.

To call this procedure, please position the camera in front of the screen in a way that a large part of the screen is seen in the acquired images. Alternatively, you can observe the reflection of the screen in a planar mirror.

The input parameter AcqHandle is the frame grabber used to acquire the images.

The input parameter WindowHandle is the handle of the graphics window on the screen where the pattern images will be displayed. The input parameters WindowWidth and WindowHeight, respectively, are the width and height of the window displaying the pattern images.

The input parameter WaitSeconds specifies the length of the pause (in seconds) to be tested. The optimal value for WaitSeconds has to be found by trial and error.

The output parameter ImagesPerSecond returns the achieved rate, i.e. the number of images acquired per second, in this particular setup for the specified parameter value WaitSeconds.

The output object CameraImages returns the camera images acquired of alternating vertical and horizontal pattern images, with an interval of WaitSeconds between displaying a pattern image and acquiring the camera image.

To find the optimal WaitSeconds, it is recommended to try steadily smaller values, whereby the output CameraImages have to be visually examined for each tested WaitSeconds. If all camera images show exactly one pattern image with correct orientation and without any transition stripes in the other direction, then the tried WaitSeconds is still OK. In this case, a smaller WaitSeconds can be tried out, until the shortest WaitSeconds is found. If, however, an overlap between vertical and horizontal patter images is seen, the tried WaitSeconds is too small and thus not acceptable. This is repeated until you find the shortest acceptable interval WaitSeconds.</abstract>
<chapters lang="en_US">
<item>Inspection</item>
<item>Structured Light</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Acquire images for the synchronization between the screen and the camera in a structured light setup.</short>
<parameters>
<parameter id="AcqHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the opened image acquisition device to be used in the procedure to acquire the test images.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>framegrabber</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CameraImages">
<description lang="en_US">Array containing the camera images of alternating pattern images, acquired at the WaitSeconds intervals.</description>
<multichannel>false</multichannel>
<multivalue>true</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>byte</item>
<item>uint2</item>
</type_list>
</parameter>
<parameter id="ImagesPerSecond">
<default_type>integer</default_type>
<description lang="en_US">Achieved rate of acquired images per second.</description>
<sem_type>number</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="WaitSeconds">
<default_type>real</default_type>
<default_value>0.1</default_value>
<description lang="en_US">Waiting time in seconds between displaying a pattern image on the screen and acquiring the camera image.</description>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Handle of the window in which the alternating pattern images will be displayed.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowHeight">
<default_type>integer</default_type>
<default_value>1200</default_value>
<description lang="en_US">Height of the window in which the alternating pattern images will be displayed.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="WindowWidth">
<default_type>integer</default_type>
<default_value>1600</default_value>
<description lang="en_US">Width of the window in which the alternating pattern images will be displayed.</description>
<multivalue>false</multivalue>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="test_features">
<interface>
<ic>
<par name="FeatureNames" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* </c>
<c>* Test procedure for custom features</c>
<c>* </c>
<c>* This procedure can be used to test, if custom features</c>
<c>* implemented in get_custom_features comply with the</c>
<c>* specifications of the calculate_feature_set library.</c>
<c>* </c>
<c>* In particular, the feature vector Feature, that is</c>
<c>* calculated with calculate_feature must fulfil</c>
<c>* following conditions:</c>
<c>* </c>
<c>* - For a single input region the result of</c>
<c>*   get_feature_length has to be equal to the length</c>
<c>*   of the featue vector: |Feature| == Length</c>
<c>* </c>
<c>* - For an empty input region array, the feature</c>
<c>*   vector has to be empty:</c>
<c>*   Feature == []</c>
<c>* </c>
<c>* - For input region arrays with multiple regions, the</c>
<c>*   following condition must be met:</c>
<c>*   |Feature| == NumRegions * Length</c>
<c>* </c>
<c>* - Additionally, the feature vector has to be sorted</c>
<c>*   according to the 'feature_column' order of</c>
<c>*   add_sample_class_train_data.</c>
<c>* </c>
<l>TestSuccessful := false</l>
<l>read_image (Image, 'patras')</l>
<l>threshold (Image, Region, 128, 255)</l>
<l>get_feature_lengths (FeatureNames, Lengths)</l>
<c>* </c>
<l>TestString[0] := 'Empty region array test (no region)'</l>
<l>TestString[1] := 'Empty region test'</l>
<l>TestString[2] := 'Single region test'</l>
<l>for Test := 0 to 2 by 1</l>
<l>    switch (Test)</l>
<l>    case 0:</l>
<l>        select_shape (Region, TestRegion, 'area', 'and', 0, 0)</l>
<l>        break</l>
<l>    case 1:</l>
<l>        gen_empty_region (TestRegion)</l>
<l>        break</l>
<l>    case 2:</l>
<l>        copy_obj (Region, TestRegion, 1, 1)</l>
<l>        break</l>
<l>    default:</l>
<l>    endswitch</l>
<l>    count_obj (TestRegion, NumRegions)</l>
<l>    AllFeatures := []</l>
<l>    for Index := 0 to |FeatureNames| - 1 by 1</l>
<l>        CurName := FeatureNames[Index]</l>
<l>        CurLength := Lengths[Index]</l>
<l>        calculate_features (TestRegion, Image, CurName, Features)</l>
<l>        if (NumRegions * CurLength != |Features|)</l>
<l>            throw (TestString[Test] + ' failed for feature \'' + CurName + '\'')</l>
<l>        endif</l>
<l>        AllFeatures := [AllFeatures,Features]</l>
<l>    endfor</l>
<l>    SumLengths := sum(Lengths)</l>
<l>    Total := SumLengths * NumRegions</l>
<l>    if (Total != |AllFeatures|)</l>
<l>        throw (['Test ' + Test + ' failed',TestString[Test]])</l>
<l>    endif</l>
<l>endfor</l>
<c>* </c>
<c>* Test multiple input regions</c>
<l>connection (Region, TestRegion)</l>
<l>select_obj (TestRegion, TestRegionSelected, [1:3])</l>
<l>for I := 0 to |FeatureNames| - 1 by 1</l>
<l>    CurName := FeatureNames[I]</l>
<l>    calculate_features (TestRegionSelected, Image, CurName, Features1)</l>
<l>    Features2 := []</l>
<l>    count_obj (TestRegionSelected, NumRegions)</l>
<l>    for J := 1 to NumRegions by 1</l>
<l>        select_obj (TestRegionSelected, ObjectSelected, J)</l>
<l>        calculate_features (ObjectSelected, Image, CurName, Features)</l>
<l>        Features2 := [Features2,Features]</l>
<l>    endfor</l>
<l>    CorrectOrder := Features1 == Features2</l>
<l>    if (not CorrectOrder)</l>
<l>        throw ('Multiple region test failed for feature \'' + CurName + '\'')</l>
<l>    endif</l>
<l>endfor</l>
<l>TestSuccessful := true</l>
<l>return ()</l>
</body>
<docu id="test_features">
<abstract lang="en_US">This procedure can be used to test, if custom features implemented in get_custom_features comply with the specifications of the calculate_feature_set library.

In particular, the feature vector Feature, that is calculated with calculate_feature must fulfil following conditions:

- For a single input region the result of get_feature_length has to be equal to the length of the featue vector: |Feature| == Length

- For an empty input region array, the feature vector has to be empty:   Feature == []

- For input region arrays with multiple regions, the following condition must be met: |Feature| == NumRegions * Length
 
- Additionally, the feature vector has to be sorted according to the 'feature_column' order of  add_sample_class_train_data.</abstract>
<chapters lang="de_DE">
<item>Klassifikation</item>
<item>Sonstiges</item>
</chapters>
<chapters lang="en_US">
<item>Classification</item>
<item>Misc</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Test procedure for custom features.</short>
<parameters>
<parameter id="FeatureNames">
<default_type>string</default_type>
<description lang="en_US">Feature names.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="trackball" access="local">
<interface>
<ic>
<par name="MX1" base_type="ctrl" dimension="0"/>
<par name="MY1" base_type="ctrl" dimension="0"/>
<par name="MX2" base_type="ctrl" dimension="0"/>
<par name="MY2" base_type="ctrl" dimension="0"/>
<par name="VirtualTrackball" base_type="ctrl" dimension="0"/>
<par name="TrackballSize" base_type="ctrl" dimension="0"/>
<par name="SensFactor" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="QuatRotation" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Compute the 3D rotation from the mouse movement</c>
<c>* </c>
<l>if (MX1 == MX2 and MY1 == MY2)</l>
<l>    QuatRotation := [1,0,0,0]</l>
<l>    return ()</l>
<l>endif</l>
<c>* Project the image point onto the trackball</c>
<l>project_point_on_trackball (MX1, MY1, VirtualTrackball, TrackballSize, P1)</l>
<l>project_point_on_trackball (MX2, MY2, VirtualTrackball, TrackballSize, P2)</l>
<c>* The cross product of the projected points defines the rotation axis</c>
<l>tuple_vector_cross_product (P1, P2, RotAxis)</l>
<c>* Compute the rotation angle</c>
<l>D := P2 - P1</l>
<l>T := sqrt(sum(D * D)) / (2.0 * TrackballSize)</l>
<l>if (T &gt; 1.0)</l>
<l>    T := 1.0</l>
<l>endif</l>
<l>if (T &lt; -1.0)</l>
<l>    T := -1.0</l>
<l>endif</l>
<l>RotAngle := 2.0 * asin(T) * SensFactor</l>
<l>Len := sqrt(sum(RotAxis * RotAxis))</l>
<l>if (Len &gt; 0.0)</l>
<l>    RotAxis := RotAxis / Len</l>
<l>endif</l>
<l>axis_angle_to_quat (RotAxis[0], RotAxis[1], RotAxis[2], RotAngle, QuatRotation)</l>
<l>return ()</l>
</body>
<docu id="trackball">
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Compute the 3D rotation from the mouse movement</short>
<parameters>
<parameter id="MX1"/>
<parameter id="MX2"/>
<parameter id="MY1"/>
<parameter id="MY2"/>
<parameter id="QuatRotation"/>
<parameter id="SensFactor"/>
<parameter id="TrackballSize"/>
<parameter id="VirtualTrackball"/>
</parameters>
</docu>
</procedure>
<procedure name="tuple_shuffle">
<interface>
<ic>
<par name="Tuple" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Shuffled" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* This procedure sorts the input tuple randomly.</c>
<c>*</c>
<l>if (|Tuple| &gt; 0)</l>
<c>    * Create a tuple of random numbers,</c>
<c>    * sort this tuple, and return the indices </c>
<c>    * of this sorted tuple.</c>
<l>    ShuffleIndices := sort_index(rand(|Tuple|))</l>
<c>    * Assign the elements of Tuple </c>
<c>    * to these random positions.</c>
<l>    Shuffled := Tuple[ShuffleIndices]</l>
<l>else</l>
<c>    * If the input tuple is empty,</c>
<c>    * an empty tuple should be returned.</c>
<l>    Shuffled := []</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="tuple_shuffle">
<abstract lang="de_DE">tuple_shuffle sortiert die Elemete des Eingabetupels Tuple zufällig und gibt das Ergebnis in Shuffled zurück. Es ist möglich, Strings und Nummern in Tuple zu vermischen. Ein leeres Eingabetupel resultiert in einem leeren Ausgabetupel.</abstract>
<abstract lang="en_US">tuple_shuffle sorts the elements of the input Tuple randomly, and returns the result in Shuffled. You can mix strings and numbers in Tuple. An empty input tuple results in an empty output tuple.</abstract>
<alternatives>
<item>tuple_sort</item>
</alternatives>
<chapters lang="de_DE">
<item>Tupel</item>
<item>Elementreihenfolge</item>
</chapters>
<chapters lang="en_US">
<item>Tuple</item>
<item>Element Order</item>
</chapters>
<example lang="de_DE">Tuple := [0:10]
tuple_shuffle (Tuple, Shuffled)</example>
<example lang="en_US">Tuple := [0:10]
tuple_shuffle (Tuple, Shuffled)</example>
<library lang="de_DE">MVTec Standard Procedures</library>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="de_DE">Zufälliges Sortieren der Elemente eines Tupels.</short>
<short lang="en_US">Sort the elements of a tuple randomly.</short>
<parameters>
<parameter id="Shuffled"/>
<parameter id="Tuple"/>
</parameters>
</docu>
</procedure>
<procedure name="tuple_vector_cross_product">
<interface>
<ic>
<par name="V1" base_type="ctrl" dimension="0"/>
<par name="V2" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="VC" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* The caller must ensure that the length of both input vectors is 3</c>
<l>VC := V1[1] * V2[2] - V1[2] * V2[1]</l>
<l>VC := [VC,V1[2] * V2[0] - V1[0] * V2[2]]</l>
<l>VC := [VC,V1[0] * V2[1] - V1[1] * V2[0]]</l>
<l>return ()</l>
</body>
<docu id="tuple_vector_cross_product">
<abstract lang="en_US">Calculates the cross product of two vectors of length 3.</abstract>
<chapters lang="de_DE">
<item>Tupel</item>
<item>Arithmetik</item>
</chapters>
<chapters lang="en_US">
<item>Tuple</item>
<item>Arithmetic</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<short lang="en_US">Calculates the cross product of two vectors of length 3.</short>
<parameters>
<parameter id="V1">
<default_type>real</default_type>
<description lang="en_US">First Vector</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="V2">
<default_type>real</default_type>
<description lang="en_US">Second vector.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="VC">
<default_type>real</default_type>
<description lang="en_US">Resulting vector.</description>
<mixed_type>optional</mixed_type>
<sem_type>real</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="visualize_calibrated_touching_point" access="local">
<interface>
<ic>
<par name="RobotTouchingPointInToolCoordinates" base_type="ctrl" dimension="0"/>
<par name="ToolInBasePosesTouchingPoint" base_type="ctrl" dimension="1"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>*</c>
<c>* Create 3D object models.</c>
<l>gen_tool_to_touching_point_object_model_3d (ToolInBasePosesTouchingPoint, RobotTouchingPointInToolCoordinates, OM3DToolTouchingPoint)</l>
<c>*</c>
<c>* Prepare parameters for visualize_object_model_3d.</c>
<c>* Instructions.</c>
<l>Instructions[0] := 'Rotate: Left button'</l>
<l>Instructions[1] := 'Zoom:   Shift + left button'</l>
<l>Instructions[2] := 'Move:   Ctrl  + left button'</l>
<c>* 3D visualization pose.</c>
<l>create_pose (0.326, 0.016, 3.137, 83.33, 341.96, 99.32, 'Rp+T', 'gba', 'point', PoseIn)</l>
<c>*</c>
<l>GenParamName := ['color_0', 'color_1', 'color_2', 'color_3', 'color_4', 'color_5','color_6', 'color_7', 'color_8','color_9', 'color_10', 'color_11']</l>
<l>GenParamValue := ['red','green','blue','magenta','red','green','blue','magenta','red','green','blue','magenta']</l>
<c>*</c>
<l>Title    := 'Visualization of the read poses. The magenta lines connect the'</l>
<l>Title[1] := 'tool coordinate system with the touching point. They intersect' </l>
<l>Title[2] := 'in the approached point in the plane. Calculated touching point'</l>
<l>Title[3] := 'coordinates with respect to the robot\'s tool: '</l>
<l>Title[4] := 'X: ' + (RobotTouchingPointInToolCoordinates[0] * 1000) $'.2f' + ' mm, Y: ' + (RobotTouchingPointInToolCoordinates[1] * 1000) $'.2f' + ' mm, Z: ' + (RobotTouchingPointInToolCoordinates[2] * 1000) $'.2f' + ' mm'</l>
<c>* Labels for the visualized 3D object models.</c>
<l>NumOM3D := |OM3DToolTouchingPoint|</l>
<l>tuple_gen_const (NumOM3D, '', Label)</l>
<l>Label[2] := 'ToolInBasePosesTouchingPoint 1'</l>
<l>Label[6] := 'ToolInBasePosesTouchingPoint 2'</l>
<l>Label[10] := 'ToolInBasePosesTouchingPoint 3'</l>
<c>*</c>
<l>visualize_object_model_3d (WindowHandle, OM3DToolTouchingPoint, [], PoseIn, GenParamName, GenParamValue, Title, Label, Instructions, PoseOut)</l>
<c>*</c>
<c>* Clean up.</c>
<l>clear_object_model_3d (OM3DToolTouchingPoint)</l>
<l>return ()</l>
</body>
<docu id="visualize_calibrated_touching_point">
<chapters lang="de_DE">
<item>Graphik</item>
<item>3D-Szene</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>3D Scene</item>
</chapters>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>get_robot_touching_point_in_tool_coordinates</item>
</predecessor>
<see_also>
<item>calibrate_robot_touching_point</item>
</see_also>
<short lang="en_US">Visualize the poses that were used to calculate the touching point, and the result.</short>
<parameters>
<parameter id="RobotTouchingPointInToolCoordinates"/>
<parameter id="ToolInBasePosesTouchingPoint">
<sem_type>pose</sem_type>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<mixed_type>false</mixed_type>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="visualize_object_model_3d">
<interface>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
<par name="CamParam" base_type="ctrl" dimension="0"/>
<par name="PoseIn" base_type="ctrl" dimension="0"/>
<par name="GenParamName" base_type="ctrl" dimension="0"/>
<par name="GenParamValue" base_type="ctrl" dimension="0"/>
<par name="Title" base_type="ctrl" dimension="0"/>
<par name="Label" base_type="ctrl" dimension="0"/>
<par name="Information" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="PoseOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* The procedure visualize_object_model_3d can be used to display</c>
<c>* one or more 3d object models and to interactively modify</c>
<c>* the object poses by using the mouse.</c>
<c>* </c>
<c>* The pose can be modified by moving the mouse while</c>
<c>* pressing a mouse button. The default settings are:</c>
<c>* </c>
<c>*  Rotate: Left mouse button</c>
<c>*  Zoom: Shift + Left mouse button (or Center mouse button)</c>
<c>*  Pan: Ctrl + Left mouse button</c>
<c>* </c>
<c>* Furthermore, it is possible to select and deselect objects,</c>
<c>* to decrease the mouse sensitivity, and to toggle the</c>
<c>* inspection mode (see the description of the generic parameter</c>
<c>* 'inspection_mode' below):</c>
<c>* </c>
<c>*  (De-)select object(s): Right mouse button</c>
<c>*  Low mouse sensitivity: Alt + Mouse button</c>
<c>*  Toggle inspection mode: Ctrl + Alt + Left mouse button</c>
<c>* </c>
<c>* In GenParamName and GenParamValue all generic Parameters</c>
<c>* of disp_object_model_3d are supported.</c>
<c>* </c>
<c>* **********************************************************</c>
<c>* Define global variables</c>
<c>* **********************************************************</c>
<c>* </c>
<l>global def tuple gDispObjOffset</l>
<l>global def tuple gLabelsDecor</l>
<l>global def tuple gInfoDecor</l>
<l>global def tuple gInfoPos</l>
<l>global def tuple gTitlePos</l>
<l>global def tuple gTitleDecor</l>
<l>global def tuple gTerminationButtonLabel</l>
<l>global def tuple gAlphaDeselected</l>
<l>global def tuple gIsSinglePose</l>
<l>global def tuple gUsesOpenGL</l>
<c>* </c>
<c>* **********************************************************</c>
<c>* Initialize Handles to enable correct handling in error case</c>
<c>* **********************************************************</c>
<l>Scene3DTest := []</l>
<l>Scene3D := []</l>
<l>WindowHandleBuffer := []</l>
<c></c>
<c>* **********************************************************</c>
<c>* Some user defines that may be adapted if desired</c>
<c>* **********************************************************</c>
<c>* </c>
<c>* TrackballSize defines the diameter of the trackball in</c>
<c>* the image with respect to the smaller image dimension.</c>
<l>TrackballSize := 0.8</l>
<c>* </c>
<c>* VirtualTrackball defines the type of virtual trackball that</c>
<c>* shall be used ('shoemake' or 'bell').</c>
<l>VirtualTrackball := 'shoemake'</l>
<l>* VirtualTrackball := 'bell'</l>
<c>* </c>
<c>* Functionality of mouse buttons</c>
<c>*     1: Left Button</c>
<c>*     2: Middle Button</c>
<c>*     4: Right Button</c>
<c>*     5: Left+Right Mousebutton</c>
<c>*   8+x: Shift + Mousebutton</c>
<c>*  16+x: Ctrl + Mousebutton</c>
<c>*  48+x: Ctrl + Alt + Mousebutton</c>
<c>* in the order [Translate, Rotate, Scale, ScaleAlternative1, ScaleAlternative2, SelectObjects, ToggleSelectionMode]</c>
<l>MouseMapping := [17,1,2,5,9,4,49]</l>
<c>* </c>
<c>* The labels of the objects appear next to their projected</c>
<c>* center. With gDispObjOffset a fixed offset is added</c>
<c>*                   R,  C</c>
<l>gDispObjOffset := [-30,0]</l>
<c>* </c>
<c>* Customize the decoration of the different text elements</c>
<c>*               Color,   Box</c>
<l>gInfoDecor := ['white','false']</l>
<l>gLabelsDecor := ['white','false']</l>
<l>gTitleDecor := ['black','true']</l>
<c>* </c>
<c>* Customize the position of some text elements</c>
<c>*   gInfoPos has one of the values</c>
<c>*   {'UpperLeft', 'LowerLeft', 'UpperRight'}</c>
<l>gInfoPos := 'LowerLeft'</l>
<c>*   gTitlePos has one of the values</c>
<c>*   {'UpperLeft', 'UpperCenter', 'UpperRight'}</c>
<l>gTitlePos := 'UpperLeft'</l>
<c>* Alpha value (=1-transparency) that is used for visualizing</c>
<c>* the objects that are not selected</c>
<l>gAlphaDeselected := 0.3</l>
<c>* Customize the label of the continue button</c>
<l>gTerminationButtonLabel := ' Continue '</l>
<c>* Define if the continue button responds to a single click event or</c>
<c>* if it responds only if the mouse button is released while being placed</c>
<c>* over the continue button.</c>
<c>* 'true':  Wait until the continue button has been released.</c>
<c>*          This should be used to avoid unwanted continuations of</c>
<c>*          subsequent calls of visualize_object_model_3d, which can</c>
<c>*          otherwise occur if the mouse button remains pressed while the</c>
<c>*          next visualization is active.</c>
<c>* 'false': Continue the execution already if the continue button is</c>
<c>*          pressed. This option allows a fast forwarding through</c>
<c>*          subsequent calls of visualize_object_model_3d.</c>
<l>WaitForButtonRelease := 'true'</l>
<c>* Number of 3D Object models that can be selected and handled individually.</c>
<c>* If there are more models passed then this number, some calculations</c>
<c>* are performed differently and the individual selection and handling</c>
<c>* of models is not supported anymore. Note that the value of MaxNumModels</c>
<c>* can be overwritten with the generic parameter max_num_selectable_models.</c>
<l>MaxNumModels := 1000</l>
<c>* Defines the default for the initial state of the rotation center:</c>
<c>* (1) The rotation center is fixed in the center of the image and lies</c>
<c>*     on the surface of the object.</c>
<c>* (2) The rotation center lies in the center of the object.</c>
<l>WindowCenteredRotation := 2</l>
<c>* </c>
<c>* **********************************************************</c>
<c>* </c>
<c>* Initialize some values</c>
<l>NumModels := |ObjectModel3D|</l>
<l>SelectedObject := gen_tuple_const(NumModels,1)</l>
<c>* </c>
<c>* Apply some system settings</c>
<l>dev_set_preferences ('graphics_window_context_menu', 'false')</l>
<l>dev_get_preferences ('suppress_handled_exceptions_dlg', SuppressExceptDlg)</l>
<l>dev_set_preferences ('suppress_handled_exceptions_dlg', 'true')</l>
<l>dev_get_preferences ('graphics_window_mouse_wheel', WindowMouseWheel)</l>
<l>dev_set_preferences ('graphics_window_mouse_wheel', 'false')</l>
<l>get_system ('clip_region', ClipRegion)</l>
<l>set_system ('clip_region', 'false')</l>
<l>dev_update_off ()</l>
<c>* </c>
<c>* Check if GenParamName matches GenParamValue</c>
<l>if (|GenParamName| != |GenParamValue|)</l>
<l>    throw ('Number of generic parameters does not match number of generic parameter values')</l>
<l>endif</l>
<c>* </c>
<l>try</l>
<c>    * </c>
<c>    * Refactor camera parameters to fit to window size</c>
<c>    * </c>
<l>    CPLength := |CamParam|</l>
<l>    get_window_extents (WindowHandle, RowNotUsed, ColumnNotUsed, Width, Height)</l>
<l>    get_part (WindowHandle, WPRow1, WPColumn1, WPRow2, WPColumn2)</l>
<l>    set_part (WindowHandle, 0, 0, Height - 1, Width - 1)</l>
<l>    if (CPLength == 0)</l>
<l>        gen_cam_par_area_scan_division (0.06, 0, 8.5e-6, 8.5e-6, Width / 2, Height / 2, Width, Height, CamParam)</l>
<l>    else</l>
<l>        get_cam_par_data (CamParam, ['sx','sy','cx','cy','image_width','image_height'], CamParamValue)</l>
<l>        CamWidth := real(CamParamValue[4])</l>
<l>        CamHeight := real(CamParamValue[5])</l>
<l>        Scale := min([Width / CamWidth,Height / CamHeight])</l>
<l>        set_cam_par_data (CamParam, 'sx', CamParamValue[0] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'sy', CamParamValue[1] / Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cx', CamParamValue[2] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'cy', CamParamValue[3] * Scale, CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_width', int(CamParamValue[4] * Scale), CamParam)</l>
<l>        set_cam_par_data (CamParam, 'image_height', int(CamParamValue[5] * Scale), CamParam)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for max_num_selectable_models</c>
<c>    * (Note that the default is set above to MaxNumModels := 1000)</c>
<l>    Indices := find(GenParamName,'max_num_selectable_models')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (is_number(GenParamValue[Indices[0]]))</l>
<l>            if (int(number(GenParamValue[Indices[0]])) &lt; 1)</l>
<c>                * Wrong parameter value: Only integer values greater than 0 are allowed</c>
<l>                throw ('Wrong value for parameter \'max_num_selectable_models\' (must be an integer value greater than 0)')</l>
<l>            endif</l>
<l>        else</l>
<c>            * Wrong parameter value: Only integer values greater than 0 are allowed</c>
<l>            throw ('Wrong value for parameter \'max_num_selectable_models\' (must be an integer value greater than 0)')</l>
<l>        endif</l>
<l>        MaxNumModels := int(number(GenParamValue[Indices[0]]))</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for window_centered_rotation</c>
<c>    * (Note that the default is set above to WindowCenteredRotation := 2)</c>
<l>    Indices := find(GenParamName,'inspection_mode')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[0]] == 'surface')</l>
<l>            WindowCenteredRotation := 1</l>
<l>        elseif (GenParamValue[Indices[0]] == 'standard')</l>
<l>            WindowCenteredRotation := 2</l>
<l>        else</l>
<c>            * Wrong parameter value, use default value</c>
<l>        endif</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Check the generic parameters for disp_background</c>
<c>    * (The former parameter name 'use_background' is still supported</c>
<c>    *  for compatibility reasons)</c>
<l>    DispBackground := 'false'</l>
<l>    if (|GenParamName| &gt; 0)</l>
<l>        Mask := GenParamName [==] 'disp_background' or GenParamName [==] 'use_background'</l>
<l>        Indices := find(Mask,1)</l>
<l>    else</l>
<l>        Indices := -1</l>
<l>    endif</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        DispBackground := GenParamValue[Indices[0]]</l>
<l>        if (DispBackground != 'true' and DispBackground != 'false')</l>
<c>            * Wrong parameter value: Only 'true' and 'false' are allowed</c>
<l>            throw ('Wrong value for parameter \'disp_background\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<c>        * Note the the background is handled explicitly in this procedure</c>
<c>        * and therefore, the parameter is removed from the list of</c>
<c>        * parameters and disp_background is always set to true (see below)</c>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Read and check the parameter Label for each object</c>
<l>    if (|Label| == 0)</l>
<l>        Label := 0</l>
<l>    elseif (|Label| == 1)</l>
<l>        Label := gen_tuple_const(NumModels,Label)</l>
<l>    else</l>
<l>        if (|Label| != NumModels)</l>
<c>            * Error: Number of elements in Label does not match the</c>
<c>            * number of object models</c>
<l>            stop ()</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Read and check the parameter PoseIn for each object</c>
<l>    get_object_models_center (ObjectModel3D, Center)</l>
<l>    if (|PoseIn| == 0)</l>
<c>        * If no pose was specified by the caller, automatically calculate</c>
<c>        * a pose that is appropriate for the visualization.</c>
<c>        * Set the initial model reference pose. The orientation is parallel</c>
<c>        * to the object coordinate system, the position is at the center</c>
<c>        * of gravity of all models.</c>
<l>        create_pose (-Center[0], -Center[1], -Center[2], 0, 0, 0, 'Rp+T', 'gba', 'point', PoseIn)</l>
<l>        determine_optimum_pose_distance (ObjectModel3D, CamParam, 0.9, PoseIn, PoseEstimated)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseEstimated[Sequence % 7]</l>
<l>        gIsSinglePose := true</l>
<l>    elseif (|PoseIn| == 7)</l>
<l>        Poses := []</l>
<l>        HomMat3Ds := []</l>
<l>        Sequence := [0:NumModels * 7 - 1]</l>
<l>        Poses := PoseIn[Sequence % 7]</l>
<l>        gIsSinglePose := true</l>
<l>    else</l>
<l>        if (|PoseIn| != |ObjectModel3D| * 7)</l>
<c>            * Error: Wrong number of values of input control parameter 'PoseIn'</c>
<l>            stop ()</l>
<l>        else</l>
<l>            Poses := PoseIn</l>
<l>        endif</l>
<l>        gIsSinglePose := false</l>
<l>    endif</l>
<c></c>
<c>    * </c>
<c>    * Open (invisible) buffer window to avoid flickering</c>
<l>    open_window (0, 0, Width, Height, 0, 'buffer', '', WindowHandleBuffer)</l>
<l>    set_part (WindowHandleBuffer, 0, 0, Height - 1, Width - 1)</l>
<l>    get_font (WindowHandle, Font)</l>
<l>    try</l>
<l>        set_font (WindowHandleBuffer, Font)</l>
<l>    catch (Exception)</l>
<l>    endtry</l>
<c>    * </c>
<c>    *  Is OpenGL available and should it be used?</c>
<l>    gUsesOpenGL := 'true'</l>
<l>    Indices := find(GenParamName,'opengl')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        gUsesOpenGL := GenParamValue[Indices[0]]</l>
<l>        GenParamName := remove(GenParamName,Indices)</l>
<l>        GenParamValue := remove(GenParamValue,Indices)</l>
<l>        if (gUsesOpenGL != 'true' and gUsesOpenGL != 'false')</l>
<c>            * Wrong parameter value: Only 'true' and 'false' are allowed</c>
<l>            throw ('Wrong value for parameter \'opengl\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>    endif</l>
<l>    if (gUsesOpenGL == 'true')</l>
<l>        get_system ('opengl_info', OpenGLInfo)</l>
<l>        if (OpenGLInfo == 'No OpenGL support included.')</l>
<l>            gUsesOpenGL := 'false'</l>
<l>        else</l>
<l>            gen_object_model_3d_from_points (0, 0, 0, DummyObjectModel3D)</l>
<l>            create_scene_3d (Scene3DTest)</l>
<l>            add_scene_3d_camera (Scene3DTest, CamParam, CameraIndexTest)</l>
<l>            determine_optimum_pose_distance (DummyObjectModel3D, CamParam, 0.9, [0,0,0,0,0,0,0], PoseTest)</l>
<l>            add_scene_3d_instance (Scene3DTest, DummyObjectModel3D, PoseTest, InstanceIndexTest)</l>
<l>            try</l>
<l>                display_scene_3d (WindowHandleBuffer, Scene3DTest, InstanceIndexTest)</l>
<l>            catch (Exception)</l>
<l>                gUsesOpenGL := 'false'</l>
<l>            endtry</l>
<l>            clear_scene_3d (Scene3DTest)</l>
<l>            Scene3DTest := []</l>
<l>            clear_object_model_3d (DummyObjectModel3D)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Compute the trackball</c>
<l>    MinImageSize := min([Width,Height])</l>
<l>    TrackballRadiusPixel := TrackballSize * MinImageSize / 2.0</l>
<c>    * </c>
<c>    * Measure the text extents for the continue button in the</c>
<c>    * graphics window</c>
<l>    get_string_extents (WindowHandleBuffer, gTerminationButtonLabel + '  ', Ascent, Descent, TextWidth, TextHeight)</l>
<c>    * </c>
<c>    * Store background image</c>
<l>    if (DispBackground == 'false')</l>
<l>        clear_window (WindowHandle)</l>
<l>    endif</l>
<l>    dump_window_image (Image, WindowHandle)</l>
<c>    * Special treatment for color background images necessary</c>
<l>    count_channels (Image, NumChannels)</l>
<l>    ColorImage := NumChannels == 3</l>
<c>    * </c>
<l>    create_scene_3d (Scene3D)</l>
<l>    add_scene_3d_camera (Scene3D, CamParam, CameraIndex)</l>
<l>    add_scene_3d_instance (Scene3D, ObjectModel3D, Poses, AllInstances)</l>
<c>    * Always set 'disp_background' to true,  because it is handled explicitly</c>
<c>    * in this procedure (see above)</c>
<l>    set_scene_3d_param (Scene3D, 'disp_background', 'true')</l>
<c>    * Check if we have to set light specific parameters</c>
<l>    SetLight := regexp_test(GenParamName,'light_')</l>
<l>    if (SetLight)</l>
<c>        * set position of light source</c>
<l>        Indices := find(GenParamName,'light_position')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If multiple light positions are given, use the last one</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| != 4)</l>
<l>                throw ('light_position must be given as a string that contains four space separated floating point numbers')</l>
<l>            endif</l>
<l>            LightPosition := LightParam[0:2]</l>
<l>            LightKind := 'point_light'</l>
<l>            if (LightParam[3] == 0)</l>
<l>                LightKind := 'directional_light'</l>
<l>            endif</l>
<c>            * Currently, only one light source is supported</c>
<l>            remove_scene_3d_light (Scene3D, 0)</l>
<l>            add_scene_3d_light (Scene3D, LightPosition, LightKind, LightIndex)</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<c>        * set ambient part of light source</c>
<l>        Indices := find(GenParamName,'light_ambient')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If the ambient part is set multiple times, use the last setting</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| &lt; 3)</l>
<l>                throw ('light_ambient must be given as a string that contains three space separated floating point numbers')</l>
<l>            endif</l>
<l>            set_scene_3d_light_param (Scene3D, 0, 'ambient', LightParam[0:2])</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<c>        * Set diffuse part of light source</c>
<l>        Indices := find(GenParamName,'light_diffuse')</l>
<l>        if (Indices != -1 and Indices != [])</l>
<c>            * If the diffuse part is set multiple times, use the last setting</c>
<l>            LightParam := number(split(GenParamValue[Indices[|Indices| - 1]],', '))</l>
<l>            if (|LightParam| &lt; 3)</l>
<l>                throw ('light_diffuse must be given as a string that contains three space separated floating point numbers')</l>
<l>            endif</l>
<l>            set_scene_3d_light_param (Scene3D, 0, 'diffuse', LightParam[0:2])</l>
<l>            tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>            tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>        endif</l>
<l>    endif</l>
<c>    * </c>
<c>    * Handle persistence parameters separately because persistence will</c>
<c>    * only be activated immediately before leaving the visualization</c>
<c>    * procedure</c>
<l>    PersistenceParamName := []</l>
<l>    PersistenceParamValue := []</l>
<c>    * Set position of light source</c>
<l>    Indices := find(GenParamName,'object_index_persistence')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[|Indices| - 1]] == 'true')</l>
<l>            PersistenceParamName := [PersistenceParamName,'object_index_persistence']</l>
<l>            PersistenceParamValue := [PersistenceParamValue,'true']</l>
<l>        elseif (GenParamValue[Indices[|Indices| - 1]] == 'false')</l>
<l>        else</l>
<l>            throw ('Wrong value for parameter \'object_index_persistence\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>        tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>        tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>    endif</l>
<l>    Indices := find(GenParamName,'depth_persistence')</l>
<l>    if (Indices != -1 and Indices != [])</l>
<l>        if (GenParamValue[Indices[|Indices| - 1]] == 'true')</l>
<l>            PersistenceParamName := [PersistenceParamName,'depth_persistence']</l>
<l>            PersistenceParamValue := [PersistenceParamValue,'true']</l>
<l>        elseif (GenParamValue[Indices[|Indices| - 1]] == 'false')</l>
<l>        else</l>
<l>            throw ('Wrong value for parameter \'depth_persistence\' (must be either \'true\' or \'false\')')</l>
<l>        endif</l>
<l>        tuple_remove (GenParamName, Indices, GenParamName)</l>
<l>        tuple_remove (GenParamValue, Indices, GenParamValue)</l>
<l>    endif</l>
<c>    * </c>
<c>    * Parse the generic parameters</c>
<c>    * - First, all parameters that are understood by set_scene_3d_instance_param</c>
<l>    AlphaOrig := gen_tuple_const(NumModels,1)</l>
<l>    for I := 0 to |GenParamName| - 1 by 1</l>
<l>        ParamName := GenParamName[I]</l>
<l>        ParamValue := GenParamValue[I]</l>
<c>        * Check if this parameter is understood by set_scene_3d_param</c>
<l>        if (ParamName == 'alpha')</l>
<l>            AlphaOrig := gen_tuple_const(NumModels,ParamValue)</l>
<l>        endif</l>
<l>        try</l>
<l>            set_scene_3d_param (Scene3D, ParamName, ParamValue)</l>
<l>            continue</l>
<l>        catch (Exception)</l>
<l>            if (Exception[0] == 1203 or Exception[0] == 1303)</l>
<l>                throw ('Wrong type or value for parameter ' + ParamName + ': ' + ParamValue)</l>
<l>            endif</l>
<l>        endtry</l>
<c>        * Check if it is a parameter that is valid for only one instance</c>
<c>        * and therefore can be set only with set_scene_3d_instance_param</c>
<l>        ParamNameTrunk := regexp_replace(ParamName,'_\\d+$','')</l>
<l>        if (ParamName == ParamNameTrunk)</l>
<l>            Instance := [0:NumModels - 1]</l>
<l>        else</l>
<l>            Instance := number(regexp_replace(ParamName,'^' + ParamNameTrunk + '_(\\d+)$','$1'))</l>
<l>            if (Instance &lt; 0 or Instance &gt; NumModels - 1)</l>
<l>                throw ('Parameter ' + ParamName + ' refers to a non existing 3D object model')</l>
<l>            endif</l>
<l>        endif</l>
<l>        try</l>
<l>            set_scene_3d_instance_param (Scene3D, Instance, ParamNameTrunk, ParamValue)</l>
<l>        catch (Exception)</l>
<l>            if (Exception[0] == 1204 or Exception[0] == 1304)</l>
<l>                throw ('Wrong type or value for parameter ' + ParamName + ': ' + ParamValue)</l>
<l>            elseif (Exception[0] == 1203 or Exception[0] == 1303)</l>
<l>                throw ('Wrong parameter name ' + ParamName)</l>
<l>            else</l>
<l>                throw (Exception)</l>
<l>            endif</l>
<l>        endtry</l>
<l>        if (ParamNameTrunk == 'alpha')</l>
<l>            AlphaOrig[Instance] := ParamValue</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * </c>
<c>    * Start the visualization loop</c>
<l>    pose_to_hom_mat3d (Poses[0:6], HomMat3D)</l>
<l>    affine_trans_point_3d (HomMat3D, Center[0], Center[1], Center[2], Qx, Qy, Qz)</l>
<l>    TBCenter := [Qx,Qy,Qz]</l>
<l>    TBSize := (0.5 + 0.5 * sum(SelectedObject) / NumModels) * TrackballRadiusPixel</l>
<l>    ButtonHold := false</l>
<l>    while (1)</l>
<l>        VisualizeTB := max(SelectedObject) != 0</l>
<l>        MaxIndex := min([|ObjectModel3D|,MaxNumModels]) - 1</l>
<c>        * Set trackball fixed in the center of the window</c>
<l>        TrackballCenterRow := Height / 2</l>
<l>        TrackballCenterCol := Width / 2</l>
<l>        if (WindowCenteredRotation == 1)</l>
<l>            try</l>
<l>                get_trackball_center_fixed (SelectedObject[0:MaxIndex], TrackballCenterRow, TrackballCenterCol, TrackballRadiusPixel, Scene3D, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], WindowHandleBuffer, CamParam, GenParamName, GenParamValue, TBCenter, TBSize)</l>
<l>            catch (Exception)</l>
<l>                disp_message (WindowHandle, 'Surface inspection mode is not available.', 'image', 5, 20, 'red', 'true')</l>
<l>                WindowCenteredRotation := 2</l>
<l>                get_trackball_center (SelectedObject[0:MaxIndex], TrackballRadiusPixel, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], TBCenter, TBSize)</l>
<l>                wait_seconds (1)</l>
<l>            endtry</l>
<l>        else</l>
<l>            get_trackball_center (SelectedObject[0:MaxIndex], TrackballRadiusPixel, ObjectModel3D[0:MaxIndex], Poses[0:(MaxIndex + 1) * 7 - 1], TBCenter, TBSize)</l>
<l>        endif</l>
<l>        dump_image_output (Image, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3D, GenParamName, GenParamValue, CamParam, Poses, ColorImage, Title, Information, Label, VisualizeTB, 'true', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObject, WindowCenteredRotation, TBCenter)</l>
<l>        dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>        dev_set_window (WindowHandle)</l>
<l>        dev_display (ImageDump)</l>
<c>        * </c>
<c>        * Check for mouse events</c>
<l>        GraphEvent := false</l>
<l>        Exit := false</l>
<l>        while (1)</l>
<c>            * </c>
<c>            * Check graphic event</c>
<l>            try</l>
<l>                get_mposition_sub_pix (WindowHandle, GraphButtonRow, GraphButtonColumn, GraphButton)</l>
<l>                if (GraphButton != 0)</l>
<l>                    if (GraphButtonRow &gt; Height - TextHeight - 25 and GraphButtonRow &lt; Height and GraphButtonColumn &gt; Width - TextWidth - 15 and GraphButtonColumn &lt; Width)</l>
<c>                        * Wait until the continue button has been released</c>
<l>                        if (WaitForButtonRelease == 'true')</l>
<l>                            while (1)</l>
<l>                                get_mposition_sub_pix (WindowHandle, GraphButtonRow, GraphButtonColumn, GraphButton)</l>
<l>                                if (GraphButton == 0 or GraphButton == [])</l>
<l>                                    if (GraphButtonRow &gt; Height - TextHeight - 25 and GraphButtonRow &lt; Height and GraphButtonColumn &gt; Width - TextWidth - 15 and GraphButtonColumn &lt; Width)</l>
<l>                                        ButtonReleased := true</l>
<l>                                    else</l>
<l>                                        ButtonReleased := false</l>
<l>                                    endif</l>
<c>                                    * </c>
<l>                                    break</l>
<l>                                endif</l>
<c>                                * Keep waiting until mouse button is released or moved out of the window</c>
<l>                            endwhile</l>
<l>                        else</l>
<l>                            ButtonReleased := true</l>
<l>                        endif</l>
<c>                        * Exit the visualization loop</c>
<l>                        if (ButtonReleased)</l>
<l>                            Exit := true</l>
<l>                            break</l>
<l>                        endif</l>
<l>                    endif</l>
<l>                    GraphEvent := true</l>
<l>                    break</l>
<l>                else</l>
<l>                    ButtonHold := false</l>
<l>                endif</l>
<l>            catch (Exception)</l>
<c>                * Keep waiting</c>
<l>            endtry</l>
<l>        endwhile</l>
<l>        if (GraphEvent)</l>
<l>            analyze_graph_event (Image, MouseMapping, GraphButton, GraphButtonRow, GraphButtonColumn, WindowHandle, WindowHandleBuffer, VirtualTrackball, TrackballSize, SelectedObject, Scene3D, AlphaOrig, ObjectModel3D, CamParam, Label, Title, Information, GenParamName, GenParamValue, Poses, ButtonHold, TBCenter, TBSize, WindowCenteredRotation, MaxNumModels, Poses, SelectedObject, ButtonHold, WindowCenteredRotation)</l>
<l>        endif</l>
<l>        if (Exit)</l>
<l>            break</l>
<l>        endif</l>
<l>    endwhile</l>
<c>    * </c>
<c>    * Display final state with persistence, if requested</c>
<c>    * Note that disp_object_model_3d must be used instead of the 3D scene</c>
<l>    if (|PersistenceParamName| &gt; 0)</l>
<l>        try</l>
<l>            disp_object_model_3d (WindowHandle, ObjectModel3D, CamParam, Poses, ['disp_background','alpha',PersistenceParamName], ['true',0.0,PersistenceParamValue])</l>
<l>        catch (Exception)</l>
<l>            stop ()</l>
<l>        endtry</l>
<l>    endif</l>
<c>    * </c>
<c>    * Compute the output pose</c>
<l>    if (gIsSinglePose)</l>
<l>        PoseOut := Poses[0:6]</l>
<l>    else</l>
<l>        PoseOut := Poses</l>
<l>    endif</l>
<c>    * </c>
<c>    * Clean up</c>
<l>    set_system ('clip_region', ClipRegion)</l>
<l>    dev_set_preferences ('graphics_window_context_menu', 'true')</l>
<l>    dev_set_preferences ('suppress_handled_exceptions_dlg', SuppressExceptDlg)</l>
<l>    dev_set_preferences ('graphics_window_mouse_wheel', WindowMouseWheel)</l>
<l>    dump_image_output (Image, WindowHandleBuffer, Scene3D, AlphaOrig, ObjectModel3D, GenParamName, GenParamValue, CamParam, Poses, ColorImage, Title, [], Label, 0, 'false', TrackballCenterRow, TrackballCenterCol, TBSize, SelectedObject, WindowCenteredRotation, TBCenter)</l>
<l>    dump_window_image (ImageDump, WindowHandleBuffer)</l>
<l>    dev_set_window (WindowHandle)</l>
<l>    dev_display (ImageDump)</l>
<l>    close_window (WindowHandleBuffer)</l>
<l>    set_part (WindowHandle, WPRow1, WPColumn1, WPRow2, WPColumn2)</l>
<l>    clear_scene_3d (Scene3D)</l>
<l>    Scene3D := []</l>
<l>catch (Exception)</l>
<l>    try</l>
<l>        if (0 &lt; |Scene3DTest|)</l>
<l>            clear_scene_3d (Scene3DTest)</l>
<l>            Scene3DTest := []</l>
<l>        endif</l>
<l>        if (0 &lt; |Scene3D|)</l>
<l>            clear_scene_3d (Scene3D)</l>
<l>            Scene3D := []</l>
<l>        endif</l>
<l>        if (0 &lt; |WindowHandleBuffer|)</l>
<l>            close_window (WindowHandleBuffer)</l>
<l>            WindowHandleBuffer := []</l>
<l>        endif</l>
<l>    catch (e)</l>
<c>        * suppress all further exceptions to return the original exception</c>
<l>    endtry</l>
<c></c>
<l>    throw (Exception)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="visualize_object_model_3d">
<abstract lang="en_US">The procedure visualize_object_model_3d displays the 3D object models of ObjectModel3D in the window with the handle WindowHandle and allows to interactively modify the object poses with the mouse. The current content of the window will be kept as background.

The pose can be modified by moving the mouse while pressing a mouse button. The default settings are:

- Rotate: Left mouse button
- Zoom: Shift + Left mouse button (or Center mouse button)
- Pan: Ctrl + Left mouse button

Furthermore, it is possible to select and deselect objects, to decrease the mouse sensitivity, and to toggle the inspection mode (see the description of the generic parameter 'inspection_mode' below):

- (De-)select object(s): Right mouse button
- Low mouse sensitivity: Alt + Mouse button
- Toggle inspection mode: Ctrl + Alt + Left mouse button

Note that the selection of individual 3D object models is only available, if the number of models is not greater than 1000 (or the value passed with the generic parameter 'max_num_selectable_models', see below).

Set CamParam and the individual poses (in PoseIn) of the 3D object models to setup the displayed scene. 
If an empty tuple is given for CamParam, visualize_object_model_3d uses default camera parameters that correspond to the window size.
PoseIn can contain either multiple poses (one for each 3D object model) or one pose for all 3D object models.
If an empty tuple is given for PoseIn, visualize_object_model_3d estimates a pose, such that all 3D object models are visible.

The parameter Title can be used to specify text that will be displayed in a box at the top of the window.

The parameter Label can be used to specify a list of labels, which are displayed aligned with the corresponding 3D object model. It must either contain one entry per 3D object model or it must be empty.

The parameter Information can be used to specify text that is displayed without a box at the bottom left of the window.

The output parameter PoseOut contains the possibly modified poses used for the visualization of the 3D object models. These poses can be used directly in disp_object_model_3d and render_object_model_3d or in visualize_object_model_3d to start the visualization with exactly the poses that have been chosen interactively.

The visualization can be configured with a set of parameters, which are given in GenParamName and GenParamValue. The detailed description  of these parameters can be found in the reference documentation of disp_object_model_3d.

The following values influence the whole scene: 

'disp_background':
Flag, if the current window content should be used as background.
Values: 'true' or 'false'
Default: 'false' 

'opengl':
Decides if  OpenGL is used to display the 3D object models. Otherwise the CPU based fallback solution is used.
Values: 'true' or 'false'
Default: 'true' 

'light_position':
Position of the light source. Must be given as a string containing four space separated floating point numbers. If the fourth number is 0.0, a directional light source is used (the first three components represent the direction), otherwise a point light source is used (with the first three components representing the position). 
Default: '-100.0 -100.0 0.0 1.0'

'light_ambient':
Ambient part of the light source. Must be given as a string containing three space separated floating point numbers.
Default value: '0.2 0.2 0.2'

'light_diffuse':
Diffuse part of the light source. Must be given as a string containing three space separated floating point numbers.
Default value: '0.8 0.8 0.8' 

'colored':
Display object models in different colors. The value of this parameter defines the number of colors that are used.
Values: 3, 6, or 12
Default: all objects are white 

'object_index_persistence':
Must be set to 'true' to enable the object index query in get_disp_object_model_3d_info.
Values: 'true' or 'false'
Default: 'false' 

'depth_persistence':
Must be set to 'true' to enable the depth query in get_disp_object_model_3d_info.
Values: 'true' or 'false'
Default: 'false' 

The following parameters can be set for all objects in the scene or for a specific object by appending the index of the object to the parameter name (e.g., 'color_0' to set the color of the first object).

'attribute'
Explicitly select in which way a 3D object model is visualized.
Values: 'auto', 'faces', 'primitive', 'points', 'lines'
Default Value: 'auto'

'color':
Color of the 3D object model. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers between '00' and 'ff', respectively.
Values: 'red', 'green', ...
Default value: 'white'

'alpha':
Transparency of the 3D object models. Displaying 3D object models with transparency set to less than 1.0 may significantly increase the runtime ofdisplay_scene_3d and render_scene_3d.
Values: floating point value between 0.0 (fully transparent) and 1.0 (fully opaque).
Default value: 1.0

'disp_pose':
Flag, if the pose of the 3D object models should be visualized.
Values: 'true' or 'false'
Default value: 'false'

'disp_lines':
Flag, if the contours of the 3D object models' polygons should be displayed.
Values: 'true' or 'false'
Default value: 'false'

'disp_normals':
Flag, if the surface normals of the 3D object models should be visualized.
Values: 'true' or 'false'
Default value: 'false'

'line_color':
Color of the lines if 'disp_lines' is set to 'true'. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers.
Values: 'red', 'green', ...
Default value: The value of 'color'

'line_width':
Sets the width of lines in pixel.
Default value: 1.0

'normal_color':
Color of the visualized normals if 'disp_normals' is set to 'true'. The available colors can be queried with the operator query_color. In addition, the color may be specified as an RGB triplet in the form '#rrggbb', where 'rr', 'gg', and 'bb' are hexadecimal numbers.
Values: 'red', 'green', ...
Default value: The value of 'color'

'point_size':
Sets the diameter of the points in pixel.
Default value: 3.5

'lut':
Sets the LUT that transforms the values of the attribute set with 'color_attrib' into a color.
See set_lut for available LUTs. If 'lut' is set to anything but 'default', 'color' is ignored.
Default value: 'default'

'color_attrib':
Name of a point attribute that is used for false color visualization.
If an attribute is set, the color of the displayed 3D points is determined by the point's attribute value and the currently set LUT (see 'lut'). This way, it is possible to visualize attributes in false colors.
Example: If 'color_attrib' is set to 'coord_z', and 'lut' is set to 'color1', the z-coordinates will be color coded from red to blue.
If 'lut' is set to 'default', the attribute values are used to scale the color that was set by the parameter 'color'.
If 'lut' is set to a different value, the attribute values of all points are internally scaled to the interval [0,255] and used as input value for the LUT function.
The mapping is also controlled by the parameters 'color_attrib_start' and 'color_attrib_end' (see below).
If faces are displayed, their color is interpolated between the color of the corner points.
Values: 'none', '&amp;distance', 'coord_x', 'coord_y', 'coord_z', user defined point attributes, or any other point attribute available.
Default: 'none'

'color_attrib_start','color_attrib_end':
The range of interest of the values of the attribute set with 'color_attrib'.
The attribute values between 'color_attrib_start' and 'color_attrib_end' are scaled to the start and end of the selected LUT. Attribute values outside the selected range are clipped. This allows to use a fixed color mapping which will not be distorted by outliers.
If set to 'auto', the minimum attribute value is mapped to the start of the LUT, the maximum is mapped to the end of the LUT, except if 'color_attrib' is 'normal_x','normal_y', or 'normal_z'. In this case, start and end are automatically set to -1 and 1.
It is possible to enter start value that is higher than the end value. This will in effect flip the used LUT.
Values: 0, 0.1, 1, 100, 255, ...
Default value: 'auto'

'red_channel_attrib', 'green_channel_attrib', 'blue_channel_attrib':
Name of a point attribute that is used for the red, green, or blue color channel.
This is most useful when used with a group of three connected attributes, like RGB colors or normal vectors. This way it is possible to display points in colored texture, e.g., display the object model with overlayed RGB-sensor data, or display point normals in false colors.
To display only a single attribute in false colors, please use 'color_attrib' (see above).
By default, the attribute values are assumed to lie between 0 and 255. If the attributes have a different range, you additionally have to set the parameters'rgb_channel_attrib_start' and 'rgb_channel_attrib_end' (see below).
If only 1 or 2 channels are set, the remaining channels use the RGB value of the color set with 'color'.
If faces are displayed, their color is interpolated between the color of the corner points.
Values: 'none', '&amp;red','&amp;green','&amp;blue', 'normal_x', 'normal_y', 'normal_z', user defined point attributes, or any other point attribute available.
Default: 'none'

'rgb_channel_attrib_start', 'rgb_channel_attrib_end':
The range of interest of the values of attributes set with 'red_channel_attrib', 'green_channel_attrib', and 'blue_channel_attrib'.
These parameters define the value range that is scaled to the full RGB channels. This is useful, if the input attribute values are not in the interval [0,255].
If set to 'auto', the minimum attribute value is mapped to 0, the maximum is mapped to 255, except if the attribute is 'normal_x', 'normal_y', or 'normal_z'. In this case, start and end are automatically set to -1 and 1.
It is possible to enter start value that is higher than the end value. This will in effect invert the displayed RGB colors.
The range can be set for the channels individually by replacing 'rgb' in the parameter name with the channel name, e.g., 'green_channel_attrib_start'.
Values: 'auto', 0, 0.1, 1, 100, 255, ...
Default values: 0, 255

The following value defines the maximum number of models, for which the selection of individual models is available:

'max_num_selectable_models':
Number of 3D Object models that can be selected and handled individually. If there are more models passed then this number, some calculations are performed differently and for reasons of efficiency, the individual selection and handling of models is not supported anymore.
Values: 1, 2, ...
Default: 1000

The following value influences the handling how the pose can be modified interactively: 

'inspection_mode':
Flag that controls the initial state of the inspection mode.
If 'inspection_mode' is set to 'standard', the rotation center is fixed in the center of the displayed object. In this mode, the rotation center is indicated by a vertical cross (+). This mode is  particularly well suited for getting an impression of the whole object.
If 'inspection_mode' is set to 'surface', the rotation center is fixed in the center of the window and it lies on the surface of the displayed object. In this mode, the rotation center is indicated by a diagonal cross (x). This mode is particularly well suited for a detailed inspection of the object's surface. It is less suitable for the inspection of point clouds, because they do not provide surface information.
Note that the trackball itself is kept in the center of the image, regardless of the selected inspection mode. Note also that the inspection mode can be toggled interactively during the visualization with Ctrl + Alt + Left mouse button (see above).
Values: 'standard' or 'surface'
Default: 'standard''
  </abstract>
<alternatives>
<item>disp_object_model_3d</item>
</alternatives>
<chapters lang="de_DE">
<item>Graphik</item>
<item>Ausgabe</item>
</chapters>
<chapters lang="en_US">
<item>Graphics</item>
<item>Output</item>
</chapters>
<example lang="en_US">read_object_model_3d ('pipe_joint', 'm', [], [], ObjectModel3D1, Status)
read_object_model_3d ('clamp_sloped', 'mm', [], [], ObjectModel3D2, Status)
gen_cam_par_area_scan_division (0.016, 0, 5e-6, 5e-6, 320, 240, 640, 480, CamParam)
get_cam_par_data (CamParam, 'image_width', Width)
get_cam_par_data (CamParam, 'image_height', Height)
dev_open_window (0, 0, Width, Height, 'black', WindowHandle)
create_pose (-0.02, 0.01, .6, 110, 5, 320, 'Rp+T', 'gba', 'point', Pose1)
create_pose (0.01, 0.03, .6, 130, 315, 340, 'Rp+T', 'gba', 'point', Pose2)
visualize_object_model_3d (WindowHandle, [ObjectModel3D1, ObjectModel3D2], \ 
                           CamParam, [Pose1, Pose2], \
                           ['alpha', 'color_0', 'color_1', 'disp_pose'], \
                           [0.5,     'orange',  'yellow',  'true'], \
                           ['3D visualization demo'], ['pipe joint', 'clamp'], \
                           ['Use mouse to change view'], PoseOut)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>read_object_model_3d</item>
<item>gen_object_model_3d_from_points</item>
</predecessor>
<see_also>
<item>disp_object_model_3d</item>
</see_also>
<short lang="en_US">Interactively display 3D object models</short>
<successor>
<item>clear_object_model_3d</item>
</successor>
<parameters>
<parameter id="CamParam">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">Camera parameters of the scene.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="GenParamName">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Names of the generic parameters. All generic parameters of disp_object_model_3d can be passed here as well.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>'alpha'</item>
<item>'attribute'</item>
<item>'color'</item>
<item>'colored'</item>
<item>'disp_background'</item>
<item>'disp_lines'</item>
<item>'disp_normals'</item>
<item>'disp_pose'</item>
<item>'inspection_mode'</item>
<item>'intensity'</item>
<item>'intensity_red'</item>
<item>'intensity_green'</item>
<item>'intensity_blue'</item>
<item>'light_position'</item>
<item>'light_ambient'</item>
<item>'light_diffuse'</item>
<item>'line_color'</item>
<item>'line_width'</item>
<item>'lut'</item>
<item>'max_num_selectable_models'</item>
<item>'normal_color'</item>
<item>'point_size'</item>
</values>
</parameter>
<parameter id="GenParamValue">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Values of the generic parameters. All generic parameters of disp_object_model_3d can be passed here as well.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>any</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
<item>string</item>
</type_list>
<values>
<item>'true'</item>
<item>'false'</item>
<item>'coord_x'</item>
<item>'coord_y'</item>
<item>'coord_z'</item>
<item>'red'</item>
<item>'green'</item>
<item>'blue'</item>
<item>'auto'</item>
<item>'faces'</item>
<item>'primitive'</item>
<item>'points'</item>
<item>'lines'</item>
<item>'normal_x'</item>
<item>'normal_y,'normal_z'</item>
<item>'standard'</item>
<item>'surface'</item>
</values>
</parameter>
<parameter id="Information">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed in the lower left corner of the output graphics window.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Label">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed at the position of each displayed object model.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<description lang="en_US">Handles of the 3D object models.</description>
<mixed_type>false</mixed_type>
<multivalue>optional</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="PoseIn">
<default_type>real</default_type>
<default_value>[]</default_value>
<description lang="en_US">3D poses of the objects.</description>
<mixed_type>optional</mixed_type>
<multivalue>optional</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="PoseOut">
<default_type>real</default_type>
<description lang="en_US">Poses of all object models that were possibly interactively changed by the user.</description>
<mixed_type>optional</mixed_type>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
<parameter id="Title">
<default_type>string</default_type>
<default_value>[]</default_value>
<description lang="en_US">Text that is to be displayed in the upper left corner of the output graphics window.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="WindowHandle">
<default_type>integer</default_type>
<description lang="en_US">Window identifier.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>window</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="xyz_attrib_to_object_model_3d">
<interface>
<io>
<par name="X" base_type="iconic" dimension="0"/>
<par name="Y" base_type="iconic" dimension="0"/>
<par name="Z" base_type="iconic" dimension="0"/>
<par name="AttribImage" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="AttribName" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* Consistency checks:</c>
<l>count_obj (AttribImage, Number)</l>
<l>if (Number != 1)</l>
<l>    throw ('The attribute image must be an image array with exactly one object. If you want to set multiple attributes, use a multichannel image.')</l>
<l>endif</l>
<c>* </c>
<l>count_channels (AttribImage, Channels)</l>
<l>if (Channels != |AttribName|)</l>
<l>    throw ('The number of channels of the attribute image (' + Channels + ') must be equal to the number of attribute names (' + |AttribName| + ').')</l>
<l>endif</l>
<c>* </c>
<l>get_image_size (X, WidthX, HeightX)</l>
<l>get_image_size (Y, WidthY, HeightY)</l>
<l>get_image_size (Z, WidthZ, HeightZ)</l>
<l>get_image_size (AttribImage, WidthA, HeightA)</l>
<l>if (WidthX != WidthY or HeightX != HeightY or WidthX != WidthZ or HeightX != HeightZ or WidthX != WidthA or HeightX != HeightA)</l>
<l>    throw ('Image sizes do not match. The size of all input images must be equal.')</l>
<l>endif</l>
<c>* </c>
<l>get_param_info ('set_object_model_3d_attrib_mod', 'AttribName', 'value_list', AvailableAttributes)</l>
<l>tuple_regexp_select (AvailableAttributes, 'point_.*', Selection)</l>
<l>tuple_difference (AttribName, Selection, Difference)</l>
<l>tuple_regexp_select (Difference, '^[^&amp;]', InvalidParameters)</l>
<l>if (|InvalidParameters| &gt; 0)</l>
<l>    Exception := 'The following attribute names are invalid: ' + sum(InvalidParameters + ', ') + 'please use a \'&amp;\' prefix for extended attributes, e.g., \'&amp;' + InvalidParameters[0] + '\', or a standard point attribute.'</l>
<l>    throw (Exception)</l>
<l>endif</l>
<c>* </c>
<c>* Get the domain of the images containing the 3D points and get the region all</c>
<c>* three of them share. This is because xyz_to_object_model_3d only uses points</c>
<c>* in the intersecting domains of all three images.</c>
<l>get_domain (X, DomainX)</l>
<l>get_domain (Y, DomainY)</l>
<l>get_domain (Z, DomainZ)</l>
<l>intersection (DomainX, DomainY, RegionIntersectionTmp)</l>
<l>intersection (RegionIntersectionTmp, DomainZ, RegionIntersection)</l>
<c>* </c>
<c>* Transform the images that contain the X, Y, and Z-coordinates to a 3D object model.</c>
<l>xyz_to_object_model_3d (X, Y, Z, ObjectModel3D)</l>
<c>* </c>
<c>* Loop through all channels and collect the cooresponding attribute values</c>
<l>AttribValues := []</l>
<l>for Index := 1 to Channels by 1</l>
<l>    access_channel (AttribImage, Channel, Index)</l>
<l>    get_region_points (RegionIntersection, Rows, Columns)</l>
<l>    get_grayval (Channel, Rows, Columns, AttribValuesTmp)</l>
<l>    AttribValues := [AttribValues,AttribValuesTmp]</l>
<l>endfor</l>
<c>* </c>
<c>* Set the attributes</c>
<l>set_object_model_3d_attrib_mod (ObjectModel3D, AttribName, 'points', AttribValues)</l>
<l>return ()</l>
</body>
<docu id="xyz_attrib_to_object_model_3d">
<abstract lang="en_US">The procedure xyz_attrib_to_object_model_3d transforms the images X, Y, and Z into a 3D object model ObjectModel3D. Additionally, it sets the point attributes in AttribName to the values in AttribImage.

The procedure can be used, e.g., to create a 3D object model that uses an RGB image to set the extended attributes '&amp;amp;red', '&amp;amp;green', and '&amp;amp;blue'. Then, as seen in the example code below, the procedure visualize_object_model_3d can be used to display the object model with the respective texture.

AttribImage can be a multichannel image. The number of channels of the attribute image must be equal to the size of the tuple AttribName. Additionally, the images X, Y, Z, and AttribImage must be the same size.

Only points in the intersecting domains of the X, Y, and Z-image are used. The domain of AttribImage is ignored. The created 3D object model contains the coordinates of the points, as well as the xyz mapping attribute that contains the original row and column of each 3D point. Points where one of the coordinates is infinity or "Not a Number" (NaN) are ignored and not added to the 3D object model.

Note that if a 3D object model is no longer needed or should be overwritten, the memory has to be freed first by calling the operator clear_object_model_3d.</abstract>
<alternatives>
<item>xyz_to_object_model_3d</item>
<item>set_object_model_3d_attrib</item>
</alternatives>
<chapters lang="de_DE">
<item>3D-Objektmodell</item>
<item>Transformationen</item>
</chapters>
<chapters lang="en_US">
<item>3D Object Model</item>
<item>Transformations</item>
</chapters>
<example lang="en_US">xyz_attrib_to_object_model_3d (X, Y, Z, ImageRGB, ['&amp;amp;red', '&amp;amp;green', '&amp;amp;blue'], ObjectModel3D)
prepare_object_model_3d (ObjectModel3D, 'segmentation', 'true', [], [])
visualize_object_model_3d (WindowHandle, ObjectModel3D, [], [], ['red_channel_attrib', 'green_channel_attrib', 'blue_channel_attrib'], ['&amp;amp;red', '&amp;amp;green', '&amp;amp;blue'], [], [], [], PoseOut)</example>
<library lang="en_US">MVTec Standard Procedures</library>
<predecessor>
<item>disparity_image_to_xyz</item>
</predecessor>
<short lang="en_US">Transform 3D points from images to a 3D object model, and add extended attributes to the points of the object model.</short>
<successor>
<item>prepare_object_model_3d</item>
<item>select_points_object_model_3d</item>
</successor>
<parameters>
<parameter id="AttribImage">
<description lang="en_US">The (multichannel) image with the attributes.</description>
<multichannel>optional</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="AttribName">
<default_type>string</default_type>
<default_value>'&amp;gray'</default_value>
<description lang="en_US">The names of the attributes.</description>
<multivalue>optional</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
<values>
<item>['&amp;red', '&amp;green', '&amp;blue']</item>
<item>'&amp;distance'</item>
</values>
</parameter>
<parameter id="ObjectModel3D">
<default_type>integer</default_type>
<description lang="en_US">Handle of the 3D object model.</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>object_model_3d</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="X">
<description lang="en_US">Image with the X coordinates of the 3D points.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Y">
<description lang="en_US">Image with the Y coordinates of the 3D points.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
<parameter id="Z">
<description lang="en_US">Image with the Z coordinates of the 3D points.</description>
<multichannel>false</multichannel>
<multivalue>false</multivalue>
<sem_type>image</sem_type>
<type_list>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
</hdevelop>
