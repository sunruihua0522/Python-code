//
// File generated by HDevelop for HALCON/.NET (C#) Version 17.12
//
//  This file is intended to be used with the HDevelopTemplate or
//  HDevelopTemplateWPF projects located under %HALCONEXAMPLES%\c#

using System;
using HalconDotNet;

public partial class HDevelopExport
{
  public HTuple hv_ExpDefaultWinHandle;

  // Procedures 
  // External procedures 
  // Chapter: Develop
  // Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
  public void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
      HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
  {




    // Local iconic variables 

    // Local control variables 

    HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
    HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
    HTuple hv_ResizeFactor = null, hv_ImageWidth = null, hv_ImageHeight = null;
    HTuple hv_TempWidth = null, hv_TempHeight = null, hv_WindowWidth = new HTuple();
    HTuple hv_WindowHeight = null;
    // Initialize local and output iconic variables 
    hv_WindowHandle = new HTuple();
    //This procedure opens a new graphics window and adjusts the size
    //such that it fits into the limits specified by WidthLimit
    //and HeightLimit, but also maintains the correct image aspect ratio.
    //
    //If it is impossible to match the minimum and maximum extent requirements
    //at the same time (f.e. if the image is very long but narrow),
    //the maximum value gets a higher priority,
    //
    //Parse input tuple WidthLimit
    if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
    {
      hv_MinWidth = 500;
      hv_MaxWidth = 800;
    }
    else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinWidth = 0;
      hv_MaxWidth = hv_WidthLimit.Clone();
    }
    else
    {
      hv_MinWidth = hv_WidthLimit.TupleSelect(0);
      hv_MaxWidth = hv_WidthLimit.TupleSelect(1);
    }
    //Parse input tuple HeightLimit
    if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
    {
      hv_MinHeight = 400;
      hv_MaxHeight = 600;
    }
    else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinHeight = 0;
      hv_MaxHeight = hv_HeightLimit.Clone();
    }
    else
    {
      hv_MinHeight = hv_HeightLimit.TupleSelect(0);
      hv_MaxHeight = hv_HeightLimit.TupleSelect(1);
    }
    //
    //Test, if window size has to be changed.
    hv_ResizeFactor = 1;
    HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
    //First, expand window to the minimum extents (if necessary).
    if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_ImageWidth))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
        hv_ImageHeight)))) != 0)
    {
      hv_ResizeFactor = (((((hv_MinWidth.TupleReal())/hv_ImageWidth)).TupleConcat(
          (hv_MinHeight.TupleReal())/hv_ImageHeight))).TupleMax();
    }
    hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
    //Then, shrink window to maximum extents (if necessary).
    if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
        hv_TempHeight)))) != 0)
    {
      hv_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal())/hv_TempWidth)).TupleConcat(
          (hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin());
    }
    hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
    //Resize window
    //dev_open_window(...);
    HOperatorSet.SetPart(hv_ExpDefaultWinHandle, 0, 0, hv_ImageHeight-1, hv_ImageWidth-1);

    return;
  }

  // Chapter: Filters / Arithmetic
  // Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] 
  public void scale_image_range (HObject ho_Image, out HObject ho_ImageScaled, HTuple hv_Min, 
      HTuple hv_Max)
  {




      // Stack for temporary objects 
      HObject[] OTemp = new HObject[20];

      // Local iconic variables 

      HObject ho_ImageSelected=null, ho_SelectedChannel=null;
      HObject ho_LowerRegion=null, ho_UpperRegion=null, ho_ImageSelectedScaled=null;

      // Local copy input parameter variables 
      HObject ho_Image_COPY_INP_TMP;
      ho_Image_COPY_INP_TMP = ho_Image.CopyObj(1,-1);



      // Local control variables 

      HTuple hv_LowerLimit = new HTuple(), hv_UpperLimit = new HTuple();
      HTuple hv_Mult = null, hv_Add = null, hv_NumImages = null;
      HTuple hv_ImageIndex = null, hv_Channels = new HTuple();
      HTuple hv_ChannelIndex = new HTuple(), hv_MinGray = new HTuple();
      HTuple hv_MaxGray = new HTuple(), hv_Range = new HTuple();
      HTuple   hv_Max_COPY_INP_TMP = hv_Max.Clone();
      HTuple   hv_Min_COPY_INP_TMP = hv_Min.Clone();

      // Initialize local and output iconic variables 
      HOperatorSet.GenEmptyObj(out ho_ImageScaled);
      HOperatorSet.GenEmptyObj(out ho_ImageSelected);
      HOperatorSet.GenEmptyObj(out ho_SelectedChannel);
      HOperatorSet.GenEmptyObj(out ho_LowerRegion);
      HOperatorSet.GenEmptyObj(out ho_UpperRegion);
      HOperatorSet.GenEmptyObj(out ho_ImageSelectedScaled);
    //Convenience procedure to scale the gray values of the
    //input image Image from the interval [Min,Max]
    //to the interval [0,255] (default).
    //Gray values < 0 or > 255 (after scaling) are clipped.
    //
    //If the image shall be scaled to an interval different from [0,255],
    //this can be achieved by passing tuples with 2 values [From, To]
    //as Min and Max.
    //Example:
    //scale_image_range(Image:ImageScaled:[100,50],[200,250])
    //maps the gray values of Image from the interval [100,200] to [50,250].
    //All other gray values will be clipped.
    //
    //input parameters:
    //Image: the input image
    //Min: the minimum gray value which will be mapped to 0
    //     If a tuple with two values is given, the first value will
    //     be mapped to the second value.
    //Max: The maximum gray value which will be mapped to 255
    //     If a tuple with two values is given, the first value will
    //     be mapped to the second value.
    //
    //Output parameter:
    //ImageScale: the resulting scaled image.
    //
    if ((int)(new HTuple((new HTuple(hv_Min_COPY_INP_TMP.TupleLength())).TupleEqual(
        2))) != 0)
    {
      hv_LowerLimit = hv_Min_COPY_INP_TMP.TupleSelect(1);
      hv_Min_COPY_INP_TMP = hv_Min_COPY_INP_TMP.TupleSelect(0);
    }
    else
    {
      hv_LowerLimit = 0.0;
    }
    if ((int)(new HTuple((new HTuple(hv_Max_COPY_INP_TMP.TupleLength())).TupleEqual(
        2))) != 0)
    {
      hv_UpperLimit = hv_Max_COPY_INP_TMP.TupleSelect(1);
      hv_Max_COPY_INP_TMP = hv_Max_COPY_INP_TMP.TupleSelect(0);
    }
    else
    {
      hv_UpperLimit = 255.0;
    }
    //
    //Calculate scaling parameters.
    hv_Mult = (((hv_UpperLimit-hv_LowerLimit)).TupleReal())/(hv_Max_COPY_INP_TMP-hv_Min_COPY_INP_TMP);
    hv_Add = ((-hv_Mult)*hv_Min_COPY_INP_TMP)+hv_LowerLimit;
    //
    //Scale image.
    {
    HObject ExpTmpOutVar_0;
    HOperatorSet.ScaleImage(ho_Image_COPY_INP_TMP, out ExpTmpOutVar_0, hv_Mult, hv_Add);
    ho_Image_COPY_INP_TMP.Dispose();
    ho_Image_COPY_INP_TMP = ExpTmpOutVar_0;
    }
    //
    //Clip gray values if necessary.
    //This must be done for each image and channel separately.
    ho_ImageScaled.Dispose();
    HOperatorSet.GenEmptyObj(out ho_ImageScaled);
    HOperatorSet.CountObj(ho_Image_COPY_INP_TMP, out hv_NumImages);
    HTuple end_val49 = hv_NumImages;
    HTuple step_val49 = 1;
    for (hv_ImageIndex=1; hv_ImageIndex.Continue(end_val49, step_val49); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val49))
    {
      ho_ImageSelected.Dispose();
      HOperatorSet.SelectObj(ho_Image_COPY_INP_TMP, out ho_ImageSelected, hv_ImageIndex);
      HOperatorSet.CountChannels(ho_ImageSelected, out hv_Channels);
      HTuple end_val52 = hv_Channels;
      HTuple step_val52 = 1;
      for (hv_ChannelIndex=1; hv_ChannelIndex.Continue(end_val52, step_val52); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val52))
      {
        ho_SelectedChannel.Dispose();
        HOperatorSet.AccessChannel(ho_ImageSelected, out ho_SelectedChannel, hv_ChannelIndex);
        HOperatorSet.MinMaxGray(ho_SelectedChannel, ho_SelectedChannel, 0, out hv_MinGray, 
            out hv_MaxGray, out hv_Range);
        ho_LowerRegion.Dispose();
        HOperatorSet.Threshold(ho_SelectedChannel, out ho_LowerRegion, ((hv_MinGray.TupleConcat(
            hv_LowerLimit))).TupleMin(), hv_LowerLimit);
        ho_UpperRegion.Dispose();
        HOperatorSet.Threshold(ho_SelectedChannel, out ho_UpperRegion, hv_UpperLimit, 
            ((hv_UpperLimit.TupleConcat(hv_MaxGray))).TupleMax());
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.PaintRegion(ho_LowerRegion, ho_SelectedChannel, out ExpTmpOutVar_0, 
            hv_LowerLimit, "fill");
        ho_SelectedChannel.Dispose();
        ho_SelectedChannel = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.PaintRegion(ho_UpperRegion, ho_SelectedChannel, out ExpTmpOutVar_0, 
            hv_UpperLimit, "fill");
        ho_SelectedChannel.Dispose();
        ho_SelectedChannel = ExpTmpOutVar_0;
        }
        if ((int)(new HTuple(hv_ChannelIndex.TupleEqual(1))) != 0)
        {
          ho_ImageSelectedScaled.Dispose();
          HOperatorSet.CopyObj(ho_SelectedChannel, out ho_ImageSelectedScaled, 1, 
              1);
        }
        else
        {
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.AppendChannel(ho_ImageSelectedScaled, ho_SelectedChannel, 
              out ExpTmpOutVar_0);
          ho_ImageSelectedScaled.Dispose();
          ho_ImageSelectedScaled = ExpTmpOutVar_0;
          }
        }
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ConcatObj(ho_ImageScaled, ho_ImageSelectedScaled, out ExpTmpOutVar_0
          );
      ho_ImageScaled.Dispose();
      ho_ImageScaled = ExpTmpOutVar_0;
      }
    }
    ho_Image_COPY_INP_TMP.Dispose();
    ho_ImageSelected.Dispose();
    ho_SelectedChannel.Dispose();
    ho_LowerRegion.Dispose();
    ho_UpperRegion.Dispose();
    ho_ImageSelectedScaled.Dispose();

    return;
  }

  // Main procedure 
  private void action()
  {


    // Local iconic variables 

    HObject ho_Image, ho_Image4, ho_Image1, ho_Image2;
    HObject ho_Image3, ho_ImageScaled, ho_Regions, ho_RegionClosing;
    HObject ho_ConnectedRegions, ho_SelectedRegions, ho_RegionDilation;
    HObject ho_Skeleton, ho_RegionFillUp, ho_Circle;

    // Local control variables 

    HTuple hv_Width = null, hv_Height = null, hv_WindowHandle = new HTuple();
    HTuple hv_Row = null, hv_Column = null, hv_Radius = null;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_Image4);
    HOperatorSet.GenEmptyObj(out ho_Image1);
    HOperatorSet.GenEmptyObj(out ho_Image2);
    HOperatorSet.GenEmptyObj(out ho_Image3);
    HOperatorSet.GenEmptyObj(out ho_ImageScaled);
    HOperatorSet.GenEmptyObj(out ho_Regions);
    HOperatorSet.GenEmptyObj(out ho_RegionClosing);
    HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
    HOperatorSet.GenEmptyObj(out ho_RegionDilation);
    HOperatorSet.GenEmptyObj(out ho_Skeleton);
    HOperatorSet.GenEmptyObj(out ho_RegionFillUp);
    HOperatorSet.GenEmptyObj(out ho_Circle);
    ho_Image.Dispose();
    HOperatorSet.ReadImage(out ho_Image, "C:/Project/GetInnerCircle/1.png");
    HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
    ho_Image4.Dispose();
    HOperatorSet.GenImageConst(out ho_Image4, "byte", hv_Width, hv_Height);
    //dev_close_window(...);
    dev_open_window_fit_image(ho_Image, 0, 0, -1, -1, out hv_WindowHandle);
    ho_Image1.Dispose();ho_Image2.Dispose();ho_Image3.Dispose();
    HOperatorSet.Decompose3(ho_Image, out ho_Image1, out ho_Image2, out ho_Image3
        );
    ho_ImageScaled.Dispose();
    scale_image_range(ho_Image1, out ho_ImageScaled, 100, 200);
    ho_Regions.Dispose();
    HOperatorSet.Threshold(ho_ImageScaled, out ho_Regions, 0, 120);
    ho_RegionClosing.Dispose();
    HOperatorSet.ClosingCircle(ho_Regions, out ho_RegionClosing, 6);
    ho_ConnectedRegions.Dispose();
    HOperatorSet.Connection(ho_RegionClosing, out ho_ConnectedRegions);
    ho_SelectedRegions.Dispose();
    HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_SelectedRegions, "width", 
        "and", 180.28, 263.76);
    ho_RegionDilation.Dispose();
    HOperatorSet.DilationCircle(ho_SelectedRegions, out ho_RegionDilation, 10);
    ho_Skeleton.Dispose();
    HOperatorSet.Skeleton(ho_RegionDilation, out ho_Skeleton);
    ho_RegionFillUp.Dispose();
    HOperatorSet.FillUp(ho_Skeleton, out ho_RegionFillUp);
    HOperatorSet.InnerCircle(ho_RegionFillUp, out hv_Row, out hv_Column, out hv_Radius);
    ho_Circle.Dispose();
    HOperatorSet.GenCircle(out ho_Circle, hv_Row, hv_Column, hv_Radius);
    HOperatorSet.ClearWindow(hv_ExpDefaultWinHandle);
    HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);
    HOperatorSet.SetDraw(hv_ExpDefaultWinHandle, "margin");
    HOperatorSet.SetLineWidth(hv_ExpDefaultWinHandle, 2);
    HOperatorSet.DispObj(ho_Circle, hv_ExpDefaultWinHandle);

    ho_Image.Dispose();
    ho_Image4.Dispose();
    ho_Image1.Dispose();
    ho_Image2.Dispose();
    ho_Image3.Dispose();
    ho_ImageScaled.Dispose();
    ho_Regions.Dispose();
    ho_RegionClosing.Dispose();
    ho_ConnectedRegions.Dispose();
    ho_SelectedRegions.Dispose();
    ho_RegionDilation.Dispose();
    ho_Skeleton.Dispose();
    ho_RegionFillUp.Dispose();
    ho_Circle.Dispose();

  }

  public void InitHalcon()
  {
    // Default settings used in HDevelop 
    HOperatorSet.SetSystem("width", 512);
    HOperatorSet.SetSystem("height", 512);
  }

  public void RunHalcon(HTuple Window)
  {
    hv_ExpDefaultWinHandle = Window;
    action();
  }

}

