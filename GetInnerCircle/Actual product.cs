//
// File generated by HDevelop for HALCON/.NET (C#) Version 17.12
//
//  This file is intended to be used with the HDevelopTemplate or
//  HDevelopTemplateWPF projects located under %HALCONEXAMPLES%\c#

using System;
using System.Windows.Forms;
using HalconDotNet;

public partial class HDevelopExport
{
  public HTuple hv_ExpDefaultWinHandle;

  public void HDevelopStop()
  {
    MessageBox.Show("Press button to continue", "Program stop");
  }

  // Procedures 
  // Chapter: Develop
  // Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
  public void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
      HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
  {




    // Local iconic variables 

    // Local control variables 

    HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
    HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
    HTuple hv_ResizeFactor = null, hv_ImageWidth = null, hv_ImageHeight = null;
    HTuple hv_TempWidth = null, hv_TempHeight = null, hv_WindowWidth = new HTuple();
    HTuple hv_WindowHeight = null;
    // Initialize local and output iconic variables 
    hv_WindowHandle = new HTuple();
    //This procedure opens a new graphics window and adjusts the size
    //such that it fits into the limits specified by WidthLimit
    //and HeightLimit, but also maintains the correct image aspect ratio.
    //
    //If it is impossible to match the minimum and maximum extent requirements
    //at the same time (f.e. if the image is very long but narrow),
    //the maximum value gets a higher priority,
    //
    //Parse input tuple WidthLimit
    if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
    {
      hv_MinWidth = 500;
      hv_MaxWidth = 800;
    }
    else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinWidth = 0;
      hv_MaxWidth = hv_WidthLimit.Clone();
    }
    else
    {
      hv_MinWidth = hv_WidthLimit.TupleSelect(0);
      hv_MaxWidth = hv_WidthLimit.TupleSelect(1);
    }
    //Parse input tuple HeightLimit
    if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
    {
      hv_MinHeight = 400;
      hv_MaxHeight = 600;
    }
    else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinHeight = 0;
      hv_MaxHeight = hv_HeightLimit.Clone();
    }
    else
    {
      hv_MinHeight = hv_HeightLimit.TupleSelect(0);
      hv_MaxHeight = hv_HeightLimit.TupleSelect(1);
    }
    //
    //Test, if window size has to be changed.
    hv_ResizeFactor = 1;
    HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
    //First, expand window to the minimum extents (if necessary).
    if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_ImageWidth))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
        hv_ImageHeight)))) != 0)
    {
      hv_ResizeFactor = (((((hv_MinWidth.TupleReal())/hv_ImageWidth)).TupleConcat(
          (hv_MinHeight.TupleReal())/hv_ImageHeight))).TupleMax();
    }
    hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
    //Then, shrink window to maximum extents (if necessary).
    if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
        hv_TempHeight)))) != 0)
    {
      hv_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal())/hv_TempWidth)).TupleConcat(
          (hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin());
    }
    hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
    //Resize window
    //dev_open_window(...);
    HOperatorSet.SetPart(hv_ExpDefaultWinHandle, 0, 0, hv_ImageHeight-1, hv_ImageWidth-1);

    return;
  }

  // Main procedure 
  private void action()
  {


    // Local iconic variables 

    HObject ho_Image=null, ho_ImageMean=null, ho_Regions1=null;
    HObject ho_RegionFillUp=null, ho_ConnectedRegions1=null;
    HObject ho_SelectedRegions=null, ho_RegionErosion=null;
    HObject ho_RegionDifference=null, ho_ImageReduced=null;
    HObject ho_Regions=null, ho_ConnectedRegions=null, ho_SelectedRegions1=null;
    HObject ho_RegionDilation=null, ho_RegionFillUp1=null, ho_SelectedRegions2=null;
    HObject ho_RegionUnion=null, ho_Rectangle=null;

    // Local control variables 

    HTuple hv_Index = null, hv_WindowHandle = new HTuple();
    HTuple hv_Area = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Area1 = new HTuple(), hv_Row1 = new HTuple();
    HTuple hv_Column1 = new HTuple(), hv_angles = new HTuple();
    HTuple hv_rectangles = new HTuple(), hv_index = new HTuple();
    HTuple hv_offset = new HTuple(), hv_Angle = new HTuple();
    HTuple hv_deltaRow = new HTuple(), hv_deltaColumn = new HTuple();
    HTuple hv_rectRow = new HTuple(), hv_rectColumn = new HTuple();
    HTuple hv_Indices = new HTuple(), hv_Sum = null;
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_ImageMean);
    HOperatorSet.GenEmptyObj(out ho_Regions1);
    HOperatorSet.GenEmptyObj(out ho_RegionFillUp);
    HOperatorSet.GenEmptyObj(out ho_ConnectedRegions1);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
    HOperatorSet.GenEmptyObj(out ho_RegionErosion);
    HOperatorSet.GenEmptyObj(out ho_RegionDifference);
    HOperatorSet.GenEmptyObj(out ho_ImageReduced);
    HOperatorSet.GenEmptyObj(out ho_Regions);
    HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegions1);
    HOperatorSet.GenEmptyObj(out ho_RegionDilation);
    HOperatorSet.GenEmptyObj(out ho_RegionFillUp1);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegions2);
    HOperatorSet.GenEmptyObj(out ho_RegionUnion);
    HOperatorSet.GenEmptyObj(out ho_Rectangle);
    //read_image (PicBlockid18773, 'C:/Users/sunru/Documents/WeChat Files/sunrh109989/FileStorage/File/2019-08/190808 五金件检测(1)/190808 五金件检测/1/2.bmp')
    for (hv_Index=10; (int)hv_Index<=10; hv_Index = (int)hv_Index + 1)
    {
      ho_Image.Dispose();
      HOperatorSet.ReadImage(out ho_Image, ("C:/Users/sunru/Documents/WeChat Files/sunrh109989/FileStorage/File/2019-08/190809/190809/2/"+hv_Index)+".bmp");
      //dev_close_window(...);
      dev_open_window_fit_image(ho_Image, 0, 0, -1, -1, out hv_WindowHandle);
      ho_ImageMean.Dispose();
      HOperatorSet.MeanImage(ho_Image, out ho_ImageMean, 19, 19);

      //select region
      HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "red");
      ho_Regions1.Dispose();
      HOperatorSet.Threshold(ho_ImageMean, out ho_Regions1, 160, 250);
      ho_RegionFillUp.Dispose();
      HOperatorSet.FillUp(ho_Regions1, out ho_RegionFillUp);
      ho_ConnectedRegions1.Dispose();
      HOperatorSet.Connection(ho_RegionFillUp, out ho_ConnectedRegions1);
      ho_SelectedRegions.Dispose();
      HOperatorSet.SelectShapeStd(ho_ConnectedRegions1, out ho_SelectedRegions, "max_area", 
          70);
      ho_RegionErosion.Dispose();
      HOperatorSet.ErosionCircle(ho_SelectedRegions, out ho_RegionErosion, 400);
      ho_RegionDifference.Dispose();
      HOperatorSet.Difference(ho_SelectedRegions, ho_RegionErosion, out ho_RegionDifference
          );


      ho_ImageReduced.Dispose();
      HOperatorSet.ReduceDomain(ho_ImageMean, ho_RegionDifference, out ho_ImageReduced
          );



      ho_Regions.Dispose();
      HOperatorSet.Threshold(ho_ImageReduced, out ho_Regions, 13, 150);
      ho_ConnectedRegions.Dispose();
      HOperatorSet.Connection(ho_Regions, out ho_ConnectedRegions);


      ho_SelectedRegions1.Dispose();
      HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_SelectedRegions1, "outer_radius", 
          "and", 20.18, 122.94);
      ho_RegionDilation.Dispose();
      HOperatorSet.DilationCircle(ho_SelectedRegions1, out ho_RegionDilation, 20);
      ho_RegionFillUp1.Dispose();
      HOperatorSet.FillUp(ho_RegionDilation, out ho_RegionFillUp1);

      ho_SelectedRegions2.Dispose();
      HOperatorSet.SelectShape(ho_RegionFillUp1, out ho_SelectedRegions2, (new HTuple("circularity")).TupleConcat(
          "area"), "and", (new HTuple(0.78073)).TupleConcat(10963.3), (new HTuple(1)).TupleConcat(
          31697.3));


      HOperatorSet.AreaCenter(ho_SelectedRegions2, out hv_Area, out hv_Row, out hv_Column);
      HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "green");
      HOperatorSet.DispCross(hv_ExpDefaultWinHandle, hv_Row, hv_Column, 86, 0);

      HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "red");
      //Find the center of whole region
      ho_RegionUnion.Dispose();
      HOperatorSet.Union1(ho_SelectedRegions2, out ho_RegionUnion);
      HOperatorSet.AreaCenter(ho_RegionUnion, out hv_Area1, out hv_Row1, out hv_Column1);
      HOperatorSet.DispCross(hv_ExpDefaultWinHandle, hv_Row1, hv_Column1, 86, 0);
      hv_angles = new HTuple();
      hv_rectangles = new HTuple();
      HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "green");
      for (hv_index=0; (int)hv_index<=5; hv_index = (int)hv_index + 1)
      {
        //index := 0
        hv_offset = 0.7;

        HOperatorSet.AngleLx(hv_Row.TupleSelect(hv_index), hv_Column.TupleSelect(
            hv_index), hv_Row1, hv_Column1, out hv_Angle);
        hv_angles = hv_angles.TupleConcat(hv_Angle);
        hv_deltaRow = (hv_Row.TupleSelect(hv_index))-hv_Row1;
        hv_deltaColumn = (hv_Column.TupleSelect(hv_index))-hv_Column1;
        hv_rectRow = (hv_offset*hv_deltaRow)+hv_Row1;
        hv_rectColumn = (hv_offset*hv_deltaColumn)+hv_Column1;
        HOperatorSet.DispCross(hv_ExpDefaultWinHandle, hv_rectRow, hv_rectColumn, 
            86, hv_Angle);

        //gen measure rectangle
        ho_Rectangle.Dispose();
        HOperatorSet.GenRectangle2(out ho_Rectangle, hv_rectRow, hv_rectColumn, hv_Angle, 
            60, 150);

        hv_rectangles = ((((((hv_rectangles.TupleConcat(hv_rectRow))).TupleConcat(
            hv_rectColumn))).TupleConcat(hv_Angle))).TupleConcat((new HTuple(60)).TupleConcat(
            150));

      }

      //sort
      HOperatorSet.TupleSortIndex(hv_angles, out hv_Indices);
      HDevelopStop();
    }

    HOperatorSet.TupleAdd(hv_Indices, 1, out hv_Sum);


    ho_Image.Dispose();
    ho_ImageMean.Dispose();
    ho_Regions1.Dispose();
    ho_RegionFillUp.Dispose();
    ho_ConnectedRegions1.Dispose();
    ho_SelectedRegions.Dispose();
    ho_RegionErosion.Dispose();
    ho_RegionDifference.Dispose();
    ho_ImageReduced.Dispose();
    ho_Regions.Dispose();
    ho_ConnectedRegions.Dispose();
    ho_SelectedRegions1.Dispose();
    ho_RegionDilation.Dispose();
    ho_RegionFillUp1.Dispose();
    ho_SelectedRegions2.Dispose();
    ho_RegionUnion.Dispose();
    ho_Rectangle.Dispose();

  }

  public void InitHalcon()
  {
    // Default settings used in HDevelop 
    HOperatorSet.SetSystem("width", 512);
    HOperatorSet.SetSystem("height", 512);
  }

  public void RunHalcon(HTuple Window)
  {
    hv_ExpDefaultWinHandle = Window;
    action();
  }

}

